<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>golang方法 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="方法在GO语言中，GO方法是作用在接受者（receiver）上的一个函数，接受者是某种类型的变量。所以在GO语言里方法是一种特殊类型的函数。接受者几乎可以是任意类型（接口、指针除外），包括结构体类型，函数类型，可以是int、bool、string或者数组别名类型。接受者不能是一个接口类型，因为接口是一个抽象定义，但是方法必须是具体的实现。接受者也不能是一个指针类型，但需要注意的是它可以是允许其他任">
<meta property="og:type" content="article">
<meta property="og:title" content="golang方法">
<meta property="og:url" content="http://example.com/2022/05/31/golang%E6%96%B9%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="方法在GO语言中，GO方法是作用在接受者（receiver）上的一个函数，接受者是某种类型的变量。所以在GO语言里方法是一种特殊类型的函数。接受者几乎可以是任意类型（接口、指针除外），包括结构体类型，函数类型，可以是int、bool、string或者数组别名类型。接受者不能是一个接口类型，因为接口是一个抽象定义，但是方法必须是具体的实现。接受者也不能是一个指针类型，但需要注意的是它可以是允许其他任">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-05-31T06:23:00.000Z">
<meta property="article:modified_time" content="2022-06-20T20:10:29.275Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="GOLANG">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-golang方法的副本" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/31/golang%E6%96%B9%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  <time class="dt-published" datetime="2022-05-31T06:23:00.000Z" itemprop="datePublished">2022-05-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/GOLANG/">GOLANG</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      golang方法
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在GO语言中，GO方法是作用在接受者（receiver）上的一个函数，接受者是某种类型的变量。所以在GO语言里方法是一种特殊类型的函数。<br>接受者几乎可以是任意类型（接口、指针除外），包括结构体类型，函数类型，可以是int、bool、string或者数组别名类型。接受者不能是一个接口类型，因为接口是一个抽象定义，但是方法必须是具体的实现。<br>接受者也不能是一个指针类型，但需要注意的是它可以是允许其他任何允许类型的指针。<br>一个类型加上它的方法就像面向对象的一个类，不同的是，在GO语言中，类型的代码和它相关的方法代码可以存在于不同的源文件中，当然它们必须在同一个包中。</p>
<h6 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h6><p>方法是函数，所以不允许方法重载，对于一个类型只能有一个给定名称的方法。但如果基于接受者类型，则允许重载，具有同样名字的方法可以在多个不同的接受者类型上存在，比如在同一个包中这样做是允许的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (a *denseMatrix) Add(b Matrix)  Matrix&#123;&#125;</span><br><span class="line">func (a *sparseMatrix) Add(b Matrix) Matrix&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法的声明</p>
</blockquote>
<p>定义方法的一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (recv receiver_type) methodName(parameter_list) (reture_value_list) &#123;...&#125;</span><br><span class="line">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为p，Connector类型的接收者变量应该命名为c等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同<br>在方法名之前，func关键字之后的括号中指定接收者。<br>如果recv是接收者的一个实例，Method1是接收者类型的一个方法名，那么方法调用遵循传统的选择器符号：recv.Method1()。<br>如果recv是一个指针，GO语言会自动解析该引用值，如果调用的方法不需要使用recv的值，可以用<code>_</code>符号替换它，如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (_ receiver_type) methodName(parameter_list) (reture_value_list) &#123;...&#125;</span><br></pre></td></tr></table></figure>
recv 与面向对象语言中的this和self等类似，但是recv并不是一个关键字，GO语言中也没有this和self关键字，所以也可以使用this和self作为接受者的实例化名字。下面是一个结构体上的简单方法的例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type TwoInts struct &#123;</span><br><span class="line">	a, b int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (tn *TwoInts) addThem() int &#123;</span><br><span class="line">	return tn.a + tn.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (tn *TwoInts) addWithParam(param int) int &#123;</span><br><span class="line">	return tn.a + tn.b + param</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	two1 := new(TwoInts)</span><br><span class="line">	two1.a = 1</span><br><span class="line">	two1.b = 2</span><br><span class="line">	fmt.Printf(&quot;plus is : %d\n&quot;, two1.addThem()) // plus is : 3</span><br><span class="line">	fmt.Printf(&quot;plus with param is : %d\n&quot;, two1.addWithParam(20)) // plus with param is : 23</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
下面是非结构体类型方法的例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type IntVector []int // 空切片</span><br><span class="line"></span><br><span class="line">func (v IntVector) Sum() (s int) &#123;</span><br><span class="line">	for _, x := range v &#123;</span><br><span class="line">		s += x</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	a := IntVector&#123;4, 5, 6&#125;</span><br><span class="line">	fmt.Println(a.Sum()) // 15</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
类型与在它上面定义的方法必须在同一个包里定义，像int、float或类似的类型属于GO语言的基本类型，开发者无法在基本类型上定义方法，除非修改GO语言的源代码。<br>比如在time.Time上定义如下方法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (t time.Time) first3Chars() string &#123;</span><br><span class="line">	return time.LocalTime().String()[0:3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果类型在非本地包定义，在非本地包上面定义的方法都会得到以下错误：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot define new methods on non-local type int</span><br></pre></td></tr></table></figure>
不过别名类型并不受这个规则限制，可以把非本地包定义的类型指定一个别名，然后在别名类型上定义方法，或者像下面这样将它作为匿名类型嵌入在一个新的结构体中。这种方式定义的方法只在这个别名类型上有效：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type nowTime struct &#123;</span><br><span class="line">	time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t nowTime) first3Chars() string &#123;</span><br><span class="line">	return t.Time.String()[0:19]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	now := nowTime&#123;time.Now()&#125;</span><br><span class="line">	fmt.Println(now.String())               // 2022-05-17 17:08:12.10256 +0800 CST m=+0.000111592</span><br><span class="line">	fmt.Println(&quot;标准格式：&quot;, now.first3Chars()) // 标准格式： 2022-05-17 17:08:12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>函数与方法的区别</p>
</blockquote>
<p>函数将变量作为参数：Function1(recv)；方法在变量上被调用：recv.Method1()。<br>当接收者是指针时，方法可以改变接收者的值或状态。这一点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。<br>接收者必须有一个显式的名字，这个名字必须在方法中被调用。receiver_type叫做“接收者类型”，这个类型必须在和方法同样的包中被声明。<br>在GO语言中，“接收者类型”对应的方法不应该写在类型结构中，就像面向对象语言的类一样，降低耦合性，类型和方法之间的关联由接收者来建立。</p>
<h6 id="为类型添加方法"><a href="#为类型添加方法" class="headerlink" title="为类型添加方法"></a>为类型添加方法</h6><p>GO语言的大多数类型都是值语义，并且都包含对应的操作方法。在需要的时候，可以给任何类型（包括内置类型）“增加”新方法，而实现某个接口时，无序从该接口继承（因为GO语言不支持面向对象思想中的继承语法），只需要实现该接口要求的所有方法既可。任何类型都可以被Any类型引用，Any类型就是空接口，即interface{}。例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Integer int</span><br><span class="line">func (i Integer) less(b Integer) bool &#123;</span><br><span class="line">    return a &lt; b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个类型中，定义了一个新类型Integer，它和int没有本质上的不同，只是为内置的int类型增加了一个新方法Less()。这样实现了Integer后，就可以让整形像一个普通的类一样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	var a Integer = 1</span><br><span class="line">	if a.less(3) &#123;</span><br><span class="line">		fmt.Println(a, &quot;less than 3&quot;) // 1 less than 3</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个Integer例子如果不使用GO语言的面向对象特性，而是用之前所说的面向过程方式实现，具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func IntegerLess(a, b Integer) bool &#123;</span><br><span class="line">	return a &lt; b</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var a Integer = 1</span><br><span class="line">	if IntegerLess(a, 5) &#123;</span><br><span class="line">		fmt.Println(&quot;a is less than b&quot;) // a is less than b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比两段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (i Integer) less(b Integer) bool &#123; // 面向对象</span><br><span class="line">	return i &lt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func IntegerLess(a, b Integer) bool &#123; // 面向过程</span><br><span class="line">	return a &lt; b</span><br><span class="line">&#125;</span><br><span class="line">a.less(2) // 面向对象的用法</span><br><span class="line">IntegerLess(a, 2) // 面向过程的用法</span><br></pre></td></tr></table></figure>
<p>可以看出，面向对象只是用了另一种语法形式来表达。GO语言中的面向对象最为直观，也无需支付额外的成本。如果要求对象必须以指针传递，有时会有额外成本，因为对象有时很小（比如4B），用指针传递兵不划算，只需要在修改对象的时候，才必须用指针。</p>
<h6 id="工厂方式创建结构体"><a href="#工厂方式创建结构体" class="headerlink" title="工厂方式创建结构体"></a>工厂方式创建结构体</h6><p>在面向对象编程中，可以通过构造字方法实现工厂模式（一般是new Object等），但是在GO语言中不能这样构造子方法，而是提供了其它的方案。以结构体为例，通常会为结构体类型定义一个工厂，按惯例，工厂的名字以new或New开头，假设定义了如下的File结构体类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type File struct &#123; // 不强制使用构造函数，首字母大写</span><br><span class="line">	fd int // 文件描述符</span><br><span class="line">	name string // 文件名</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewFile(fd int, name string) *File  &#123; // File结构体对应的工厂方法，返回一个指向结构体实例的指针</span><br><span class="line">	if fd &lt; 0 &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;File&#123;fd, name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以这么调用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f := NewFile(5, &quot;./test.txt&quot;)</span><br></pre></td></tr></table></figure>
<p>在GO语言中尝尝像上面这样在工厂方法里使用初始化来简便的实现构造函数。<br>如果File是一个机构提类型，表达式new(File)和&amp;File{}是等价的，这可以和大多数面向对象编程语言中笨拙的初始化方式做个比较：File f &#x3D; new File(…)。<br>可以说工厂实例化了类型的一个对象，就像在基于类的面向对象语言中哪那样。如果想知道结构体类型T的一个实例占用了多少内存，可以使用：size :&#x3D; unsafe.Sizeof(T{})。<br>强制使用工厂方法，通过应用可见性规则就可以禁止使用new函数，强制用户使用工厂方法，从而使类型变成私有的，就像在面向对象语言中那样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type file struct &#123; // 强制使用构造函数，首字母小写</span><br><span class="line">	fd   int    // 文件描述符</span><br><span class="line">	name string // 文件名</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewFile(fd int, name string) *file &#123;</span><br><span class="line">	if fd &lt; 0 &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;file&#123;fd, name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，在其他包使用工厂方法是不能通过new的方式私建，因为file类型是私有的，实例化该结构体的唯一方式只能通过NewFile来实现。</p>
<h6 id="基于指针对象的方法"><a href="#基于指针对象的方法" class="headerlink" title="基于指针对象的方法"></a>基于指针对象的方法</h6><p>现在知道了GO语言不支持类似其他面向对象语言的那种传统类，相反，GO语言使用结构体替代，由于GO语言支持在结构体类型上定义方法，所以这一点非常类似其他面向对象语言中的传统类方法。<br>在结构体类型上可以定义两种方法，分别基于指针接收器和基于值接收器，显然，从之前的内容可以知道，值接收器代表复制整个值到内存中，内存开销大，而基于指针的接收器只需要一个指针大小的内存。<br>因此，性能决定了指针接收器的方式更适合我们使用。recv最常见的是一个指向receiver_type的指针（因为不需要复制整个实例，但如果按值调用就会复制整个实例），特别是在接收者类型是结构体时，性能优势就更明显了。<br>如果想要方法改变接收器的数据，就在接收器的指针类型上定义该方法，否在就在普通的值类型上定义方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type HttpResponse struct &#123;</span><br><span class="line">	statusCode int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r *HttpResponse) validResponse() &#123;</span><br><span class="line">	r.statusCode = 200</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r HttpResponse) updateStatus() string &#123;</span><br><span class="line">	return fmt.Sprint(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var r1 HttpResponse // 值类型</span><br><span class="line">	r1.validResponse()</span><br><span class="line">	fmt.Println(r1.updateStatus()) // 200</span><br><span class="line"></span><br><span class="line">	r2 := new(HttpResponse) // 指针类型(new函数返回指向类型的指针)</span><br><span class="line">	r2.validResponse()</span><br><span class="line">	fmt.Println(r1.updateStatus()) // 200</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>validResponse()接收一个指向 HttpResponse 的指针，并且改变其内部成员；updateStatus()复制 HttpResponse 的值并只输出 HttpResponse 的内容，r1输出值，r2输入指针。<br>然后，在 updateStatus() 中改变接收者 r 的值，将会看到它可以正常编译，但是开始的 r 值没有改变，因为指针作为接收者不是必须的。如下例所示，Point 的值仅仅用于计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Point struct&#123; x, y, z float64 &#125;</span><br><span class="line"></span><br><span class="line">func (p Point) abs() float64 &#123;</span><br><span class="line">	return math.Sqrt(p.x*p.x + p.y*p.y + p.z*p.z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	p := &amp;Point&#123;3, 4, 5&#125; // 定义为指针减少内存占用</span><br><span class="line">	fmt.Println(p.abs()) // 7.0710678118654755</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在后续代码中，都可以使用p.abs()来替代之前的(*p).abs()这种写法</p>
<h6 id="方法值和方法表达式"><a href="#方法值和方法表达式" class="headerlink" title="方法值和方法表达式"></a>方法值和方法表达式</h6><p><font color="red">这块没搞懂，详见书的191页</font><br>我们有时会在一个表达式中执行一个甚至多个方法，比如常见的p.Distance()形式，实际上还可以将其分成两部来执行，其中p.Distance中的小数点叫做“选择器”，选择器会返回它前面那个方法（或变量）的“值”并传递给后面的那个方法（Point.Distance），其中Distance一定是一个绑定到特定接收器变量的函数，这个函数可以不通过指定其接收器既可被调用，调用时不需要指定接收器，只需要传入函数的参数既可：</p>
<p>非接口方法，不管接收器的类型是指针类型还是值类型，值对象和指针对象都可以调用</p>
<h6 id="方法和未导出字段"><a href="#方法和未导出字段" class="headerlink" title="方法和未导出字段"></a>方法和未导出字段</h6><p>当类型被明确导出时（首字母大写可被外部包调用），它的字段并没有被导出，例如p.firstName就无法被外界调用，想在另一个程序中修改护着读取可以通过面向对象语言中一个众所周知的方式来完成：提供getter和setter方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">	firstName string</span><br><span class="line">	LastName  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) FirstName() string &#123;</span><br><span class="line">	return p.firstName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) SetFirstName() (newName string) &#123;</span><br><span class="line">	p.firstName = newName</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码设置了firstName的getter和setter方法，如果需要改变Person类型中的字段的值，需要在外部调用Setter方法，下面是main.go的代码，展示如何改变未导出的字段的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;golang_test/person&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	p := new(person.Person)</span><br><span class="line">	p.LastName = &quot;wick&quot;</span><br><span class="line">	p.SetFirstName(&quot;john&quot;)</span><br><span class="line">	name := p.FirstName()</span><br><span class="line">	fmt.Println(p)    // &amp;&#123;john wick&#125;</span><br><span class="line">	fmt.Println(name) // john</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该避免多个线程同时操作对象的字段的值，这会导致线程之间产生竞争并极有可能返回无法预料的结果（无法得知那个线程最后操作了该字段的值）。如果程序执行时发生这种情况，为了安全并发访问，可以使用GO语言官方提供的sync标准库中的方法。在后面章节会通过goroutines和channels探索并发访问对象的方式。</p>
<h6 id="嵌入类型的方法和继承"><a href="#嵌入类型的方法和继承" class="headerlink" title="嵌入类型的方法和继承"></a>嵌入类型的方法和继承</h6><blockquote>
<p>嵌入类型的方法</p>
</blockquote>
<p>GO语言并不是一门传统意义上的面向对象编程语言（Java，PHP等），所以GO语言无法在语言层面上实现累得继承和亚类的实现，但由于GO语言提供了创建匿名结构体的方法，所以可以发匿名结构体嵌入具名结构体内部，这样具名结构体也会拥有其内部匿名结构体的那些方法，在效果上等于面向对象变成中的类的继承。这与Python，Ruby等语言的混入（mixin）相似。<br>下面是一个完整例子，它展示了内嵌结构体上的方法可以直接在外层类型的实例上调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type Point struct &#123;</span><br><span class="line">	x, y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Point) Abs() float64 &#123;</span><br><span class="line">	return math.Sqrt(p.x*p.x + p.y*p.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type NamedPoint struct &#123;</span><br><span class="line">	Point</span><br><span class="line">	name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	n := &amp;NamedPoint&#123;Point&#123;3, 4&#125;, &quot;test&quot;&#125;</span><br><span class="line">	fmt.Println(n.Abs()) // 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个已存在类型的字段和方法注入另一个类型即为内嵌，匿名字段上的方法“晋升”为了外层类型的方法。当然类型可以有只作用于本身实例而不作用于内嵌“父”类型的方法，可以覆写字段（像字段一样）。<br>和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (n *NamedPoint) Abs() float64 &#123;</span><br><span class="line">	return n.Point.Abs() * 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在fmt.PrintLn(n.Abs())会输出500。<br>因为一个结构体可以嵌入多个匿名类型，所以时间上可以有一个简单版本的多重继承，就像：type Child struct {Mother, Father}。在多重继承中会进一步进行讲解。<br>结构体内嵌和自己在同一个包中的结构体时，可以访问对方所有的字段和方法。</p>
<blockquote>
<p>多重继承</p>
</blockquote>
<p>多重继承在生活中很常见，比如孩子继承父母，父母是两个父级类，在大部分面向对象语言中，是不允许有多重继承的，因为这样会导致编译器变得复杂，不过由于GO语言没有类的概念，所以继承其实是内嵌结构体，通过在类型中嵌入所有必须的父类型，可以很简单的实现多重继承。GO语言的多重继承不支持多重嵌套（即父级类型内部不允许有匿名结构体字段）。<br>以下是一个例子，假设有一个类型CameraPhone，通过它可以调用Call()函数，也可以调用TakePicture()函数，但是第一个方法属于类型Phone，第二个属于类型Camera，只要嵌入这两个类型就可以解决这个问题，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type Camera struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Camera) TakePicture() string &#123;</span><br><span class="line">	return &quot;take picture&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Phone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Phone) Call() string &#123;</span><br><span class="line">	return &quot;calling&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CameraPhone struct &#123;</span><br><span class="line">	Camera</span><br><span class="line">	Phone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	cp := new(CameraPhone)</span><br><span class="line">	fmt.Println(cp.Call())        // calling</span><br><span class="line">	fmt.Println(cp.TakePicture()) // take picture</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/31/golang%E6%96%B9%E6%B3%95%E7%9A%84%E5%89%AF%E6%9C%AC/" data-id="cl4v3jgao000hacs61a762ej4" data-title="golang方法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GOLANG/" rel="tag">GOLANG</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/31/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%AF%E6%9C%AC/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          golang数据类型
        
      </div>
    </a>
  
  
    <a href="/2022/05/31/golang%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9A%84%E5%89%AF%E6%9C%AC/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">golang流程控制</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GOLANG/">GOLANG</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GOLANG/" rel="tag">GOLANG</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/GOLANG/" style="font-size: 10px;">GOLANG</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/31/golang%E5%87%BD%E6%95%B0%E7%9A%84%E5%89%AF%E6%9C%AC/">golang函数</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%8C%85%E7%9A%84%E5%89%AF%E6%9C%AC/">golang包</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%9F%BA%E7%A1%80%E7%9A%84%E5%89%AF%E6%9C%AC/">golang运算基础</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%9A%84%E5%89%AF%E6%9C%AC/">golang复合数据</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%B9%B6%E5%8F%91%E7%9A%84%E5%89%AF%E6%9C%AC/">golang并发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>