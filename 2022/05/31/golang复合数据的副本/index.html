<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>golang复合数据 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="复合数据类型复合数据类型是可以包含大量条目的数据结构，比如数组、切片和映射等。go语言的复合数据类型吸收了很多Python语言的优点，相对没有C语言那么灵活、复杂。因为引入了切片这种概念使得GO语言的代码中并不容易见到数组，切片是构建在数组智商并且提供更强大的能力和便捷的一种数据类型，学好切片有助于在编成过程中灵活处理数据。GO语言的3中复合数据类型可以让开发者管理集合数据，这3中数据类型也是GO">
<meta property="og:type" content="article">
<meta property="og:title" content="golang复合数据">
<meta property="og:url" content="http://example.com/2022/05/31/golang%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%9A%84%E5%89%AF%E6%9C%AC/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="复合数据类型复合数据类型是可以包含大量条目的数据结构，比如数组、切片和映射等。go语言的复合数据类型吸收了很多Python语言的优点，相对没有C语言那么灵活、复杂。因为引入了切片这种概念使得GO语言的代码中并不容易见到数组，切片是构建在数组智商并且提供更强大的能力和便捷的一种数据类型，学好切片有助于在编成过程中灵活处理数据。GO语言的3中复合数据类型可以让开发者管理集合数据，这3中数据类型也是GO">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-05-31T06:23:00.000Z">
<meta property="article:modified_time" content="2022-06-20T21:59:43.909Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="GOLANG">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-golang复合数据的副本" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/31/golang%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  <time class="dt-published" datetime="2022-05-31T06:23:00.000Z" itemprop="datePublished">2022-05-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/GOLANG/">GOLANG</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      golang复合数据
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>复合数据类型是可以包含大量条目的数据结构，比如数组、切片和映射等。go语言的复合数据类型吸收了很多Python语言的优点，相对没有C语言那么灵活、复杂。<br>因为引入了切片这种概念使得GO语言的代码中并不容易见到数组，切片是构建在数组智商并且提供更强大的能力和便捷的一种数据类型，学好切片有助于在编成过程中灵活处理数据。GO语言的3中复合数据类型可以让开发者管理集合数据，这3中数据类型也是GO语言核心的一部分，在标准库中被广泛应用。掌握这些数据结构后，用GO语言编写程序会变得快速、有趣。且十分灵活。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>了解数据结构，一般会从数组开始，因为数组是切片和映射的基础数据结构。了解数组的工作原理，有助于理解切片和映射提供的优雅、强大的功能。<br>数组是具有想同类型的一组已经编号且长度固定的数据项序列，这个序列可以是有序的也可以是无序的，组成数组的各个变量称为数组的元素。这种类型可以是任意的原始类型，例如int、string和自定义类型。数组长度必须是一个非负整数的常量（或常量表达式），数组长度也是数组类型的一部分，所以[20]int和[100]不是同一种类型。</p>
<p>数组的声明需要指定元素的数据类型，以及存储元素的数量（数组长度），如以下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个包含5个元素的整形数组</span><br><span class="line">var array [5]int</span><br></pre></td></tr></table></figure>
<p>数组一旦声明，它所存储的数据类型和数组长度便都不能修改了。如果需要存储更多的元素，必须先创建一个更长的数组，然后把原来的数组里的值复制到新数组里面。<br>GO语言在声明变量时，都是使用相应类型的零值来初始化变量的，数组也一样。数组初始化时，其每个元素都被初始化对应类型的零值。比如上面的整形数组里，每个元素都被初始化为0（整形的零值）<br>使用数组字面量可以快速创建并初始化数组，数组字面量可以声明数组里元素的数量，并指定每个元素的值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个包含5个元素的整形数组</span><br><span class="line">// 用具体值初始化每个元素</span><br><span class="line">var array [5]int(1,2,3,4,5)</span><br></pre></td></tr></table></figure>
<p>如果使用…来代替数组的长度，GO语言会根据初始化数组元素的数量来确定该数组的长度，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个整形数组</span><br><span class="line">// 用具体值初始化每个元素</span><br><span class="line">// 容量由初始化值的数量决定</span><br><span class="line">var array [...]int(1,2,3,4,5)</span><br></pre></td></tr></table></figure>
<p>如果知道数组的长度，还可以给特定下标指定具体值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test := [5]int&#123;1: 20, 3: 50&#125;</span><br><span class="line">// [0 20 0 50 0]</span><br></pre></td></tr></table></figure>
<h6 id="数组访问与修改"><a href="#数组访问与修改" class="headerlink" title="数组访问与修改"></a>数组访问与修改</h6><p>GO语言通过数组下标（索引位置）来读取和修改数组元素，下标（索引）从0开始，逐渐类推。元素的数目（长度或数组大小）必须是固定的并且在声明数组时就指定的（编译时需要知道数组长度以便分配内存），数组最大长度为2GB。</p>
<p><strong>访问元素</strong><br>对于数组arr[]，第一个元素是arr[0]，第三个元素是arr[2]，总体来说下标i代表的元素是arr[i]，最后一个元素是arr[len(arr)-1]</p>
<p><strong>修改元素</strong><br>数组是效率很高的数据结构，因为数组在内存分配中是连续的，要访问数组里某个单独的值，使用[]运算符既可。<br>数组的值也可以是指针，下面声明一个所有元素都是指针的数组，然后使用*运算符就可以访问元素指针所指向的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 声明包含5个元素的指向整数的数组</span><br><span class="line">// 用整形指针初始化索引为0和1的数组元素</span><br><span class="line">array := [5]*int&#123;0: new(int), 1: new(int)&#125;</span><br><span class="line">// 为索引0和1的元素赋值</span><br><span class="line">*array[0] = 10</span><br><span class="line">*array[1] = 20</span><br><span class="line"></span><br><span class="line">fmt.Println(*array[0])</span><br><span class="line">//输出为：10</span><br></pre></td></tr></table></figure>
<p>在GO语言中，数组是一个类型值，这意味着数组也可以像函数一样用在赋值操作中，变量名代表整个数组，因此同样类型的数组可以赋值类另一个数组，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个包含4个元素的字符串数组</span><br><span class="line">var array1 [5]string</span><br><span class="line">// 声明第二个包含5个元素的字符串数组并初始化</span><br><span class="line">array2 := [5]string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;</span><br><span class="line">array1 = array2</span><br></pre></td></tr></table></figure>
<p>数组作为一个变量类型，它包括数组长度和每个元素的类型两个部分。只有两部分都相同的数组才是类型相同的数组，才能相互赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个包含4个元素的字符串数组</span><br><span class="line">var array1 [4]string</span><br><span class="line">// 声明第二个包含5个元素的字符串数组并初始化</span><br><span class="line">array2 := [5]string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,&quot;d&quot;,&quot;e&quot;&#125;</span><br><span class="line">array1 = array2</span><br><span class="line">// 数组长度不同，无法赋值</span><br></pre></td></tr></table></figure>
<p>与之前的参数传递一样，如果复制数组指针，只会复制指针的值（一个地址），而不会赋值指针所指向的值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个包含3个元素的指向字符串的指针数组</span><br><span class="line">var array1 [3]*string</span><br><span class="line">// 声明第二个包含3个元素的指向字符串的指针数组</span><br><span class="line">// 使用字符串指针初始化这个数组</span><br><span class="line">array2 := [3]*string&#123;new(string), new(string), new(string)&#125;</span><br><span class="line">*array2[0] = &quot;a&quot;</span><br><span class="line">*array2[1] = &quot;b&quot;</span><br><span class="line">*array2[2] = &quot;c&quot;</span><br><span class="line"></span><br><span class="line">array1 = array2</span><br><span class="line">*array2[1] = &quot;d&quot;</span><br><span class="line">fmt.Println(*array1[1])</span><br><span class="line">// 输出d</span><br></pre></td></tr></table></figure>
<p>在上面操作中，复制操作后，两个数组指向同一组字符串，修改其中一个数组的某个值后，另一个数组的值也相应改变。</p>
<h6 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h6><p>数组本身只有一个维度，但是可以组合多个数组创建多维数组。多维数组用于管理具有依赖关系的数据（比如坐标系），下面是声明二维数组的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//声明一个二维整形数组，两个维度分别存储4个元素和2个元素</span><br><span class="line">var array [4][2]int</span><br><span class="line">//使用数组字面量来声明并初始化一个二维整形数组</span><br><span class="line">array := [4][2]int&#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;, &#123;7, 8&#125;&#125;</span><br><span class="line">//声明并初始化外层数组中索引为1和3的元素</span><br><span class="line">array := [4][2]int&#123;1: &#123;3, 4&#125;, 3: &#123;7, 8&#125;&#125;</span><br><span class="line">//声明并初始化外层数组和内层数组的单个元素</span><br><span class="line">array := [4][2]int&#123;1: &#123;0: 1&#125;, 3: &#123;1: 2&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>访问单个元素，需要组合[]运算符。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[0][1] = 1</span><br></pre></td></tr></table></figure>
<p>和一维数组一样，只要类型一致，就可以将多维数组互相赋值，又因为每个数组都是一个单独的值，所以还可以独立赋值某个维度，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将array1的索引为1的维度赋值到一个同类型的新数组里</span><br><span class="line">var array3 [2]int = array1[1]</span><br><span class="line">// 将外层数组的索引为1、内层数组的索引为0的整形值复制到新的整形变量里</span><br><span class="line">var value int = array1[1][0]</span><br></pre></td></tr></table></figure>

<h6 id="将数组传递给函数"><a href="#将数组传递给函数" class="headerlink" title="将数组传递给函数"></a>将数组传递给函数</h6><p>前面讲过，在GO语言中数组是一个值类型(value type)，所有的值类型变量在赋值和作为参数传递时都将产生一次复制操作。如果直接将数组作为函数的参数，则在函数调用时数组会复制一份作为函数参数。因此，在函数体内无法修改传入的数组的内容，因为函数内操作的只是所传入的数组的一个副本。<br>如此依赖，从内存和性能角度看，在函数间传递数组是一个开销很大的操作。特别是当这个变量是一个数组是，意味着整个数组，不管有多长，都会完整复制，并传递给函数（别忘了在函数之间传递变量时，默认以值的方式传递）<br>为了体验这个操作到底有多消耗性能，我们来创建一个包含100万个int类型元素的数组。在64位架构上，这将需要800万字节，即8MB的内存。如果声明了这种大小的数组，并传递给函数，可以想象是一个非常“重”的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个需要8MB的数组</span><br><span class="line">var array [1e6]int</span><br><span class="line">// 将数组传递给函数foo</span><br><span class="line">foo(array)</span><br><span class="line">// 函数foo接收一个包含100万个整形的数组</span><br><span class="line">func foo(array [1e6]int) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次当函数foo调用时，必须在栈上分配8MB的内存。之后，整个数组的值（大小8MB）被复制到刚分配的内存里。<br>虽然GO语言会处理这个复制操作，不过其实有一种更好且更高效分方法来处理这个操作，那就是只传入数组的指针，这样只需赋值8字节的数据而不是8MB的内存数据到栈上，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个需要8MB的数组</span><br><span class="line">var array [1e6]int</span><br><span class="line">// 将数组的地址传递给函数foo</span><br><span class="line">foo(&amp;array)</span><br><span class="line">// 函数foo接收一个包含100万个整形的数组的指针</span><br><span class="line">func foo(array *[1e6]int) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次函数foo()接受一个指向100万个整形值的数组的指针，现在将数组的地址传入函数，只需要在栈上分配8字节的内存给指针既可。<br>这个才做会更有效的利用内存，性能也更好，但是要注意，因为现在传递的事指针，所以如果改变指针指向的值，会改变共享内存的值，为了解决这个问题，就需要使用切片来更好的处理这类共享问题了。</p>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>切片是GO语言中比较特殊的数据结构，，这种数据结构更便于使用和管理数据集合。<br>切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是通过内置函数append()来实现的，这个函数</p>
<p>可以快速且搞笑地增长切片，也可以通过对切片再次切割，缩小一个切片的大小。因为切片的底层内存也是在连续内存快中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处。</p>
<h6 id="创建数组切片"><a href="#创建数组切片" class="headerlink" title="创建数组切片"></a>创建数组切片</h6><p>GO语言中创建和初始化切片的方法有几种，而能否确定切片的容量是创建切片的关键，它决定了以何种方式创建切片。</p>
<ul>
<li>make和切片字面量<br>一种创建切片的方式使用内置的make()函数。当使用make()时，需要传入一个参数，指定切片的长度，如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个长度和容量都是5的字符串切片</span><br><span class="line">slice := make([]string, 5)</span><br></pre></td></tr></table></figure>
如果只指定长度，那么切片的容量和长度也相等。也可以分别指定长度和容量，如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个长度为3容量为5的整形切片</span><br><span class="line">slice := make([]int, 3, 5)</span><br></pre></td></tr></table></figure>
分别指定长度和容量时，创建出来的切片的底层数组长度就是创建时指定的容量，但是初始化后并不能访问所有的数组元素。上面代码中的切片可以访问3个元素，而底层数组拥有5个元素，因此剩余的2个元素可以在后期操作中合并到切片，然后才可以通过切片访问这些元素。<br>基于上面这个切片创建的新的切片，新切片会和原有切片共享底层数组，也能通过后期操作来访问多余容量的元素。不过不允许创建容量小于底层数组长度的切片</li>
<li>切片字面量创建切片<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 长度和容量都是5的字符串切片</span><br><span class="line">slice := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;</span><br></pre></td></tr></table></figure>
这种方式和创建数组类似，但是不需要指定[]运算符里面的值，初始的长度和容量会基于初始化提供的元素的个数决定。<br>当时用切片字面量时，可以设置初始长度和容量，要坐的就是在初始化时给出所需的长度和容量作为索引（下标），下面的代码展示了如何创建长度和容量都是100个元素的切片：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []string&#123;99:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>nil和空切片<br>有时候程序可能需要一个值为nil的切片，只需要在声明时不做任何初始化，就会创建nil切片，如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var slice []string</span><br></pre></td></tr></table></figure>
在GO语言中，nil切片是常见的创建切片的方法。nil切片多用于标准库和内置函数，在需要描述一个目前暂时不存在的切片时，nil切片十分好用。比如，函数要求返回一个切片但是发生异常的时候，利用初始化，通过声明一个切片可以创建一个nil切片：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用make创建空的整形切片</span><br><span class="line">slice := make([]int, 0)</span><br><span class="line">// 使用切片字面量创建空的字符串切片</span><br><span class="line">slice := []string&#123;&#125;</span><br></pre></td></tr></table></figure>
nil切片在底层数组中包含0个元素，也没有分配任何存储空间。<br>此外，nil切片还可以表示空集合，比如，数据库查询返回0个查询结果时，nil切片和普通切片一样，调用append、len、cap的效果都是一样的。</li>
</ul>
<h6 id="切片之间的比较"><a href="#切片之间的比较" class="headerlink" title="切片之间的比较"></a>切片之间的比较</h6><p>切片之间是不能比较的，我们不能使用 &#x3D;&#x3D; 运算符判断两个切片是否拥有完全相同元素。切片唯一合法的比较操作是和nil比较。一个nil值的切片没有底层数组，长度和容量都为0，但是一个长度和容量都为0的切片就是nil，判断切片是否为空不能通过切片是否为nil，可以通过len()获取切片长度是否为0来判断。</p>
<p><font color="red">切片需要初始化后才可以使用。</font></p>
<h6 id="切片的删除"><a href="#切片的删除" class="headerlink" title="切片的删除"></a>切片的删除</h6><p>切片删除示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">var b []int // 声明一个新切片（也可以赋值给原有的切片a）</span><br><span class="line">b = append(a[0:2], a[3:]...)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">// [1 2 4 5]</span><br></pre></td></tr></table></figure>
<h6 id="切片的使用"><a href="#切片的使用" class="headerlink" title="切片的使用"></a>切片的使用</h6><p>给切片的某个元素赋值和给数组的某个元素赋值在方法上完全一样，使用[]运算符就可以改变某个元素的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">// 改变索引为1的值</span><br><span class="line">slice[1] = 6</span><br></pre></td></tr></table></figure>
<p>切片之所以被称之为切片，是因为每创建一个新的切片就是把底层数组切出一部分，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">// 创建一个新切片，长度和容量分别为2和4</span><br><span class="line">newSlice := slice[1:3] // 等于从2开始切割，取2，3两个值，而容量是除去1以外的原切片的长度作为容量</span><br></pre></td></tr></table></figure>
<p>执行上述代码后，就有个两个切片，它们共享同一段底层数组，但通过不同的切片会看到底层数组的不同部分。<br>第一个切片slice能访问底层数组全部5个元素的容量，之后的newSlice就不行，newSlice切片的容量为4，无法访问到指向的底层数组第一个元素之前的部分，换而言之，之前的元素是不存在的。<br>一个常见的描述是，对于底层数组容量是k的切片slice[i:j:k]，长度为j-i，容量为k-i。<br>需要注意的是，现在的两个切片共享同一个底层数组，如果一个切片修改了底层数组的共享部分，另一个也会被影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">newSlice := slice[1:3]</span><br><span class="line">newSlice[1] = 6</span><br><span class="line">// 此时slice输出为：[1 2 6 4 5]</span><br></pre></td></tr></table></figure>
<p>切片只能访问到它自身长度内的元素，试图访问超出其长度的元素将会导致语言运行时异常。</p>
<h6 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h6><p>对于数组而言，因为数组长度是固定的，使用切片的好处是可以按需增加数据集合的容量。GO语言的内置append()函数可以处理增加长度时所有的操作细节。<br>使用append()时，需要一个被操作的切片和一个要追加的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">newSlice := slice[1:3]</span><br><span class="line">newSlice = append(newSlice, 6) // 输出： [2 3 6]</span><br></pre></td></tr></table></figure>
<p>当append()被调用时会返回一个包含修改结果的新切片。函数append()只能增加新的切片的长度，而容量有可能会改变，也有可能不会改变，因为newSlice在底层数组里还有额外的可用容量，append()操作将可用的元素合并到切片的长度，并对其赋值。如果切片的底层数组没有足够的可用容量，append()会创建一个新的底层数组，将被引用的现有的值复制到新数组，再追加新的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">newSlice := append(slice, 6)</span><br></pre></td></tr></table></figure>
<p>在这个append()操作完成后，newSlice拥有一个全新的底层数组，容量为原有的两倍</p>
<p>可以通过<code>$GOROOT/src/runtime/slice.go</code>源码，查看GO语言扩容策略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.cap</span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line">if cap &gt; doublecap &#123;</span><br><span class="line">    newcap = cap</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if old.cap &lt; 1024 &#123;</span><br><span class="line">        newcap = doublecap</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Check 0 &lt; newcap to detect overflow</span><br><span class="line">        // and prevent an infinite loop.</span><br><span class="line">        for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123;</span><br><span class="line">                newcap += newcap / 4</span><br><span class="line">        &#125;</span><br><span class="line">        // Set newcap to the requested cap when</span><br><span class="line">        // the newcap calculation overflowed.</span><br><span class="line">        if newcap &lt;= 0 &#123;</span><br><span class="line">                newcap = cap</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出：</p>
<ul>
<li>首先判断，如果新申请容量(cap)大于2倍的旧容量(old.cap)，最终容量(newcap)就是新申请的容量(cap).&#x3D;。</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即(newcap&#x3D;doublecap)</li>
<li>否则判断，如果旧切片大于1024，则最终容量(newcap)就是从旧容量(old.cap)循环增加原来的四分之一，即(newcap&#x3D;old.cap,for(newcap +&#x3D; newcap&#x2F;4))，直到最终容量大于新申请的容量(cap)，即(newcap &gt;&#x3D; cap)</li>
<li>如果最终值(cap)计算溢出，则最终容量(cap)就是新申请容量(cap)</li>
</ul>
<p>需要注意的是，切片扩容还会根据切片中元素类型的不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不同。</p>
<h6 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h6><p>切片是一个集合，那么自然可以迭代其中的元素，那么自然可以迭代其中的元素，可以使用特殊关键字range，配合关键字for来迭代切片里的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slice := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">// 迭代元素并输出</span><br><span class="line">for index, value := range slice &#123;</span><br><span class="line">    fmt.printF(&quot;index : %d value : %d&quot;, index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和数组迭代类似，迭代切片时，range会返回两个值。第一个值是当前迭代到的索引位置，第二个值是该位置对应元素的一份副本。</p>
<p>注意，range创建的事每个元素的副本，而不是对该元素的引用，如下面代码所示。如果使用该值变量的地址作为指向每个元素的指针，就会造成错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slice := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">for index, value := range slice &#123;</span><br><span class="line">	fmt.Printf(&quot;value : %d valueAddr : %X elemAddr : %X\n&quot;, value, &amp;value, &amp;slice[index])</span><br><span class="line">&#125;</span><br><span class="line">/*value : 1 valueAddr : C0000B2008 elemAddr : C0000AA060</span><br><span class="line">value : 2 valueAddr : C0000B2008 elemAddr : C0000AA068</span><br><span class="line">value : 3 valueAddr : C0000B2008 elemAddr : C0000AA070</span><br><span class="line">value : 4 valueAddr : C0000B2008 elemAddr : C0000AA078</span><br><span class="line">value : 5 valueAddr : C0000B2008 elemAddr : C0000AA080*/</span><br></pre></td></tr></table></figure>
<p>上面的valueAddr之所以全部一样，是因为range执行时返回的这个value变量实际上是同一个变量，被依次不断输出，所以value的值总是相同的。因此想要获取每个元素的地址，可以使用切片变量和索引值。如果不使用索引值，可以使用空白占位符忽略这个值。</p>
<p>关键字range总是从切片头部开始迭代的，如果想对迭代做更多的控制，可以用传统的for循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">for index := 2, index &lt; len(slice), index++ &#123;</span><br><span class="line">    fmt.PrintF(&quot;index %d value %d\n&quot;, index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码用到了一个内置函数，在GO语言中，有两个特殊的内置函数len()和cap()，可以处理数组、切片和通道，对于切片，函数len()返回切片的长度，函数cap()返回切片的容量。</p>
<h6 id="限制容量"><a href="#限制容量" class="headerlink" title="限制容量"></a>限制容量</h6><p>在创建切片时，还可以使用之前没有提到的第三个索引选项。第三个索引可以用来控制新切片的容量，其目的并不是要增加容量，而是要限制容量。可以看到，允许限制新切片的容量为底层数组提供了一定的保护，可以更好的控制追加操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">// 将第三个元素做切片，并限制容量，其长度为1，容量为2</span><br><span class="line">newSlice := slice[2:3:4]</span><br></pre></td></tr></table></figure>
<p>这个切片操作执行后，新切片从底层数组引用了1个元素，容量是2个元素。具体来说，新切片引用了<code>3</code>元素，并将容量扩展到<code>4</code>元素。可以用之前的计算方法来计算新切片的长度和容量：newSlice<a href="%5B2:3:4%5D">i:j:k</a>，长度为j-i(3-2&#x3D;1)，容量为k-i(4-2&#x3D;2)。</p>
<p>和之前一样，第一个值表示新切片开始的元素的索引位置，这个例子是2。第二个值表示开始的索引位置（2）加上希望包括的元素的个数（1），2+1&#x3D;3，所以第二个元素就是3。为了设置容量，从索引位置2开始，加上希望容量中包括的元素个数（2），就得到了第三个值4。</p>
<p>如果试图设置的容量比可用的容量还大，就会得到一个语言运行时错误。</p>
<p>之前有提到过，内置函数append()会首先使用可用容量。一旦没有可用容量，会分配一个新的底层数组，这导致很容易忘记切片间正在共享同一个底层数组，一旦发生这种情况，对切片进行修改，很可能会导致随机且奇怪的问题。<br>对切片内容的修改会影响多个切片，却很难找到问题的原因。如果在创建切片时设置切片的容量长度一样，就可以强制让切片的第一个append()操作创建新的底层数组，与原有的底层数组分离。<br>新切片与原有的底层数组分离后，可以安全的进行后续的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;</span><br><span class="line">// 对第三个元素做切片并限制长度和容量都为1</span><br><span class="line">slice := source[2:3:3]</span><br><span class="line">slice = append(slice, &quot;f&quot;)</span><br></pre></td></tr></table></figure>
<p>如果不追加第三个索引，由于剩下的容量都属于slice，向slice追加<code>f</code>元素会改变原有底层数组索引为3的元素，不过因为限制了slice的容量为1，当第一次使用append()函数时，会返回一个新的底层数组，这个数组包括两个元素，并将<code>c</code>复制进来，再追加<code>f</code>，并返回了一个引用了这个底层数组的新切片。<br>因为新的切片slice拥有了自己的底层数组，所以杜绝了可能发生的问题。所以可以继续向新切片追加数据，而不会担心不小心修改了其他切片中的数据，同时也保持了为切片申请新的底层数组的便捷性。</p>
<p>内置函数append()也是一个可变参数的函数，这意味着可以在一次调用中传递多个追加的值。使用<code>...</code>运算符，可以将一个切片的所有元素追加到另一个切片中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := []int&#123;1, 2&#125;</span><br><span class="line">s2 := []int&#123;3, 4&#125;</span><br><span class="line">fmt.PrintF(&quot;%v\n&quot;, append(s1, s2...))</span><br><span class="line">// 返回[1 2 3 4]</span><br></pre></td></tr></table></figure>
<h6 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h6><p>和数组一样，切片是一维的。不过合之前提过的数组一样，可以组合多个切片形成多维切片。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := [][]int&#123;&#123;1&#125;, &#123;2, 3&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>一个包含两个元素的外层切片，每个元素包含一个内层的整形切片，外层的切片包含两个元素，每个元素都是一个切片。<br>第一个元素中的切片使用单个整数来初始化，第二个元素中的切片包括两个整数，这种组合可以让用户创建非常复杂且强大的数据结构。关于内置函数append()的规则也可以应用到组合后的切片上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := [][]int&#123;&#123;1&#125;, &#123;2, 3&#125;&#125;</span><br><span class="line">slice[0] = append(slice[0], 4)</span><br></pre></td></tr></table></figure>
<p>GO语言中使用append()函数处理追加的方式很简明：先增长切片，再将新的整形切片赋值给外层切片的第一个元素。执行以上代码以后，会为新的整形切片分配新的底层数组，然后将切片赋值到外层切片的索引为0的元素中。<br>即使是这么简单的多维切片，操作时也会设计众多布局和值。看起来在函数间像这样传递数据结构也会很复杂，不过切片本身结构很简单，可以以很小的成本在函数间传递。</p>
<h6 id="将切片传递给函数"><a href="#将切片传递给函数" class="headerlink" title="将切片传递给函数"></a>将切片传递给函数</h6><p>在函数间传递切片是指在函数间以值的方式传递切片。由于切片的尺寸很小，在函数间复制和传递切片成本很低。创建一个大切片，并将这个切片以值的方式传递给函数foo()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 分配包含100万个整形数值的切片</span><br><span class="line">slice := make([]int, 1e6)</span><br><span class="line">slice = foo(slice)</span><br><span class="line"></span><br><span class="line">func foo(slice []int) []int &#123;</span><br><span class="line">    return slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在64位架构的机器上，一个切片需要24B的内存：指针字段需要8B，长度和容量字段分别需要8B，由于切片关联的数据包含在底层数组里，并不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组。<br>在函数间传递24B的数据会非常快速、简单，这也是切片高效的地方。不需要传递指针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本。</p>
<h4 id="印射（map）"><a href="#印射（map）" class="headerlink" title="印射（map）"></a>印射（map）</h4><p>印射是一种数据结构，用于存储一系列无序的键值对（类似PHP的对象），印射基于键来存储值。印射功能强大的地方是，能够基于键快速索引数据。键就像索引一样，指向该键关联的值。</p>
<h6 id="印射的实现"><a href="#印射的实现" class="headerlink" title="印射的实现"></a>印射的实现</h6><p>因为印射也是一个数据集合，所以也可以使用类似处理数组和切片的方式来迭代印射中的元素。但是印射是无序集合，所以即使以同样的顺序来保存键值对，每次迭代印射时，元素顺序也可能不一样。无序的原因是因为印射使用了散列表。<br>GO语言的map在底层是用hash(哈希)表实现的，在<code>$GOROOT/src/pkg/runtime/hashmap.go</code>可以查看具体实现细节（不同版本golang文件存储可能不同）。GO语言的map是一个hash数组列表，而不是像C++一样使用红黑树，与传统的hashmap一样，GO语言的map由一个个bucket组成。<br>hashmap列表中的每一个元素都被称为bucket的结构体，每个bucket可以保存8个键值对，所有元素将被hash算法填入到数组的bucket中，bucket填满后，将通过一个overflow指针来扩展一个bucket，从而形成链表，已解决hash冲突的问题。简单来说，这个map就是一个bucket指针型的一维数组，而每个bucket指针下面则不定长，可能挂着bucket指针list，也可能只有一个，视hash冲突而定。</p>
<h6 id="创建印射"><a href="#创建印射" class="headerlink" title="创建印射"></a>创建印射</h6><p>GO语言中创建并初始化映射的方法有很多种，使用内置的make函数或者使用映射字面量都是常见的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个键的类型是string，值的类型为int的映射</span><br><span class="line">dict := make(map[string]int)</span><br><span class="line">// 创建一个键和值类型都为string的映射并初始化</span><br><span class="line">dict := map[string]string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>使用映射字面量是更常用的方法，映射的初始长度会根据初始化指定的键值对的数量来决定。</p>
<p>和数组、切片不同，映射可以根据新增的key-value动态伸缩，因此不存在固定长度和最大限制，但是也可以选择标明映射的初始容量capacity，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make(map[keytype]valuetype, cap)</span><br><span class="line"></span><br><span class="line">dict := make(map[string]string, 100)</span><br></pre></td></tr></table></figure>
<p>当map增长到容量上限时，如果再增加新的key-value，容量会自动加1，所以出于性能考虑，对于大的映射或者可能快速扩张的映射，即使只知道大概容量，也最好先标明。</p>
<p>映射的键可以是任何值，值的类型并不限制，内置的类型或者结构类型都可以，不过需要确定这个值可以使用<code>==</code>运算符作比较。需要注意的是，切片、函数以及包含切片的结构类型具有引用语义，都不能作为映射的键，使用这些类型会造成编译错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict := map[int][]string&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在使用一个映射键对应一组数据时，会非常有用。</p>
<h6 id="映射的使用"><a href="#映射的使用" class="headerlink" title="映射的使用"></a>映射的使用</h6><ul>
<li>元素赋值<br>通过指定适当类型的键并给这个键赋值就完成了映射的键值对赋值（需要注意的是，未初始化的映射不能直接对键赋值）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var dict map[int]int // 只声明未初始化，此时dict为nil，不可使用，需要dict = map[int]int&#123;&#125;初始化才能使用</span><br><span class="line">dict := map[int]int&#123;&#125; // 声明并自动初始化，可以使用</span><br><span class="line">dict[0] = 2</span><br><span class="line">fmt.Println(dict)</span><br><span class="line"></span><br><span class="line">// 类型为切片的映射</span><br><span class="line">mapSlice := make([]map[string]int, 8, 8) // 仅初始化了切片，map未初始化，还需要 mapSlice = make(map[string]int, 8)初始化</span><br><span class="line"></span><br><span class="line">// 类型为映射的切片</span><br><span class="line">sliceMap := make(map[string][]int, 8) // 仅初始化了map，切片未初始化，还需要sliceMap := make([]int, 8, 8)初始化</span><br></pre></td></tr></table></figure></li>
</ul>
<p>与切片类似，通过声明一个未初始化的映射可以创建一个值为nil的映射（称为nil映射），nil映射不能用于存储键值对，否则会产生语言运行时的错误。</p>
<ul>
<li>查找与遍历<br>从映射中取数据有两种方式，一种是获得值以及一个表示这个键是否存在的标志：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value, exist := colors[&quot;red&quot;]</span><br><span class="line">if exist &#123;</span><br><span class="line">    fmt.PrintLn(&quot;exist&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
另一种方式是，只返回对应的值，再判断这个值是否为0值，以此来确定键是否存在，这种只能用在映射存储的值都是非零值的情况：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value := color[&quot;red&quot;]</span><br><span class="line">if value != &quot;&quot; &#123;</span><br><span class="line">    fmt.PrintLn(&quot;exist&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在GO语言中，通过键来索引映射时，即便这个键不存在也会返回该值对应的数据类型的零值。</li>
</ul>
<p>和迭代数组和切片一样，使用range关键字可以迭代映射里的所有值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alphabet := map[string]string&#123;</span><br><span class="line">    &quot;a&quot;: &quot;A&quot;,</span><br><span class="line">    &quot;b&quot;: &quot;B&quot;,</span><br><span class="line">    &quot;c&quot;: &quot;C&quot;,</span><br><span class="line">&#125;</span><br><span class="line">for key, value := range alphabet &#123;</span><br><span class="line">	fmt.Printf(&quot;key is : %s value is %s\n&quot;, key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>元素删除<br>GO语言提供了一个内置函数delete()用于删除容器内的元素，下面是例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(alphabet, &quot;a&quot;)</span><br></pre></td></tr></table></figure>
上面代码会从alphabet中删除键位<code>a</code>的键值对，如果这个键不存在，那么这个调用将什么都不发生，也不会有什么副作用。但是如果传入的map变量的值是nil，该调用将导致程序抛出异常(panic)</li>
</ul>
<h6 id="将映射传递给函数"><a href="#将映射传递给函数" class="headerlink" title="将映射传递给函数"></a>将映射传递给函数</h6><p>在函数间传递映射并不会创造出该映射的一个副本。实际上，当映射传递给一个函数，并对这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alphabet := map[string]string&#123;</span><br><span class="line">	&quot;a&quot;: &quot;A&quot;,</span><br><span class="line">	&quot;b&quot;: &quot;B&quot;,</span><br><span class="line">	&quot;c&quot;: &quot;C&quot;,</span><br><span class="line">	&quot;d&quot;: &quot;D&quot;&#125;</span><br><span class="line"></span><br><span class="line">for key, value := range alphabet &#123;</span><br><span class="line">	fmt.Printf(&quot;key is : %s value is %s\n&quot;, key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete(alphabet, &quot;c&quot;)</span><br><span class="line"></span><br><span class="line">for key, value := range alphabet &#123;</span><br><span class="line">	fmt.Printf(&quot;key is : %s value is %s\n&quot;, key, value)</span><br><span class="line">&#125;</span><br><span class="line">//key is : a value is A</span><br><span class="line">//key is : b value is B</span><br><span class="line">//key is : d value is D</span><br></pre></td></tr></table></figure>
<p>可以看到调用了delete()函数后，alphabet映射之后的值中也不再有<code>c</code>键值对应的值。这个特性和切片类似，保证可以用很小的成本来复制映射</p>
<p>因为map的键值对顺序是无序的，所以有些时候可以通过特殊的方法来对其进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dict := make(map[string]int, 100)</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 50; i++ &#123;</span><br><span class="line">	key := fmt.Sprintf(&quot;stu%02d&quot;, i)</span><br><span class="line">	value := rand.Intn(50)</span><br><span class="line">	dict[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(dict)</span><br><span class="line">mapKey := make([]string, 0)</span><br><span class="line"></span><br><span class="line">for oldKey := range dict &#123;</span><br><span class="line">	mapKey = append(mapKey, oldKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Strings(mapKey)</span><br><span class="line"></span><br><span class="line">for _, v := range mapKey &#123;</span><br><span class="line">	fmt.Println(v, dict[v])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是根据key值对映射进行排序，如果想根据value值对映射排序，可以使用struct存放key和value，实现sort接口，调用sort.Sort进行排序</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/31/golang%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%9A%84%E5%89%AF%E6%9C%AC/" data-id="cl4v3jgaj0005acs6h0e10dvm" data-title="golang复合数据" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GOLANG/" rel="tag">GOLANG</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/31/golang%E5%9F%BA%E7%A1%80%E7%9A%84%E5%89%AF%E6%9C%AC/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          golang运算基础
        
      </div>
    </a>
  
  
    <a href="/2022/05/31/golang%E5%B9%B6%E5%8F%91%E7%9A%84%E5%89%AF%E6%9C%AC/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">golang并发</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GOLANG/">GOLANG</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GOLANG/" rel="tag">GOLANG</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/GOLANG/" style="font-size: 10px;">GOLANG</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/31/golang%E5%87%BD%E6%95%B0%E7%9A%84%E5%89%AF%E6%9C%AC/">golang函数</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%8C%85%E7%9A%84%E5%89%AF%E6%9C%AC/">golang包</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%9F%BA%E7%A1%80%E7%9A%84%E5%89%AF%E6%9C%AC/">golang运算基础</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%9A%84%E5%89%AF%E6%9C%AC/">golang复合数据</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%B9%B6%E5%8F%91%E7%9A%84%E5%89%AF%E6%9C%AC/">golang并发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>