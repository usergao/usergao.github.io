

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="GM">
  <meta name="keywords" content="">
  
    <meta name="description" content="函数我们已经认识了main()函数，是程序的入口，因为go 是编译型语言，所以函数编写的顺序无关紧要，但是为了可读性，一般把main（）函数卸载文件前面，但是其他函数需要按照一定的逻辑顺序编写。 认识函数在golang中，函数和其他语言的方法不一样，有明显的区分，函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接受者的，而方法是有接受者的，方法要么属于一个结构体，要么数以一个新定义的类型">
<meta property="og:type" content="article">
<meta property="og:title" content="golang函数">
<meta property="og:url" content="https://usergao.github.io/2022/05/31/golang%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="GM的博客">
<meta property="og:description" content="函数我们已经认识了main()函数，是程序的入口，因为go 是编译型语言，所以函数编写的顺序无关紧要，但是为了可读性，一般把main（）函数卸载文件前面，但是其他函数需要按照一定的逻辑顺序编写。 认识函数在golang中，函数和其他语言的方法不一样，有明显的区分，函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接受者的，而方法是有接受者的，方法要么属于一个结构体，要么数以一个新定义的类型">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-31T06:23:00.000Z">
<meta property="article:modified_time" content="2022-07-30T22:46:32.400Z">
<meta property="article:author" content="GM">
<meta property="article:tag" content="GOLANG">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>golang函数 - GM的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"usergao.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>GM的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="golang函数"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-31 14:23" pubdate>
          2022年5月31日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          131 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">golang函数</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>我们已经认识了main()函数，是程序的入口，因为go 是编译型语言，所以函数编写的顺序无关紧要，但是为了可读性，一般把main（）函数卸载文件前面，但是其他函数需要按照一定的逻辑顺序编写。</p>
<h4 id="认识函数"><a href="#认识函数" class="headerlink" title="认识函数"></a>认识函数</h4><p>在golang中，函数和其他语言的方法不一样，有明显的区分，函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接受者的，而方法是有接受者的，方法要么属于一个结构体，要么数以一个新定义的类型。（？？？？？）</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>一个完整的函数声明结构格式如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func func<span class="hljs-constructor">Name(<span class="hljs-params">input1</span> <span class="hljs-params">type1</span>, <span class="hljs-params">input2</span> <span class="hljs-params">type2</span>)</span>(output1 type1, outtype2 type2)  &#123;<br>	return value1, value2 <span class="hljs-comment">// 返回多值</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>从以上可以看出 func 是用来声明函数的，而 funcName 是指函数名称（匿名函数和lambda函数除外）。函数名称如果是小写的，它的作用于只属于所声明的包，不能被其它包调用。如果函数名以大写字母开头，则该函数是公开的，可以被其他包调用。这是go语言中大小写的用处，这个规则适用于所有变量、函数等实体对象的声明，类似PHP的作用于关键字（private、public、protect等）。</p>
<p>此外，go语言不支持嵌套（nested）、重载（overload）和默认参数（default parameter）。</p>
<p>声明一个在外部定义的函数只需给出函数名和函数签名，不需要写出完整的函数体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(str, num <span class="hljs-type">int</span>)</span></span> <span class="hljs-comment">// 外部实现</span><br></code></pre></td></tr></table></figure>
<p>函数同样可以通过声明的方式作为一个函数类型被使用，就像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> addNum <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure>
<p>此处不需要函数体{}，因为函数在go语言属于一等值（first-class value），函数也可以复制给变量，例如 add :&#x3D; addNum，由于变量执行了 addNum 函数的前面，所以不能再给他赋一个具有不同签名的函数值。</p>
<p>不过函数值（functions value）之间是可以相互比较的，比如他们引用的都是相同的函数，或者返回值都是nil，则可以认为它们是相同的函数。函数不能再其他函数里面声明，也就是不能嵌套（匿名函数除外）</p>
<p><font color="red">匿名函数就是没有名字的函数</font></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">res1 := <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n1 <span class="hljs-type">int</span>, n2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> n1 + n2<br>&#125;(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>)  <span class="hljs-comment">//括号里的10,30 就相当于参数列表，分别对应n1和n2</span><br><br>fmt.Println(<span class="hljs-string">&quot;res1=&quot;</span>,res1)<br></code></pre></td></tr></table></figure>

<p>函数可以有一个或者多个参数，每个参数后面带有类型，通过 ，分割。如果参数列表中若干个相邻参数的类型相同，比如下面例子中的a和b，则可以在参数列表中省略前面变量的类型声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span>(ret <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果返回值列表中多个返回值的类型相同，也可以用同样的方式合并，如果函数只有一个返回值，也可以这样写：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">Add(<span class="hljs-params">a</span>, <span class="hljs-params">b</span> <span class="hljs-params">int</span>)</span> <span class="hljs-built_in">int</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数可以有多个返回值，也是go语言的一大特性，多返回值也意味着有时候返回值并不是全部需要</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>	<span class="hljs-keyword">var</span> b <span class="hljs-type">float32</span><br>	a, _, b = <span class="hljs-type">ThreeValues</span>()<br>	fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;int is %d, float is %f \n&quot;</span>, a, b)<br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-type">ThreeValues</span>() (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">float32</span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>.<span class="hljs-number">99</span><br>&#125;<br><br>/*<span class="hljs-type">int</span> <span class="hljs-keyword">is</span> <span class="hljs-number">5</span>, <span class="hljs-type">float</span> <span class="hljs-keyword">is</span> <span class="hljs-number">7</span>.<span class="hljs-number">990000</span> */<br></code></pre></td></tr></table></figure>
<p>代码中第一个与第三个值赋予了a和b，第二个返回值赋予了空白标识符“_”，然后自动丢弃掉</p>
<p>函数是第一类对象，可以作为参数传递，只要被调用函数的返回值个数、返回类型和返回值的顺序与调用函数所需要的参数一致，就可以把这个被调用的函数当做其他函数的参数。</p>
<p>同时建议将复杂签名定义为函数类型，以便于阅读</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pipe</span><span class="hljs-params">(ff <span class="hljs-keyword">func</span>()</span></span> <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">return</span> ff()<br>&#125;<br><br><span class="hljs-keyword">type</span> FormatFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>, x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">format</span><span class="hljs-params">(ff FormatFunc, s <span class="hljs-type">string</span>, x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> ff(s, x, y)<br>&#125;<br><br>s1 := pipe(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">300</span> &#125;)<br>s2 := format(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>, x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> fmt.Sprintf(s, x, y)<br>&#125;, <span class="hljs-string">&quot;%d, %d&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br><br>fmt.Println(s1, s2)<br><span class="hljs-comment">/*300 10, 10*/</span><br></code></pre></td></tr></table></figure>
<h6 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h6><p>函数在go语言中也是一种变量，前面多次使用type，它的类型就是所有拥有相同参数与返回值的一种函数类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isOdd</span><span class="hljs-params">(v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>	<span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEven</span><span class="hljs-params">(v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>	<span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">type</span> boolFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">filter</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>, f boolFunc)</span></span> []<span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span><br><br>	<span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> slice &#123;<br>		<span class="hljs-keyword">if</span> f(value) &#123;<br>			result = <span class="hljs-built_in">append</span>(result, value)<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> result<br>&#125;<br><br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;slice is &quot;</span>, slice)<br>odd := filter(slice, isOdd) <span class="hljs-comment">// 函数当作值传递</span><br>fmt.Println(<span class="hljs-string">&quot;odd : &quot;</span>, odd)<br>even := filter(slice, isEven) <span class="hljs-comment">// 函数当作值传递</span><br>fmt.Println(<span class="hljs-string">&quot;even : &quot;</span>, even)<br><br><span class="hljs-comment">/*	//slice is  [3 1 4 5 9 2]</span><br><span class="hljs-comment">	//odd :  [3 1 5 9]</span><br><span class="hljs-comment">	//even :  [3 1 5 9]*/</span><br></code></pre></td></tr></table></figure>

<p>上面的 boolFunc 是一个函数类型，isOdd和isEven函数的参数和返回值相同，所以在调用filter函数时使filter函数实现不同的功能</p>
<h6 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h6><p>go语言支持可变参数（有着不定数量的参数）写法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(arg ...<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>如果函数的最后一个参数是 <font color="red">…type</font> 的形式，那这个函数就是一个变参参数，且这个长度可以为0，无论变参有多少个，它们的类型始终一样<br>实例：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vim">func minOrMax(<span class="hljs-keyword">m</span> <span class="hljs-built_in">string</span>, <span class="hljs-keyword">a</span> ...<span class="hljs-keyword">int</span>) <span class="hljs-keyword">int</span> &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-keyword">a</span>) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br><br>	<span class="hljs-keyword">if</span> <span class="hljs-keyword">m</span> == <span class="hljs-string">&quot;max&quot;</span> &#123;<br>		<span class="hljs-built_in">max</span> := <span class="hljs-keyword">a</span>[<span class="hljs-number">0</span>]<br>		<span class="hljs-keyword">for</span> _, v := <span class="hljs-built_in">range</span> <span class="hljs-keyword">a</span> &#123;<br>			<span class="hljs-keyword">if</span> v &gt; <span class="hljs-built_in">max</span> &#123;<br>				<span class="hljs-built_in">max</span> = v<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span><br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">m</span> == <span class="hljs-string">&quot;min&quot;</span> &#123;<br>		<span class="hljs-built_in">min</span> := <span class="hljs-keyword">a</span>[<span class="hljs-number">0</span>]<br>		<span class="hljs-keyword">for</span> _, v := <span class="hljs-built_in">range</span> <span class="hljs-keyword">a</span> &#123;<br>			<span class="hljs-keyword">if</span> v &lt; <span class="hljs-built_in">min</span> &#123;<br>				<span class="hljs-built_in">min</span> = v<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span><br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">e</span> := -<span class="hljs-number">1</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">e</span><br>	&#125;<br>&#125;<br>// 手动填写参数<br><span class="hljs-built_in">min</span> := minOrMax(<span class="hljs-string">&quot;min&quot;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">3</span>)<br>fmt.Printf(<span class="hljs-string">&quot;min is %d&quot;</span>, <span class="hljs-built_in">min</span>)<br>age := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">22</span>, <span class="hljs-number">1</span>, <span class="hljs-number">55</span>, <span class="hljs-number">20</span>&#125;<br><span class="hljs-built_in">max</span> := minOrMax(<span class="hljs-string">&quot;max&quot;</span>, age...)<br>fmt.Printf(<span class="hljs-string">&quot;max is %d&quot;</span>, <span class="hljs-built_in">max</span>)<br>/*<span class="hljs-built_in">min</span> <span class="hljs-keyword">is</span> <span class="hljs-number">2</span><span class="hljs-built_in">max</span> <span class="hljs-keyword">is</span> <span class="hljs-number">55</span>*/<br></code></pre></td></tr></table></figure>
<p>上面的minOrMax就是使用了两种不同类型的参数，不同类型的参数需要单独声明，而可变参数必须是同一种类型<br>下面的例子就是接收一个变参并打印每个元素，比较f2和f3的区别，一个接收变参的函数可以将这个变参作为其他函数的参数进行传递</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">(arr ...<span class="hljs-type">int</span>)</span></span> &#123;<br>	f2(arr...)<br>	fmt.Println(<span class="hljs-string">&quot;&quot;</span>)<br>	f3(arr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(arr ...<span class="hljs-type">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>		fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, v)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>		fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, v)<br>	&#125;<br>&#125;<br>age := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">32</span>, <span class="hljs-number">15</span>, <span class="hljs-number">55</span>&#125;<br>f1(age...)<br><span class="hljs-comment">/*17 20 32 15 55</span><br><span class="hljs-comment">17 20 32 15 55*/</span><br></code></pre></td></tr></table></figure>
<p>变长参数可以作为对应类型的slice进行二次传递，从内部实现机制来说，类型…type本质上是一个数组切片，也就是{}type，这也是arr可以用for循环来获得每个值的原因<br>函数f2和f3的最大区别在于调用方式</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f2</span>(<span class="hljs-number">17</span> <span class="hljs-number">20</span> <span class="hljs-number">32</span> <span class="hljs-number">15</span> <span class="hljs-number">55</span>) // 可变参数，随便写多少个<br><span class="hljs-attribute">f3</span>([]int&#123;<span class="hljs-number">17</span> <span class="hljs-number">20</span> <span class="hljs-number">32</span> <span class="hljs-number">15</span> <span class="hljs-number">55</span>&#125;) // 需要加上[]int来创建一个数组切片实例<br></code></pre></td></tr></table></figure>
<p>如果可变参数是多种类型，可以指定类型为interface{}，也就是接口，下面是go语言标准库中fmt.PrintF()的函数原型：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">PrintF(<span class="hljs-params">format</span> <span class="hljs-params">string</span>, <span class="hljs-params">args</span> <span class="hljs-operator">...</span><span class="hljs-params">interface</span>&#123;&#125;)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>常用的PrintF函数就是一个变参函数，而且不限制参数类型，用interface{}传递任意类型数据是go语言的习惯用法。interface{}是类型安全的</p>
<h6 id="匿名函数与闭包"><a href="#匿名函数与闭包" class="headerlink" title="匿名函数与闭包"></a>匿名函数与闭包</h6><p>匿名函数是指不需要定义函数名的一种函数定义方式，以下就是一个简单的匿名函数例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> x + y&#125;<br></code></pre></td></tr></table></figure>
<p>因为在函数声明时没有函数名称，所以一般赋值于某个变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">argPlus := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> x + y&#125;<br>argPlus(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 返回11</span><br></code></pre></td></tr></table></figure>
<p>同时也可以匿名参数后面紧跟函数运行参数直接调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> x + y&#125;(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>
<p>函数列表的第一对扩号必须紧挨着关键字func，因为匿名函数没有名称，花括号涵盖着函数体，最后的一对扩号表示对该函数的调用</p>
<h6 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h6><p>匿名函数同样称为闭包，简单来说闭包允许调用定义在其他环境下的变量，可以让某个函数捕捉到一些外部状态，例如函数被创建时的状态。用专业的语言来说就是：一个闭包继承了函数声明时的作用域，这种状态（作用域内的变量）会共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。闭包常用作包装函数，预先定义一个或者多个参数以用以包装，另一个常见的应用就是使用闭包来完成更加简介的错误检查，闭包的体现形式，通常就是用函数返回另一个函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">j := <span class="hljs-number">5</span><br>a := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>	i := <span class="hljs-number">10</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		fmt.Printf(<span class="hljs-string">&quot;j is %d i is %d&quot;</span>, j, i)<br>	&#125;<br>&#125;()<br><br>a()<br>j = <span class="hljs-number">12</span> <span class="hljs-comment">// 将一个新的值赋予j</span><br>a()<br><span class="hljs-comment">//j is 5 i is 10j is 12 i is 10</span><br></code></pre></td></tr></table></figure>
<p>上面这个例子中，j变量的值在闭包之外初始化，当闭包第一获取j 的值时，返回的是初始化的5，第二次获取时，闭包反悔了赋值之后的j值10。在变量a指向的闭包函数中，只有内部的函数才能访问变量i，其它途径无法访问到，因此保证了i的安全性。下面是另一种不一样的写法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> f = adder()<br>	fmt.Println(f(<span class="hljs-number">1</span>))<br>	fmt.Println(f(<span class="hljs-number">2</span>))<br>	fmt.Println(f(<span class="hljs-number">3</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> <span class="hljs-comment">// 闭包中的变量可以在闭包函数体内声明，也可以在外部函数声明</span><br><br>	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(d <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;x = &quot;</span>, x, <span class="hljs-string">&quot;d = &quot;</span>, d)<br>		x += d<br>		<span class="hljs-keyword">return</span> x<br>	&#125;<br>&#125;<br><span class="hljs-comment">/*x =  0 d =  1</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">x =  1 d =  2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">x =  3 d =  3</span><br><span class="hljs-comment">6*/</span><br></code></pre></td></tr></table></figure>
<p>三次调用函数adder中变量d的值分别是1，2，3，通过func(d int) 传递，而在多次调用中，变量x的值是保留的，一开始默认为0，即0+1&#x3D;1，1+2&#x3D;3，3+3&#x3D;6，闭包函数保存并积累其中的变量的值，不管外部函数是否退出，它都能够继续操作外部函数中的局部变量，这些局部变量同样可以是参数。以下是更直观的操作：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">func <span class="hljs-selector-tag">main</span>() &#123;<br>	addNumber := <span class="hljs-built_in">getSequence</span>()<br><br>	fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">addNumber</span>())<br>	fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">addNumber</span>())<br>	fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">addNumber</span>())<br><br>	addNumber1 := <span class="hljs-built_in">getSequence</span>()<br>	fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">addNumber1</span>())<br>	fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">addNumber1</span>())<br>&#125;<br>func getSequence() func() int &#123;<br>	<span class="hljs-selector-tag">i</span> := <span class="hljs-number">0</span><br>	return <span class="hljs-built_in">func</span>() int &#123;<br>		<span class="hljs-selector-tag">i</span>++<br>		return <span class="hljs-selector-tag">i</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个例子清晰的展示了go语言闭包在环境继承方面的特性</p>
<h5 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h5><p>递归就是在运行的过程中调用自己，语法格式如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">func <span class="hljs-built_in">recursion</span>() &#123;<br>    <span class="hljs-built_in">recursion</span>()<br>&#125;<br><br><span class="hljs-built_in">recursion</span>()<br></code></pre></td></tr></table></figure>
<p>go语言支持递归，但是在使用递归时，需要设置退出条件，否则将陷入无限的循环当中。递归函数对于解决数学上的问题是非常有用的，一下实例通过go语言的递归函数实现阶乘运算：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	i := <span class="hljs-number">60</span><br>	fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>, Factorial(<span class="hljs-type">uint64</span>(i))) <span class="hljs-comment">// 因为阶乘的数字可能会过大，所以使用unint64位</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Factorial</span><span class="hljs-params">(n <span class="hljs-type">uint64</span>)</span></span> (result <span class="hljs-type">uint64</span>) &#123;<br>	<span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> &#123;<br>		result = n * Factorial(n<span class="hljs-number">-1</span>)<br>		<span class="hljs-keyword">return</span> result<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>以下是使用递归实现斐波那契数列：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, fibonacci(i))<br>	&#125;<br>&#125;<br><span class="hljs-comment">//0 1 1 2 3 5 8 13 21 34</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>		<span class="hljs-keyword">return</span> n<br>	&#125;<br>	<span class="hljs-keyword">return</span> fibonacci(n<span class="hljs-number">-2</span>) + fibonacci(n<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>递归可以优雅的解决很多问题，经常使用的快速排序就是通过递归实现的。有时候递归函数在使用时可能遇到栈溢出的问题，当大量的递归调用导致程序栈内存分配耗尽就会产生栈溢出，好在通过懒惰求值的方法可以解决这个问题，在go语言中可以通过管道（channel）和goroutine来解决</p>
<h6 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h6><p>内置函数是不需要进行导入操作就可以直接使用的函数，有些可以根据不同的类型进行操作（len、cap和append），有些用于系统级的操作（panic），不管哪种，他们都需要直接获得编译器的支持。<br>常见内置函数有如下几种：</p>
<ul>
<li>close：用于管道通信</li>
<li>len：用于返回某个类型的长度或数量（字符串、数组、切片、map和管道）</li>
<li>cap：容量的意思，用于返回某个类型的最大容量（只能用于切片和map）</li>
<li>new、make：均用于内存分配，不过new用于值类型和用户定义的类型，如自定义结构，make用于内置引用类型（切片、map和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T)分配类型T的零值并返回器地址，也就是指向类型T的指针，它也可以用于基本类型：v:&#x3D;new(int)。make(T)返回T初始化之后的值，因此它比new做更多的工作。new()是一个函数，因此要记得加上扩号。</li>
<li>copy、append：用于复制和链接切片</li>
<li>panic、recover：两者均用于错误处理机制</li>
<li>print、println：底层打印函数（部署环境中建议使用fmt包）</li>
<li>complex、real imag：用于创建和操作复数</li>
</ul>
<h4 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h4><h6 id="函数传递机制"><a href="#函数传递机制" class="headerlink" title="函数传递机制"></a>函数传递机制</h6><p>go语言的参数传递可以分为“按值传递”和“按引用传递”，默认为按值传递，传递的是参数的副本，函数接收参数副本后，使用变量的过程中可能对副本的值进行更改，但不会影响原来的变量，换句话来说，调用函数时修改参数的值，不会影响原来的实参的值，因为数值变化只会作用在副本上。<br>所以要当函数直接修改参数的值，而不是对参数的副本进行修改，就需要将参数的地址（变量名前面添加&amp;符号）传递给函数，这就是“按引用传递”，此时传递给函数的是一个指针。<br>如果把指针传递给函数，指针的值（一个地址）就会被复制，但指针的值指向的地址上的那个值不会被复制（被复制的是指针，但两个指针实际上指向的是同一个实际的值）。这样一来，修改这个指针的值，实际上意味着这个值指向的地址上的值被修改了（指针也是变量类型，有自己的地址和值，通常指针的只指向一个变量的地址，所以按引用传递其实也是按值传递）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	x := <span class="hljs-number">1</span><br>	fmt.Println(<span class="hljs-string">&quot;x= &quot;</span>, x, <span class="hljs-string">&quot;&amp;x= &quot;</span>, &amp;x)<br>	y := add(x)<br>	fmt.Println(<span class="hljs-string">&quot;x= &quot;</span>, x, <span class="hljs-string">&quot;y= &quot;</span>, y)<br>	z := add1(&amp;x)<br>	fmt.Println(<span class="hljs-string">&quot;x= &quot;</span>, x, <span class="hljs-string">&quot;z=&quot;</span>, z)<br>	fmt.Println(<span class="hljs-string">&quot;&amp;x= &quot;</span>, &amp;x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	a++<br>	<span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add1</span><span class="hljs-params">(a *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	*a++<br>	<span class="hljs-keyword">return</span> *a<br>&#125;<br><span class="hljs-comment">/*x=  1 &amp;x=  0xc0000b2008</span><br><span class="hljs-comment">x=  1 y=  2</span><br><span class="hljs-comment">x=  2 z= 2</span><br><span class="hljs-comment">&amp;x=  0xc0000b2008*/</span><br></code></pre></td></tr></table></figure>
<p>add()函数中x变量的值没有发生变化，而add1()函数中的x值变了。当调用add()的时候，add()接受的参数其实是x的副本，而不是x本身；而add1()函数接受的参数是一个指针，指向的是x的本身，所以x实际的值发生了变化<br>使用指针最明显的三个好处如下</p>
<ul>
<li>传指针可以是多个函数能操作同一个对象</li>
<li>传指针比较轻量级（8B），因为只是传内存地址，可以用指针传递体积大的结构体，如果传递值，在每次创建副本上面就会花费相对较多的系统开销（内存和时间）。所以当要传递打的结构体的时候，用指针是一个明智的选择。一般来说，传递指针（一个32或者64位的值）的消耗傻逼传递副本占用更少资源。在函数调用是，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认引用传递（即使没有显示的支出指针）</li>
<li>传递指针给函数不但可以节省内存（因为没有赋值变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不需要再用return返回<br>关于第三点，下面的例子中res是一个只想int变量的指针，通过这个指针，在函数内修改了这个int变量的值<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim">func main() &#123;<br>	<span class="hljs-keyword">m</span> := <span class="hljs-number">2</span><br>	<span class="hljs-keyword">res</span> := &amp;<span class="hljs-keyword">m</span><br>	multi(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">res</span>)<br>	fmt.Println(<span class="hljs-string">&quot;res is &quot;</span>, *<span class="hljs-keyword">res</span>)<br>	fmt.Println(<span class="hljs-string">&quot;m is &quot;</span>, <span class="hljs-keyword">m</span>)<br>&#125;<br><br>func multi(<span class="hljs-keyword">a</span>, <span class="hljs-keyword">b</span> <span class="hljs-keyword">int</span>, <span class="hljs-keyword">res</span> *<span class="hljs-keyword">int</span>) &#123;<br>	*<span class="hljs-keyword">res</span> = <span class="hljs-keyword">a</span> * <span class="hljs-keyword">b</span><br>&#125;<br><span class="hljs-keyword">res</span> <span class="hljs-keyword">is</span>  <span class="hljs-number">30</span><br><span class="hljs-keyword">m</span> <span class="hljs-keyword">is</span>  <span class="hljs-number">30</span> // 因为指针指向的值发生了修改，所以原先的值也发生了修改<br></code></pre></td></tr></table></figure>
实际开发中传递一个指针容易发生一些不确定的事，所以需要万分小心可以改变外部变量的函数，迫不得已使用时需要添加注意以便能清楚函数的具体作用<br>即使如此，传递指针的又是还是十分明显的，当需要在函数内改变一个占用内存比较大的变量时，传递指针可以极大减少内存，性能优势十分出色。但也是一把双刃剑</li>
</ul>
<h6 id="defer与跟踪"><a href="#defer与跟踪" class="headerlink" title="defer与跟踪"></a>defer与跟踪</h6><p>go语言中让人颇为沉到的一个设计就是延迟（defer）语句，开发者可以在函数中添加多个defer语句，当函数执行到最后时（return语句执行之前），这些defer语句会按照“逆序”执行，最后函数才退出。<br>在进行一些IO操作时，如果需要提前返回，而返回之前需要关闭相应的资源，否则容易造成资源泄露等问题，defer语句就可以优秀的解决这个问题，比如以下这个打开文件的例子：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stata">func ReadFile() bool &#123;<br>	<span class="hljs-keyword">file</span>.<span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;file&quot;</span>)<br>	<span class="hljs-comment">// 一些操作</span><br>	<span class="hljs-keyword">if</span> openFail &#123;<br>		<span class="hljs-keyword">file</span>.<span class="hljs-keyword">Close</span>()<br>		<span class="hljs-keyword">return</span> false<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> readFail &#123;<br>		<span class="hljs-keyword">file</span>.<span class="hljs-keyword">Close</span>()<br>		<span class="hljs-keyword">return</span> false<br>	&#125;<br>	<br>	<span class="hljs-comment">// 读写正常</span><br>	<span class="hljs-keyword">file</span>.<span class="hljs-keyword">Close</span>()<br>	<span class="hljs-keyword">return</span> true<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的例子中有很多重复的代码，而使用go语言的defer语句可以解决这个问题，以下是go语言的写法，不仅使得代码量减少很多，程序也变得更加优雅</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">func ReadFile() <span class="hljs-keyword">bool</span> &#123;<br>	file.<span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;file&quot;</span>)<br>	defer file.Close() <span class="hljs-comment">// 打开和关闭写在一起方便管理，也不容易遗忘</span><br>	<span class="hljs-keyword">if</span> <span class="hljs-keyword">openFail</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">readFail</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在defer后指定的函数会在函数退出前调用，如果多次使用defer，那么defer会采用后进先出顺序依次执行</p>
<p>关于defer、return、和返回值之间的执行顺序，很多人都容易搞混，下面几个例子可以简单说明。<br>首先需要特别注意函数的返回值是否被命名，以下是返回值无命名的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;return&quot;</span>, a()) <span class="hljs-comment">// return 0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		i++<br>		fmt.Println(<span class="hljs-string">&quot;defer 1 is &quot;</span>, i) <span class="hljs-comment">// defer 1 is  2</span><br>	&#125;()<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		i++<br>		fmt.Println(<span class="hljs-string">&quot;defer 2 is &quot;</span>, i) <span class="hljs-comment">// defet 2 is  1</span><br>	&#125;()<br>	<span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以下是返回值有命名的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;return&quot;</span>, a()) <span class="hljs-comment">// return 2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		i++<br>		fmt.Println(<span class="hljs-string">&quot;defer 1 is &quot;</span>, i) <span class="hljs-comment">// defer 1 is  2</span><br>	&#125;()<br><br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		i++<br>		fmt.Println(<span class="hljs-string">&quot;defer 2 is &quot;</span>, i) <span class="hljs-comment">// defer 2 is  1</span><br>	&#125;()<br>	<span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先我们知道，多个defer执行的顺序为逆序，defer、return、返回值三者的执行逻辑应该是：defer先执行；然后return执行，return负责将结果写入返回值中；最后函数携带当前返回值退出。<br>上面两段代码返回结果之所以不同，是因为a()int{}的返回值没有被命名，而且需要特别注意的是，尽管两个defer语句的匿名函数也没有返回值，但是匿名函数的特点是可以集成变量的值，所以defer2语句继承了defer1的值。按理说a()的返回值是2才对，但是返回0，这里是因为返回值没有被声明，所以函数a()的返回值还是0，然后b()(i int){}的返回值已经声明为i，也就意味着defer中是可以调用到真实返回值的，因此defer在return赋值返回值i之后，再一次修改了i的值，最终函数退出后的返回值才会是defer修改过的值。</p>
<p>defer原理<br>defer的实现逻辑简单来说就是：</p>
<ul>
<li>先给返回值赋值（若为有名返回值直接赋值，若为匿名返回值则先声明再赋值）</li>
<li>执行defer语句，defer语句后的参数获取会根据函数类型获取到不同作用域下的值</li>
<li>return 携带返回值退出函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">//匿名返回值</span><br>	r := <span class="hljs-number">6</span><br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		r *= <span class="hljs-number">7</span><br>	&#125;()<br>	<span class="hljs-keyword">return</span> r <span class="hljs-comment">// return 6</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">//有名返回值</span><br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 闭包能调用外界的 r 变量，当 r 赋值为7时，defer操作将 r 变为 49</span><br>		r *= <span class="hljs-number">7</span><br>	&#125;()<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">7</span> <span class="hljs-comment">// return 49</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">//有名返回值</span><br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r <span class="hljs-type">int</span>)</span></span> &#123; <span class="hljs-comment">// 匿名函数只能访问当前函数内变量，当 r 赋值为7时，defer操作对 r 不影响</span><br>		r *= <span class="hljs-number">7</span><br>	&#125;(r)<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">7</span> <span class="hljs-comment">// return 7</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span></span> (z <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">// 有名返回值</span><br>	r := <span class="hljs-number">6</span><br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		r *= <span class="hljs-number">7</span><br>	&#125;()<br>	<span class="hljs-keyword">return</span> r <span class="hljs-comment">// return 6</span><br>	<span class="hljs-comment">//1、先设置 z = r = 6</span><br>	<span class="hljs-comment">//2、defer操作 r 赋值为42</span><br>	<span class="hljs-comment">//3、返回z = 6</span><br>&#125;<br></code></pre></td></tr></table></figure>
f1的结果是6。f1是匿名返回值，匿名返回值是在return执行时被声明，因此defer声明时，还不能访问到匿名返回值，defer的修改不会影响到返回值。<br>f2先给返回值r赋值，r&#x3D;6，执行defer语句，defer修改r, r &#x3D; 42，然后函数return。<br>f3是有名返回值，但是因为r是作为defer的传参，在声明defer的时候，就进行参数拷贝传递，所以defer只会对defer函数的局部参数有影响，不会影响到调用函数的返回值。</li>
</ul>
<h6 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h6><p>defer 经常用于代码追踪执行，具体在进入和离开某个函数时打印相关的消息，比如下例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">defer</span> un(trace(<span class="hljs-string">&quot;a&quot;</span>)) <span class="hljs-comment">// 初始化defer函数的参数，所以输出trace()的结果</span><br>	fmt.Println(<span class="hljs-string">&quot;执行a&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">defer</span> un(trace(<span class="hljs-string">&quot;b&quot;</span>))<br>	fmt.Println(<span class="hljs-string">&quot;执行b&quot;</span>)<br>	a()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;processing &quot;</span>, s)<br>	<span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">un</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;endind &quot;</span>, s)<br>&#125;<br><br><span class="hljs-comment">/*processing  b</span><br><span class="hljs-comment">执行b</span><br><span class="hljs-comment">processing  a</span><br><span class="hljs-comment">执行a</span><br><span class="hljs-comment">endind  a</span><br><span class="hljs-comment">endind  b*/</span><br></code></pre></td></tr></table></figure>
<p>也可以使用defer语句来记录函数的参数与返回值。比如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">defer func<span class="hljs-literal">()</span> &#123;<br>	log.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;func1(%q) = %d, %v&quot;</span>, <span class="hljs-params">s</span> ,<span class="hljs-params">n</span>, <span class="hljs-params">err</span>)</span><br>&#125;<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure>
<p>使用这种方法可以获取函数调用时的输入和输出值。使用延迟语句还可以修改return语句的返回值，比如修改return的错误信息。</p>
<h5 id="错误与恢复"><a href="#错误与恢复" class="headerlink" title="错误与恢复"></a>错误与恢复</h5><p>go语言提供了panic和recover来支持异常机制，但是，panic应当作为最后的手段来使用，代码中应该没有或者少有panic语句，下面是panic()和recover()函数的声明格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panic</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recover</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br></code></pre></td></tr></table></figure>
<p>在了解panic的机制之前，先了解一下go语言是怎样处理程序错误的。</p>
<p>error</p>
<p>go语言的error是一个接口，定义极其简单，只有一个error()</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">type <span class="hljs-built_in">error</span><span class="hljs-built_in"> interface </span>&#123;<br>    <span class="hljs-built_in">Error</span>() string<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于大部分函数来说，返回错误基本都可以定义为以下模式，即将error作为多返回值的最后一个返回，并非强制要求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Foo</span><span class="hljs-params">(param <span class="hljs-type">int</span>)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">//  ....</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里使用go语言标准库中的实际代码来演示如何使用自定义的error类型。首先需要定义一个类型，用于承载错误信息，不过因为go语言中接口十分灵活，所以不需要从error接口集成或者想Java一样使用implements来明确指定类型和接口之间的关系，所以具体代码如下：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">PathError</span> struct &#123;<br>    <span class="hljs-type">Op</span> string<br>    <span class="hljs-type">Path</span> string<br>    <span class="hljs-type">Err</span> error<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在为了让编译器知道PathError可以当一个error来传递，还需要关键一步，下面的代码实现了具体的Error()方法：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func (e *PathError) <span class="hljs-built_in">Error</span>() string  &#123;<br>	return e<span class="hljs-selector-class">.Op</span> + <span class="hljs-string">&quot; &quot;</span> + e<span class="hljs-selector-class">.path</span> + <span class="hljs-string">&quot;: &quot;</span> + e<span class="hljs-selector-class">.Err</span><span class="hljs-selector-class">.Error</span>()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关于接口的更多细节，这里不做更多讲解。现在可以直接返回PathError变量，比如下面的示例代码中，当syscall.Stat()失败返回err时，将该err包装到一个PathError对象中返回：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Stat</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> (fi FileInfo, err <span class="hljs-type">error</span>) &#123;<br>	<span class="hljs-keyword">var</span> stat syscall.Stat_t<br>	err = syscall.Stat(name, &amp;stat)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, &amp;PathError&#123;<span class="hljs-string">&quot;stat&quot;</span>, name, err&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> fileInfoFormStat(&amp;stat, name), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>不过，很多时候在处理错误时，需要获得详细错误信息，这时候需要用到类型转换了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">fi, err := os.Stat(<span class="hljs-string">&quot;a.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-keyword">if</span> e, ok := err.(*os.PathError); ok &amp;&amp; e.Err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-comment">// 获取PathError类型变量中e的其他信息并处理</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h6><p>panic 是一个内建函数，可以中断原有的控制流程。比如当函数Func1调用panic时，函数的执行就会被中断，但是Func1的defer函数会正常执行，然后Func1会返回到调用它的地方，panic继续蔓延，向外围扩散，直到panic的goroutine中所调用的函数返回。错误信息将会被上报，包括在调用panic()函数时传入的参数，这个过程称为错误处理流程<br>恐慌可以直接调用panic产生，也可以运行时错误产生，例如访问越界的数据，从上面的声明格式来看（参数是一个空接口），panic()函数接收任意类型的数据，比如整形、字符串、对象等。调用方式很简单：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">panic</span><span class="hljs-params">(<span class="hljs-number">404</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">panic</span><span class="hljs-params">(<span class="hljs-string">&quot;network error&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">panic</span><span class="hljs-params">(Error(<span class="hljs-string">&quot;file not exists&quot;</span>)</span></span>)<br></code></pre></td></tr></table></figure>
<p>在使用过程中，我们可以使用panic()抛出错误，但是产生的错误并不会影响defer的执行。<br>区别使用 panic 和 error 两种方式，导致关键流程出现不可修复性错误的情况使用panic，其他时间使用error</p>
<h6 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h6><p>recover是一个内建的函数，可以让进入panic的流程中的goroutine恢复过来，如果当前的goroutine陷入panic，调用recover可以捕获到panic的输入值，并且恢复过来执行。<br>由于recover() 函数用于错误处理流程，所以一般情况下，recover()仅在defer语句中的“函数”中有效，以有效截取错误处理流程，recover()只有在defer的“函数”内直接调用才会终止错误，否则总是返回nil。如果在没有发生异常的goroutine中明确调用recover()函数，会导致该goroutine所属的进程打印异常信息后直接退出</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">func <span class="hljs-built_in">test</span>() &#123;<br>	defer <span class="hljs-built_in">func</span>() &#123; <span class="hljs-comment">// 有效，在defer语句的匿名函数中调用</span><br>		fmt<span class="hljs-selector-class">.Println</span>(recover())<br>	&#125;()<br><br>	defer <span class="hljs-built_in">func</span>() &#123; <span class="hljs-comment">// 无效，间接调用recover，返回nil</span><br>		<span class="hljs-built_in">func</span>() &#123;<br>			<span class="hljs-built_in">recover</span>()<br>		&#125;()<br>	&#125;()<br><br>	defer fmt<span class="hljs-selector-class">.Println</span>(recover()) <span class="hljs-comment">// 无效，recover相当于直接调用然后被外部函数打印，返回nil</span><br>	defer <span class="hljs-built_in">recover</span>()              <span class="hljs-comment">// 无效，相当于直接调用recover，返回nil</span><br>	<span class="hljs-built_in">panic</span>(&quot;error&quot;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以下是一个常见的例子，假设对于foo()函数的执行结果不确定，感觉可能会报错，或者自己在其中明确了按特定条件触发错误处理的语句，那么可以用如下党发在调用代码中截取recover()：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>			log.Printf(<span class="hljs-string">&quot;异常： %v&quot;</span>, r)<br>		&#125;<br>	&#125;()<br><br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;第二个错误&quot;</span>)<br>	&#125;()<br><br>	<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;第一个错误&quot;</span>)<br><br>	<span class="hljs-comment">//2022/04/19 11:50:26 异常： 第二个错误</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>无论foo()中是否触发了错误处理流程，该匿名defer函数都将在函数退出时执行。假如foo()触发了错误处理流程，执行recover()函数将使得该错误处理过程终止。如果错误处理流程触发，程序传给panic的参数不为nil，则该函数还会打印详细的错误信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	throwsPanic(genErr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genErr</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(time.Now(), <span class="hljs-string">&quot;normal sentence&quot;</span>)<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		fmt.Println(time.Now(), <span class="hljs-string">&quot;defer normal sentence&quot;</span>)<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;second error&quot;</span>)<br>	&#125;()<br>	<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;first error&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">throwsPanic</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span></span>) (b <span class="hljs-type">bool</span>) &#123;<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>			fmt.Println(time.Now(), <span class="hljs-string">&quot;error is: &quot;</span>, r)<br>			b = <span class="hljs-literal">true</span><br>		&#125;<br>	&#125;()<br>	f()<br>	<span class="hljs-keyword">return</span><br><br>	<span class="hljs-comment">//2022-04-19 11:59:47 normal sentence</span><br>	<span class="hljs-comment">//2022-04-19 11:59:47 defer normal sentence</span><br>	<span class="hljs-comment">//2022-04-19 11:59:47 error is: second error</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意到，虽然第一个panic已经执行，但是在recover()函数中看不到错误捕获的时间，这是因为recover()只会捕捉最后一个错误，而且捕获的时机是在函数最后面，不影响第一个panic之后的defer语句的执行。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/GOLANG/" class="category-chain-item">GOLANG</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/GOLANG/">#GOLANG</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>golang函数</div>
      <div>https://usergao.github.io/2022/05/31/golang函数/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>GM</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月31日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/31/golang%E5%8C%85/" title="golang包">
                        <span class="hidden-mobile">golang包</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="" target="_blank" rel="nofollow noopener"><span></span></a>

    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
