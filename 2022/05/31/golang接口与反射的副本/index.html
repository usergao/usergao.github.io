<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>golang接口与反射 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="接口接口在GO语言中有着至关重要的地位，如果说goroutine和channel是支撑GO语言的并发模型的基石，让GO语言在如此集群化和多核化的时代称为一道极为靓丽的风景，那么接口就是整个类型系统的基石，让GO语言语言在基础编程哲学的探索上各个过达到前所未有的高度。 什么是接口接口是一种类型，一种抽象的类型。 GO语言是“非传统”的面向对象编程语言，它没有类和继承的概念，但是GO语言有灵活的接口概">
<meta property="og:type" content="article">
<meta property="og:title" content="golang接口与反射">
<meta property="og:url" content="http://example.com/2022/05/31/golang%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E5%89%AF%E6%9C%AC/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="接口接口在GO语言中有着至关重要的地位，如果说goroutine和channel是支撑GO语言的并发模型的基石，让GO语言在如此集群化和多核化的时代称为一道极为靓丽的风景，那么接口就是整个类型系统的基石，让GO语言语言在基础编程哲学的探索上各个过达到前所未有的高度。 什么是接口接口是一种类型，一种抽象的类型。 GO语言是“非传统”的面向对象编程语言，它没有类和继承的概念，但是GO语言有灵活的接口概">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-05-31T06:23:00.000Z">
<meta property="article:modified_time" content="2022-06-20T22:00:33.812Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="GOLANG">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-golang接口与反射的副本" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/31/golang%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E5%89%AF%E6%9C%AC/" class="article-date">
  <time class="dt-published" datetime="2022-05-31T06:23:00.000Z" itemprop="datePublished">2022-05-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/GOLANG/">GOLANG</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      golang接口与反射
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口在GO语言中有着至关重要的地位，如果说goroutine和channel是支撑GO语言的并发模型的基石，让GO语言在如此集群化和多核化的时代称为一道极为靓丽的风景，那么接口就是整个类型系统的基石，让GO语言语言在基础编程哲学的探索上各个过达到前所未有的高度。</p>
<h6 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h6><p><font color="red">接口是一种类型，一种抽象的类型。</font></p>
<p>GO语言是“非传统”的面向对象编程语言，它没有类和继承的概念，但是GO语言有灵活的接口概念，通过它可以实现很多面向对象的特性。接口提供了一种方式来说明对象的行为：如果谁能实现这件事，那么它就可以在这里调用。<br>接口定义了一组方法（方法集），但是这些方法不包含（实现）代码–他们没有被实现（它们是抽象的），接口里也不能包含变量。<br>接口可以通过下面方式定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type 接口类型名 interface&#123;</span><br><span class="line">    方法名1( 参数列表1 ) 返回值列表1</span><br><span class="line">    方法名2( 参数列表2 ) 返回值列表2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的接口名是一个接口类型。按照约定，只包含一个方法的接口名字由方法名加[e]r后缀组成，例如Pointer，Writer，Logger等。还有一些不常用的方式（后缀不适合er时），比如Recoverable，此时以able结尾，胡哦哦这以I开头。</p>
<p>GO语言的接口都很简短，通常会包含0~3个方法。不像大多数面向对象编程语言，在GO语言中接口可以有值，一个接口类型的变量或者一个接口值，例如 var in Writer，其中in是一个多字(multiword)数据结构，它的值为nil，它本质上是一个指针，虽然完全不是一回事。指向接口值的指针是非法的，它们不仅一点用没有，还会导致代码错误，此处的方法指针是通过运行时反射能力构建的。</p>
<p>类型（比如结构体）实现接口方法集中的方法，每一个方法的实现说明了此方法是如何作用于该类型的：即实现接口，同时方法集也集成了该类型的接口，同时方法集也构成了该类型的接口。实现了Writer接口类型的变量可以赋值给 in （接收者值），此时方法表中的指针会指向被实现的接口方法。当然如果另一个类型（也实现了该接口）的变量被赋值给ai，对应指针和方法实现也会随之改变。</p>
<p>类型不需要显式声明它实现了某个接口：接口被隐式实现。多个类型可以实现同一个接口，实现某个接口的类型（除了实现接口方法外），还可以有其他的方法。一个类型可以实现多个接口，接口类型可以包含一个实例的引用，该实例的类型实现了此接口（接口是动态类型）。</p>
<p>即使接口在类型实现之后才定义，二者处于不同的包中，被单独编译，只要类型实现了接口中的方法，它就实现了此接口，所有这些特性使得接口有很大的灵活性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type Sharper interface &#123;</span><br><span class="line">	area() float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Square struct &#123;</span><br><span class="line">	side float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s Square) area() float32 &#123;</span><br><span class="line">	return s.side * s.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	square1 := new(Square)</span><br><span class="line">	square1.side = 6.2</span><br><span class="line"></span><br><span class="line">	//定义 squareArea</span><br><span class="line">	//squareArea = square1 // 实际会报错，没有解析</span><br><span class="line">	//更简洁，不需要分开定义</span><br><span class="line">	//squareArea := Sharper(square1)</span><br><span class="line">	//甚至这样</span><br><span class="line">	squareArea := square1</span><br><span class="line">	println(&quot;area is &quot;, squareArea.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序定义了一个接口体Square和一个借口Sharper，接口有一个方法area()，在main()方法中创建了一个Square的实例。在主程序外面定义了一个接收者类型是Square的area()方法，用来计算正方形的面积，结构体Square实现了接口Sharper。<br>所以可以将一个Square类型的变量赋值给一个接口类型的变量：squareArea &#x3D; square1。<font color="red">存疑，实际操作会报未解析的变量</font><br>现在接口变量包含一个指向Square变量的引用，通过它可以调用Square上的方法area()。当然也可以直接在Square的实例上调用此方法，但是在接口实例上调用此方法更具有通用性。接口变量包含了接收者实例的值和指向对应方法表的指针。<br>这就是GO语言版本的“多态”，多态是面向对象编程中一个广为人知的概念：根据当前的类型选择正确的方法，或者说同一种类型在不同的实例上表现出不同的行为。<br>如果Square没有实现area()方法，编译器就会给出清晰的报错信息。<br>同时如果Sharper有另一个方法Perimeter()，但是Square没有实现它，即使没有人在Square实例上调用这个方法，编译器也会报错。<br>扩展上面的例子，类型Rectangle也实现了Sharper接口。接着创建一个Sahrper类型的数据，迭代它的每一个元素并在上面调用area()方法，以此来展示多态行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">type Sharper interface &#123;</span><br><span class="line">	area() float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Square struct &#123;</span><br><span class="line">	side float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s Square) area() float32 &#123;</span><br><span class="line">	return s.side * s.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Rectangle struct &#123;</span><br><span class="line">	width, length float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r *Rectangle) area() float32 &#123;</span><br><span class="line">	return r.width * r.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r := &amp;Rectangle&#123;4, 5&#125; // 传入指针</span><br><span class="line">	s := Square&#123;5&#125;        // 传入值</span><br><span class="line">	//shapes := []Sharper&#123;Sharper(r), Sharper(s)&#125;</span><br><span class="line">	//简洁写法</span><br><span class="line">	shapes := []Sharper&#123;r, s&#125;</span><br><span class="line"></span><br><span class="line">	for n, _ := range shapes &#123;</span><br><span class="line">		fmt.Println(&quot;形状参数：&quot;, shapes[n])</span><br><span class="line">		fmt.Println(&quot;形状面积：&quot;, shapes[n].area())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用shapes[n].area()时，只知道shapes[n]是一个Sharper对象，最后摇身一变成为了一个Square或Rectangle对象，并展示了相应的行为。<br>下面是一个更具体的例子：有两个类型stockPosition和car，他们都有一个getValue()方法，可以定义一个具有此方法的接口valuable。接着定义一个使用valuable类型作为参数的函数showValue()，所有实现了valuable接口的类型都可以使用这个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">type stockPosition struct &#123;</span><br><span class="line">	ticker     string</span><br><span class="line">	sharePrice float32</span><br><span class="line">	count      float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s stockPosition) getValue() float32 &#123;</span><br><span class="line">	return s.sharePrice * s.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type car struct &#123;</span><br><span class="line">	brand string</span><br><span class="line">	price float32</span><br><span class="line">	model string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c car) getValue() float32 &#123;</span><br><span class="line">	return c.price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type valuable interface &#123;</span><br><span class="line">	getValue() float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func showValue(asset valuable) &#123;</span><br><span class="line">	fmt.Println(&quot;价值为：&quot;, asset.getValue())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var o valuable</span><br><span class="line">	o = stockPosition&#123;&quot;DIDI&quot;, 121.5, 2000&#125;</span><br><span class="line">	showValue(o)</span><br><span class="line">	o = car&#123;price: 100000, brand: &quot;Benz&quot;&#125;</span><br><span class="line">	showValue(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举一个标准库的例子，io包里面有一个借口Reader：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">    Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义变量var r io.Reader，那么就可以写如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var r io.Reader</span><br><span class="line">r = os.Stdin</span><br><span class="line">r = bufio.NewReader(r)</span><br><span class="line">r = new(bytes.Buffer)</span><br><span class="line">f, _ := os.Open(&quot;test.txt&quot;)</span><br><span class="line">r = bufio.NewReader(f)</span><br></pre></td></tr></table></figure>
<p>上面r右边的类型都实现了Read()方法，并且有相同的方法签名，r的静态类型是io.Reader。<br>注意，有些时候也会用一种稍微不同的方式来使用接口这个词，从某个类型的角度来看，它的接口指的是：它的所有导出方法，只不过没有显示的为这些导出方法额外指定一个接口而已。</p>
<h6 id="接口类型与约定"><a href="#接口类型与约定" class="headerlink" title="接口类型与约定"></a>接口类型与约定</h6><p>接口类型实际上是描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。<br>io.Writter类型是用的最广泛的接口之一，因为它提供了所有的类型写入bytes（字节）的抽象，包括文件类型、内存缓冲区、网络连接、HTTP客户端、压缩工具、哈希等。io包中定义了很多其他游泳的接口类型。io.Reader可以代表任意可读取bytes的类型，io.Closer可以是任意可以关闭的值，例如一个文件或者网络连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package io</span><br><span class="line"></span><br><span class="line">type Reader interface &#123;</span><br><span class="line">	Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Closer interface &#123;</span><br><span class="line">	Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再往下看，我们发现有些的接口类型通过组合已经有了接口来定义，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type ReadWriter interface &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ReadWriteCloser interface &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面用到的语法和结构内嵌相似，可以用这种方式以一个简写命名另一个接口，而不用声明它所有的方法，这种方式被称为接口内嵌。尽管略失简洁性，可以像下面这样，不用使用内嵌来声明io.Writer接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type ReadWriter interface &#123;</span><br><span class="line">    Read(p []byte) (n int, err error)</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line">或者使用混合的方式：</span><br><span class="line">type ReadWriter interface &#123;</span><br><span class="line">    Read(p []byte) (n int, err error)</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面三种定义方式效果都是一样的。方法的顺序变化也没有影响，唯一重要的就是这个集合里面的方法。</p>
<blockquote>
<p>动态类型（类型断言）</p>
</blockquote>
<p>一个接口类型的变量param1中可以包含任何类型的值，必须有一种方法来检测它的动态类型，即运行时在变量中存储的值的实际类型。在执行过程中动态类型可能会有所不同，但是它一定是可以分配给接口变量的类型。通常可以使用类型断言（GO语言内置的一种智能推断类型的功能）来测试某个时刻param1中是否包含类型T的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := param1.(T) // T代表可能是的类型</span><br></pre></td></tr></table></figure>
<p>param1必须是一个借口变量，否则编译器会报错。<br>类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能遇见所有的可能性，如果在程序运行时失败，会导致错误产生，所以更安全的方式用以下的方式断言：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if v, ok := param1.(T)</span><br><span class="line">if ok &#123;</span><br><span class="line">    Process(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对一个接口值有多个实际类型需要判断，可以使用Switch语句来判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func isInterface(i interface&#123;&#125;) &#123;</span><br><span class="line">	switch v := i.(type) &#123;</span><br><span class="line">	case string:</span><br><span class="line">		fmt.Println(v, &quot;is string&quot;)</span><br><span class="line">	case int:</span><br><span class="line">		fmt.Println(v, &quot;is int&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果转换合法，v是param1转换到类型T的值，ok会是true；否则v会是类型T的零值，ok也是false，也没有运行时错误发生。</p>
<p>下面是接口在runtime 中的实现，注意其中包含了接口本身和实际数据类型的类型信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// src/runtime/runtime2.go</span><br><span class="line">type iface struct &#123;</span><br><span class="line">    // 包含接口的静态类型信息、数据的动态类型信息和函数表</span><br><span class="line">    tab *itab</span><br><span class="line">    // 指向具体数据的内存地址，比如slice、map 等，或者在接口转换时直接存放小效据(一个指针的长度</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line">type itab struct &#123;</span><br><span class="line">    // 接口的类型信息</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    // 具体数据的类型信息</span><br><span class="line">    _type type</span><br><span class="line">    link *itab</span><br><span class="line">    hash uint32</span><br><span class="line">    bad bool</span><br><span class="line">    inhash bool</span><br><span class="line">    unused [2]byte</span><br><span class="line">    // 函数地址表，这里放置和接口方法对应的具体数据类型的方法地址实现接口调用方法的动态分派，一般在每次给接口賦值发生转换时会更新此表，或者直接获取缓存的itab</span><br><span class="line">    fun [1]uintptr // 变量大小</span><br></pre></td></tr></table></figure>
<p>此外，需要注意与接口相关的两点优化，会影响到反射等的实现。</p>
<ol>
<li>空接口（intertacef3）的 itab优化：当将菜个类型赋值给空接口时。由于空接口没有方法，所以上面空接口iface的tab字段会直接指向数据的具体类型。在GO语言的reflect包中，reflect.TypeOf 和 refleet.ValueOf的参数都是空接口，因此所有参数都会先转换为空接口奖型，这样反射就安现了对所有参数类型获取实际数据类型的统一，这在后面反射的基本实现中会分析到。</li>
<li>发生“接口转換”时 data 字段相关的优化：当被转换为接口的数据的类型长度<br>不超过一个指针的长度时（比如pointer、map、func、chan、[1]int 等类型），接口转换时会将数据直接复制到接口的 data 字段（Driectface） 中，而不再额外分配内存并复制。另外，从GO1.8+的源码来看除 Driectface 的优化以外，还对长度较小（不超过64B，未初始化数据内存的 array、空字符串等）的零值做了优化，也不会重新分配内存，而是直接指向一个包级全局数组变量 zeroVal的首地址。注意这里的优化发生在接口转换时生成的<br>临时接口上，而不是被赋值的接口左值上。<br>再者，在 Go 语言中只有值传递（包括接口类型），与具体的类型实现无关，但是某些类型具有引用的属性。典型的9种非基础类型中：</li>
</ol>
<ul>
<li>array 传递会复制整块数据内存，传递长度为 len(arr) * Sizeof(elem)。</li>
<li>string.slice、interface 传递的是其 runtime 的实现，所以长度是固定的，分别为 16B、24B、16B (AMD64)</li>
<li>map、func、 chan、pointer 传递的是指针，所以长度固定为 8B (AMD64)</li>
<li>struct 传递的是所有字段的内存副本，所以长度是所有字段的长度之和。</li>
</ul>
<h6 id="嵌套接口"><a href="#嵌套接口" class="headerlink" title="嵌套接口"></a>嵌套接口</h6><p>一个接口可以包含一个或者多个接口，这相当于将这些内嵌接口的方法列举在外层接口中。</p>
<h6 id="接口赋值"><a href="#接口赋值" class="headerlink" title="接口赋值"></a>接口赋值</h6><p>接口赋值在GO语言中分为两种情况：把对象实例赋值给接口；将一个接口赋值给另一个接口。</p>
<p>先说将某种类型的对象实例赋值给接口，这要求该对象实例实现了接口所要求的的所有方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Integer int</span><br><span class="line"></span><br><span class="line">func (a Integer) less(b Integer) bool &#123;</span><br><span class="line">	return a &lt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Integer) add(b Integer) &#123;</span><br><span class="line">	*a += b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type lessAdd interface &#123;</span><br><span class="line">	less()</span><br><span class="line">	add()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果现在有一个Integer类型的对象实例，下面该如何才能赋值给lessAdd接口呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a Integer</span><br><span class="line">var b lessAdd = &amp;a // 语句1</span><br><span class="line">var b lessAdd = a // 语句2</span><br></pre></td></tr></table></figure>
<p>答案应该是语句1，因为add()方法中需要的接收者是指针类型，GO语言可以根据方法less()自动生成一个使用指针接收者的方法，这样一样类型Integer为指针传值时同时满足了接口lessAdd，而GO语言不能自动生成一个值接收者的add()方法，所以语句2不行。</p>
<p>接下来是另一种情况————将一个接口赋值给另一个接口。在GO语言中，只要两个接口拥有相同的方法列表（方法顺序不影响），那么它们就是等同的，可以相互赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package one</span><br><span class="line">type look interface &#123;</span><br><span class="line">    read()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package two</span><br><span class="line">type listen interface &#123;</span><br><span class="line">    read()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个不同包的不同接口，但是都实现了read()方法，在GO语言中，这两个接口并无区别，因为任何实现了one.look接口的类，均实现了two.listen；任何one.look接口都可以赋值给two.listen，相反也是一样。<br>接口赋值并不需要两个接口必须等价。如果接口A的方法列表是接口B的方法列表的子集，那么接口B就可以赋值给接口A，反之却不行，因为接口A没有实现B所有的方法列表。</p>
<h6 id="接口查询"><a href="#接口查询" class="headerlink" title="接口查询"></a>接口查询</h6><p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库io源码中就有很多接口之间互相组合的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// src/io/io.go</span><br><span class="line"></span><br><span class="line">type Reader interface &#123;</span><br><span class="line">	Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Writer interface &#123;</span><br><span class="line">	Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Closer interface &#123;</span><br><span class="line">	Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型</span><br><span class="line">type ReadWriter interface &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型</span><br><span class="line">type ReadCloser interface &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型</span><br><span class="line">type WriteCloser interface &#123;</span><br><span class="line">	Writer</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p>
<p>接口也可以作为结构体的一个字段，我们来看一段Go标准库sort源码中的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// src/sort/sort.go</span><br><span class="line"></span><br><span class="line">// Interface 定义通过索引对元素排序的接口类型</span><br><span class="line">type Interface interface &#123;</span><br><span class="line">    Len() int</span><br><span class="line">    Less(i, j int) bool</span><br><span class="line">    Swap(i, j int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// reverse 结构体中嵌入了Interface接口</span><br><span class="line">type reverse struct &#123;</span><br><span class="line">    Interface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在结构体中嵌入一个接口类型，从而让该结构体类型实现了该接口类型，并且还可以改写该接口的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Less 为reverse类型添加Less方法，重写原Interface接口类型的Less方法</span><br><span class="line">func (r reverse) Less(i, j int) bool &#123;</span><br><span class="line">	return r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interface类型原本的Less方法签名为Less(i, j int) bool，此处重写为r.Interface.Less(j, i)，即通过将索引参数交换位置实现反转。<br>在这个示例中还有一个需要注意的地方是reverse结构体本身是不可导出的（结构体类型名称首字母小写），sort.go中通过定义一个可导出的Reverse函数来让使用者创建reverse结构体实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Reverse(data Interface) Interface &#123;</span><br><span class="line">	return &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的目的是保证得到的reverse结构体中的Interface属性一定不为nil，否者r.Interface.Less(j, i)就会出现空指针panic。</p>
<h6 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h6><p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。</p>
<p>通常在使用空接口时，定义方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Any interface&#123;&#125;</span><br><span class="line">// 或直接在代码中声明并命名</span><br><span class="line">var x interface&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用空接口可以实现接收任意类型参数的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 空接口作为函数参数</span><br><span class="line">func show(a interface&#123;&#125;) &#123;</span><br><span class="line">	fmt.Printf(&quot;type:%T value:%v\n&quot;, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以实现保存任意类型数据的map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var studentInfo = make(map[string]interface&#123;&#125;)</span><br><span class="line">studentInfo[&quot;name&quot;] = &quot;john&quot;</span><br><span class="line">studentInfo[&quot;age&quot;] = 18</span><br><span class="line">studentInfo[&quot;married&quot;] = false</span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure>

<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h2>反射介绍</h2>
反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。

<p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p>
<p>Go程序在运行期使用reflect包访问程序的反射信息。</p>
<p>反射是一个强大的工具，但是也存在一定的隐患，除非真的有必要，否则应当避免使用或者小心使用。</p>
<p>反射应谨慎使用的原因有三：</p>
<ul>
<li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li>
<li>大量使用反射的代码通常难以理解。</li>
<li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li>
</ul>
<h6 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h6><p>在Go语言中，使用reflect.TypeOf()函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func reflectType(x interface&#123;&#125;) &#123;</span><br><span class="line">	v := reflect.TypeOf(x)</span><br><span class="line">	fmt.Printf(&quot;type:%v\n&quot;, v)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var a float32 = 3.14</span><br><span class="line">	reflectType(a) // type:float32</span><br><span class="line">	var b int64 = 100</span><br><span class="line">	reflectType(b) // type:int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在反射中关于类型还划分为两种：类型（Type）和种类（Kind）。因为在GO语言中我们可以使用type关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类（Kind）。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">type myInt int64</span><br><span class="line"></span><br><span class="line">func reflectType(x interface&#123;&#125;) &#123;</span><br><span class="line">	t := reflect.TypeOf(x)</span><br><span class="line">	fmt.Printf(&quot;type:%v kind:%v\n&quot;, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var a *float32 // 指针</span><br><span class="line">	var b myInt    // 自定义类型</span><br><span class="line">	var c rune     // 类型别名</span><br><span class="line">	reflectType(a) // type: kind:ptr</span><br><span class="line">	reflectType(b) // type:myInt kind:int64</span><br><span class="line">	reflectType(c) // type:int32 kind:int32</span><br><span class="line"></span><br><span class="line">	type person struct &#123;</span><br><span class="line">		name string</span><br><span class="line">		age  int</span><br><span class="line">	&#125;</span><br><span class="line">	type book struct&#123; title string &#125;</span><br><span class="line">	var d = person&#123;</span><br><span class="line">		name: &quot;john&quot;,</span><br><span class="line">		age:  18,</span><br><span class="line">	&#125;</span><br><span class="line">	var e = book&#123;title: &quot;《GOLANG》&quot;&#125;</span><br><span class="line">	reflectType(d) // type:person kind:struct</span><br><span class="line">	reflectType(e) // type:book kind:struct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空。</p>
<p>在reflect包中定义的Kind类型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type Kind uint</span><br><span class="line">const (</span><br><span class="line">    Invalid Kind = iota  // 非法类型</span><br><span class="line">    Bool                 // 布尔型</span><br><span class="line">    Int                  // 有符号整型</span><br><span class="line">    Int8                 // 有符号8位整型</span><br><span class="line">    Int16                // 有符号16位整型</span><br><span class="line">    Int32                // 有符号32位整型</span><br><span class="line">    Int64                // 有符号64位整型</span><br><span class="line">    Uint                 // 无符号整型</span><br><span class="line">    Uint8                // 无符号8位整型</span><br><span class="line">    Uint16               // 无符号16位整型</span><br><span class="line">    Uint32               // 无符号32位整型</span><br><span class="line">    Uint64               // 无符号64位整型</span><br><span class="line">    Uintptr              // 指针</span><br><span class="line">    Float32              // 单精度浮点数</span><br><span class="line">    Float64              // 双精度浮点数</span><br><span class="line">    Complex64            // 64位复数类型</span><br><span class="line">    Complex128           // 128位复数类型</span><br><span class="line">    Array                // 数组</span><br><span class="line">    Chan                 // 通道</span><br><span class="line">    Func                 // 函数</span><br><span class="line">    Interface            // 接口</span><br><span class="line">    Map                  // 映射</span><br><span class="line">    Ptr                  // 指针</span><br><span class="line">    Slice                // 切片</span><br><span class="line">    String               // 字符串</span><br><span class="line">    Struct               // 结构体</span><br><span class="line">    UnsafePointer        // 底层指针</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>reflect.ValueOf()返回的是reflect.Value类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以互相转换。</p>
<p>reflect.Value类型提供的获取原始值的方法如下：</p>
<p>Interface() interface {}<br>&amp;emsp;&amp;emsp; 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型<br>Int() int64<br>&amp;emsp;&amp;emsp; 将值以 int 类型返回，所有有符号整型均可以此方式返回<br>Uint() uint64<br>&amp;emsp;&amp;emsp; 将值以 uint 类型返回，所有无符号整型均可以此方式返回<br>Float() float64<br>&amp;emsp;&amp;emsp; 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回<br>Bool() bool<br>&amp;emsp;&amp;emsp; 将值以 bool 类型返回<br>Bytes() []bytes<br>&amp;emsp;&amp;emsp; 将值以字节数组 []bytes 类型返回<br>String() string<br>&amp;emsp;&amp;emsp; 将值以字符串类型返回</p>
<blockquote>
<p>通过反射获取值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func reflectValue(x interface&#123;&#125;) &#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	k := v.Kind()</span><br><span class="line">	switch k &#123;</span><br><span class="line">	case reflect.Int64:</span><br><span class="line">		// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span><br><span class="line">		fmt.Printf(&quot;type is int64, value is %d\n&quot;, int64(v.Int()))</span><br><span class="line">	case reflect.Float32:</span><br><span class="line">		// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span><br><span class="line">		fmt.Printf(&quot;type is float32, value is %f\n&quot;, float32(v.Float()))</span><br><span class="line">	case reflect.Float64:</span><br><span class="line">		// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span><br><span class="line">		fmt.Printf(&quot;type is float64, value is %f\n&quot;, float64(v.Float()))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var a float32 = 3.14</span><br><span class="line">	var b int64 = 100</span><br><span class="line">	reflectValue(a) // type is float32, value is 3.140000</span><br><span class="line">	reflectValue(b) // type is int64, value is 100</span><br><span class="line">	// 将int类型的原始值转换为reflect.Value类型</span><br><span class="line">	c := reflect.ValueOf(10)</span><br><span class="line">	fmt.Printf(&quot;type c :%T\n&quot;, c) // type c :reflect.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过反射设置变量的值</p>
</blockquote>
<p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的Elem()方法来获取指针对应的值。使用CanSet方法判断是否可以被修改，而当一个Value持有值可以被寻址同时又不是来自非导出字段时，它才可以被修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func reflectSetValue1(x interface&#123;&#125;) &#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	if v.Kind() == reflect.Int64 &#123;</span><br><span class="line">		v.SetInt(200) //修改的是副本，reflect包会引发panic</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func reflectSetValue2(x interface&#123;&#125;) &#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	// 反射中使用 Elem()方法获取指针对应的值</span><br><span class="line">	if v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">		v.Elem().SetInt(200)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var a int64 = 100</span><br><span class="line">	v := reflect.ValueOf(a)</span><br><span class="line">	fmt.Println(&quot;canSet: &quot;, v.CanSet()) // canSet:  false</span><br><span class="line">	// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span><br><span class="line">	reflectSetValue2(&amp;a)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>isNil()和isValid()</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (v Value) IsNil() bool</span><br></pre></td></tr></table></figure>
<p>IsNil()报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (v Value) IsValid() bool</span><br></pre></td></tr></table></figure>
<p>IsValid()返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p>
<p>IsNil()常被用于判断指针是否为空；IsValid()常被用于判定返回值是否有效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// *int类型空指针</span><br><span class="line">var a *int</span><br><span class="line">fmt.Println(&quot;var a *int IsNil:&quot;, reflect.ValueOf(a).IsNil()) // true</span><br><span class="line">// nil值</span><br><span class="line">fmt.Println(&quot;nil IsValid:&quot;, reflect.ValueOf(nil).IsValid()) // false</span><br><span class="line">// 实例化一个匿名结构体</span><br><span class="line">b := struct&#123;&#125;&#123;&#125;</span><br><span class="line">// 尝试从结构体中查找&quot;abc&quot;字段</span><br><span class="line">fmt.Println(&quot;不存在的结构体成员:&quot;, reflect.ValueOf(b).FieldByName(&quot;abc&quot;).IsValid()) // false</span><br><span class="line">// 尝试从结构体中查找&quot;abc&quot;方法</span><br><span class="line">fmt.Println(&quot;不存在的结构体方法:&quot;, reflect.ValueOf(b).MethodByName(&quot;abc&quot;).IsValid()) // false</span><br><span class="line">// map</span><br><span class="line">c := map[string]int&#123;&#125;</span><br><span class="line">// 尝试从map中查找一个不存在的键</span><br><span class="line">fmt.Println(&quot;map中不存在的键：&quot;, reflect.ValueOf(c).MapIndex(reflect.ValueOf(&quot;ab&quot;)).IsValid()) // false</span><br></pre></td></tr></table></figure>
<h5 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h5><p>任意值通过reflect.TypeOf()获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的NumField()和Field()方法获得结构体成员的详细信息。</p>
<p>reflect.Type中与获取结构体成员相关的的方法如下所示。</p>
<p>Field(i int) StructField<br>&amp;emsp;&amp;emsp; 根据索引，返回索引对应的结构体字段的信息。<br>NumField() int<br>&amp;emsp;&amp;emsp; 返回结构体成员字段数量。<br>FieldByName(name string) (StructField, bool)	<br>&amp;emsp;&amp;emsp; 根据给定字符串返回字符串对应的结构体字段的信息。<br>FieldByIndex(index []int) StructField<br>&amp;emsp;&amp;emsp; 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。<br>FieldByNameFunc(match func(string) bool) (StructField,bool)	<br>&amp;emsp;&amp;emsp; 根据传入的匹配函数匹配需要的字段。<br>NumMethod() int<br>&amp;emsp;&amp;emsp; 返回该类型的方法集中方法的数目<br>Method(int) Method<br>&amp;emsp;&amp;emsp; 返回该类型方法集中的第i个方法<br>MethodByName(string)(Method, bool)<br>&amp;emsp;&amp;emsp; 根据方法名返回该类型方法集中的方法</p>
<p>我们同样能够调用已经定义的函数在结构上的方法，例如，使用索引n来调用Method(n).Call(in []Value)</p>
<h2>StructField类型</h2>

<p>StructField类型用来描述结构体中的一个字段的信息。</p>
<p>StructField的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type StructField struct &#123;</span><br><span class="line">    // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span><br><span class="line">    // 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span><br><span class="line">    Name    string</span><br><span class="line">    PkgPath string</span><br><span class="line">    Type      Type      // 字段的类型</span><br><span class="line">    Tag       StructTag // 字段的标签</span><br><span class="line">    Offset    uintptr   // 字段在结构体中的字节偏移量</span><br><span class="line">    Index     []int     // 用于Type.FieldByIndex时的索引切片</span><br><span class="line">    Anonymous bool      // 是否匿名字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">type student struct &#123;</span><br><span class="line">	Name  string `json:&quot;name&quot;`</span><br><span class="line">	score int    `json:&quot;score&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	stu1 := student&#123;</span><br><span class="line">		Name:  &quot;john&quot;,</span><br><span class="line">		score: 90,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t := reflect.TypeOf(stu1)</span><br><span class="line">	fmt.Println(t.Name(), t.Kind()) // student struct</span><br><span class="line">	// 通过for循环遍历结构体的所有字段信息</span><br><span class="line">	for i := 0; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		field := t.Field(i)</span><br><span class="line">		fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\n&quot;, field.Name, field.Index, field.Type, field.Tag.Get(&quot;json&quot;))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 通过字段名获取指定结构体字段信息</span><br><span class="line">	if scoreField, ok := t.FieldByName(&quot;Score&quot;); ok &#123;</span><br><span class="line">		fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\n&quot;, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(&quot;json&quot;))</span><br><span class="line">	&#125;</span><br><span class="line">	v := reflect.ValueOf(stu1)</span><br><span class="line">	v.FieldByName(&quot;score&quot;).SetInt(91) // reflect.Value.SetInt using value obtained using unexported field，结构体中只有被导出字段（首字母大写）才可以被设置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子用来调用结构体下所有包含的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">type student struct &#123;</span><br><span class="line">	Name  string `json:&quot;name&quot;`</span><br><span class="line">	score int    `json:&quot;score&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s student) Study() string &#123;</span><br><span class="line">	msg := &quot;好好学习，天天向上。&quot;</span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">	return msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s student) Sleep() string &#123;</span><br><span class="line">	msg := &quot;好好睡觉，快快长大。&quot;</span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">	return msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printMethod(x interface&#123;&#125;) &#123;</span><br><span class="line">	t := reflect.TypeOf(x)</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">	fmt.Println(t.NumMethod())</span><br><span class="line">	for i := 0; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">		methodType := v.Method(i).Type()</span><br><span class="line">		fmt.Printf(&quot;method name:%s\n&quot;, t.Method(i).Name)</span><br><span class="line">		fmt.Printf(&quot;method:%s\n&quot;, methodType)</span><br><span class="line">		// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span><br><span class="line">		var args = []reflect.Value&#123;&#125;</span><br><span class="line">		v.Method(i).Call(args)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var stu student</span><br><span class="line">	printMethod(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/31/golang%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E5%89%AF%E6%9C%AC/" data-id="cl4v3jgam000aacs672wr217u" data-title="golang接口与反射" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GOLANG/" rel="tag">GOLANG</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/31/golang%E5%B9%B6%E5%8F%91%E7%9A%84%E5%89%AF%E6%9C%AC/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          golang并发
        
      </div>
    </a>
  
  
    <a href="/2022/05/31/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%AF%E6%9C%AC/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">golang数据类型</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GOLANG/">GOLANG</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GOLANG/" rel="tag">GOLANG</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/GOLANG/" style="font-size: 10px;">GOLANG</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/31/golang%E5%87%BD%E6%95%B0%E7%9A%84%E5%89%AF%E6%9C%AC/">golang函数</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%8C%85%E7%9A%84%E5%89%AF%E6%9C%AC/">golang包</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%9F%BA%E7%A1%80%E7%9A%84%E5%89%AF%E6%9C%AC/">golang运算基础</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%9A%84%E5%89%AF%E6%9C%AC/">golang复合数据</a>
          </li>
        
          <li>
            <a href="/2022/05/31/golang%E5%B9%B6%E5%8F%91%E7%9A%84%E5%89%AF%E6%9C%AC/">golang并发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>