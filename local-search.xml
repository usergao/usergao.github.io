<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mysql如何生成随机数</title>
    <link href="/2022/09/16/mysql%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0/"/>
    <url>/2022/09/16/mysql%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>在使用mysql存储过程时，使用到了mysql随机函数<code>rand</code>来生成数据，下面是官方给的手册：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">rand</span>(seed) <span class="hljs-comment">// seed 为参考值，指定seed可以生成范围内的可重复的随机数值，未指定则随机生成</span><br><br><span class="hljs-comment">// 生成 &gt;= 5 且 &lt; 10 的10进制数值</span><br><span class="hljs-built_in">rand</span>() * (<span class="hljs-number">10</span>-<span class="hljs-number">5</span>+<span class="hljs-number">1</span>) + <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>这样看着很难一次看明白如何才能设置对自己想要的范围值。所以可以换一种写法，更明显的能展示出自己取的范围：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 表达式中两个数字相加，代表的就是最大范围（可相等），左边单独相加的数字即为最小范围（可相等）</span><br><span class="hljs-number">20</span> + <span class="hljs-built_in">rand</span>() * <span class="hljs-number">10</span><br><br><span class="hljs-comment">// 没有相加只有相乘的数字，即为 0 到数字 N + 1 的范围（可相等）</span><br><span class="hljs-built_in">rand</span>() * <span class="hljs-number">4</span> <br><br></code></pre></td></tr></table></figure><p>这样来记忆和使用，就会方便很多。不过这是个人的使用方法，每个人理解和使用的方法都不同，仅供参考。</p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql查询字段对索引的影响</title>
    <link href="/2022/05/31/Mysql%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E5%AF%B9%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <url>/2022/05/31/Mysql%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E5%AF%B9%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="8d71cf04cca32c18b753fd3db8e8a20c32f61bda87d39376e6e837508bb258f3">a1cd4d145fad29d28349aee38a59b663e6dc27a2b6b77670e2aa8ba44986c151b9787352ade85311bf136f236c660ab7bfe91cad104bbc9535129ed6c4e22a158f0cc8b364385bc2d792d6dff930df79873c49f44ad5f3eadb4f6287d9723fa7e9d825b66287e37a76ae16faa7653b0fcd549eb0040fc8f0a8e9aa6a03ce8a4fb5cdb5a42d8e37a48e702d170c8af4e68112b23281ef9f5a917f0682925c1c1bf806ca4e816bfdac14934fbc10fd9872af961397da0885c3348194696dc4cbbccc9309cd92456a9eadfdc53321e4db36e9b7828c1c31abe0f949e55b2335d6c5f60c7179c75157f1a423f54e68567056e191558e7c1fac8d8eab7c07d598792bb4e3cfe284aeca179b4d96f1e8d2be56a9c42e444f713162d95bdda29d2b5b9a753dc6ac7c05556a9b062fc903c0e5a295ae80c42880499fd1732a9e48acf7399b403a40e397495f5135c7c2b9ff6cabd8a2742b2155a1b2e4a6f2b27a741aa6b5829660c63d2812616bb73ff981158c46474b111ebe26ec2469ed04ec28367af24632f528fa5b3fc9675bb644e76c0b5ef91dbf17fcfd00428b962355b9460c582fba906bc02d7391d974519ed1a7b00aa7758babfa2dcdcc054ce378727f1682fba2b4c5e1ee265d68b8380e66088b2f6e1ccbe49ac9fd15d3625d992e2fd002125030387584fa5b6b8c64c8e8dfa5148d50b95c083b5603d66a44b891f7e5eec0ac8855c353e9d021e622952ed6b294979025a83148a47328a8783e4d4cd31c383994ec557b444afb95a069fcbfa70e222ebf581daa7f9bdc194d4b8e0be334c7e8552318d10133cb926a7ddc83237b931b4027a7b52d6c314a196a17c6df2e5d42ee40c6698bb09e8d76a2a147270b0bca93e7504ebfa8f6529adade1290ac0daf42ae4292ef4512a95dd1fdd3e5ea4f0f98aa15c19f8696d4994880a712506b917dc7a80ee643616f758c83a192b17016a55688115e5bb771503692fafaa328f966ba7ed96af05a789976d61fc3c768c2df3b2d5b083b429bfe197069f843df8d020e952c337d718c273dd429460a39fb6b5a5da7168e4498947ea5dbd98ae9d2d70e98427629f95763ecd640e40f3d10f3573c0370c18cdc31c8b434c7fc67034ec4d49ed23eb0ad715a3a8df3a5f83d24e44d45ba6fe49cf1ecb1263ccd127da89fb1150c68c0332b0b20fe153086ec9a07a1af6ee8f3cedcbf46ab794c7d9344410ab28b991e34c160f1c5c0ace401099d11693c4c087bf28ae0d23e9da3366b7e39e5208329bb50abe693dee65cbef73f0a94bae09e42497a8bc870bb9777593152c040c72f844f70c028dd31b8d101eefbced80ec9c0dd0e1a3569ebfe3c5d7c596f592e658dfe2dc26c99b01e1fd7c61559532f55df275d2380fb7e842d923e32156957075207225cd2d827e6eec5eebbd9191beebbcc23f232459cec24f97be7b1f524d68d2f1535c20536485ea3a9f1c950a9c9c778374ba3dfd3359fd7a8bcc8aa46977066a32a6a6e9759947f2d820f912f8ea1824f5c5c270a5644bf6d1cbd2e9b2ae0ed223b3c81b2a7e98f167d8cec2c1de0ba3898cca066d27f2700931a03cbdc786e255d7bdac77afb398a3bd6b342cbcefc6758bb9f586494eda841ab1ef1cbb4e0ccdaa7c255cb776ddb8e02c7e56810a30551b21248ec9d60b04bf64eb3ff12eb39d60cb1233e2c702cb2bf3a259631671a8a11d71867d0967077882844aa029b260ac816de0e5fc9ffe711b26dfa1be75eb21635afe3616940aa97fe2ac6901ce8e766708f11f8b56ffbd72b7b50f1be32cbd9a5356debb7ddd35c2481a5cc34998a9519e58f016d82d94fe671798ba56c78194bfd492031b1f4d820863a1db688e5714c9da51d7c23e02808fcd851509ca28cc78163043ce98f8913466c2ee0781b254abda286cd178fb2ce2a0bea49c340571b1201659fe2c2a91aca477454e09bf10098ac847f1b951e74a9b1576ff772fb1682f4069ccb6a5a51d14c7c3a76a87c3358d879c61d80872b85d4557d3d48d4912a4d2c1830a2b05b8e2ab984ad0247543d1d1c9426657d2020fb9a593624917f06f80c53cf056bfaef31102ab32232da9dbc4403d7cfd457120d84e1a84e2165a2e298fb25e45f479ce81adda6229d167341174b8894e60f912e4117851152f6c509ac323eb0d1eddd180b73f10f13d8ca6e4a598a0e6531350e51f208d553086e5120e3248faace37abf2e3ceff56756192ff3c96c3de50e111374a632067582caac62db61b6d82f0d86d0e2a3050c2aff83f4e038f6c54bf93afa85f3f6c23c1490db84b1bde2ac19f91f62b21c58ed3351e40090e2bfd0debadad1f312be2fab3c6e570f3fa70ac03747b7a0e558880897cdbb2df077f57e3bed8d4acc3e0b628ea01ae9412b32238eccda5f1e0697e2ac7f9502c2d2f120516976b537e6c6a0a63622842dd1eb51edd9ede46325dd771494e9c68a0d72400a8fb4650e77c1748d80af738626e0e3bc7abbb2f774c75ede32e56aaa4751f66541e088ce0720b9be9bef03f6e1daefaf6b24221e1485243d10549cf2258c8bd1427dede16651b177cfb0c43a4c1c93728b8bf1f7b9394e233a4526ff0a78c7392a80b6a41a0140b445f1b5cc5428d5b7a4ba072ff8f663718b02e9c80a4a6d777397623757b0bb28956d90dea0c5caf70e071c5715edca2262fc28e7bef6f7fc75b4b21bc7d955a2bfc94a0c2e24cc0077541fb77c89c5c4b6596a9d9730f3a60a1dc60e42f9ae068956afc301c135008e9ddbbe470bfe022f1417e77778b9cc0f5737d4c3d8a92f1d0b8b832a0e6862fb969950c35e21fcef4b3b3372560d5e619da55764ad6826db87de9061816292fc0924a1a7973a262630d4ca6cf700cd169010425a39f03c667515a4524dce2f13289307e09d35cdef5750993e9970a32f9721308795ee2711676aa5f206333cd061988f1d99b1cf4de95000b45e4b73b3eac3f0fe349622e8dd7eb6ee7a0935468c7b964c99bee92596ee495cd8d92c48daf655c56ba1547ebfb0506de283ac86a9d7957f94404bc9e34fd5c6108be1ced5ef5cf156fb20c62653ef2a35950ee6e5db79f27cef9ed996d5e609007da9f6db91c4b3f85c7104e3e2bf886fcc16e27576ba4cd21ce95f8f0b811840608545573b8ab4607d2661a1f5c6af5644a9d761a0d2592ddc3d74706e35da4900f8a174890590c94fe9780598f7575ede557fe671496e760024d0475ac96ac3d09d51ad925debdf854cb5dfd582f6b4d84460eb5d0f20ab45b4c28bbd95beb65c727fa8346dd52e8d8274c0077f88a5a22029954914d3a9e5df49c5a5dbaa57abfdf6213bdf9558af70c1d82dc4045e8a9eccc817d559ade41d66ef2fd503c5be5d693b408d2ab96e9df1f0fd81856d4cd8ca0c03f98363460de4512b69f9f5666e4143afd5be6044f04a4624b21d401936cdb5217c589bb2ef22a9e7d001a27d7a25d96f2ec4bc0d9af5c7830392c7066bf108bc3e39a9267b85c24cb1447301b46e1d05ed57838b2e1cee04c9437d5c87ada2d6ffa0caf70d1702c94e82184f31abed9681358e5d4071379be98f2d9924f60f232bdec16f4d1b75cbf904fe2dd64f5cb511ae557bd85ff43292252503ca300444818707d9abbd0590b7c2d6e87dd6523a3bc6843ca874b1460fa876f3329752af279a95465e831c70bd40363792fea5c34acbc3136d27b90303989c4df0758def57cc771f1c61228d78fce0b22dbc1e7cdf4bbabe1c93858eadcec4d99de994776262c62c4db771fac158713e43e61232dc3d80d99a62da057450c1b4da41f8734854aedc7f7ede9bdd45777a8f82a9f6b9c441c5dc279e3449328ff90157247d67bb70ca49810d25716dc37e07cc1b78faad68e6bc326bbc260bcb4feb8370e1887b642059ff2416b81562eb7129e70539026a9b65132a71c03fbace4cd470bf30d8e204e5d6668d408be1584636b96e76377f68e49d0566ffbc148e3b0d21bbf9fefd9c927fae5ddbcb8c2ab236d01e86c0f40799365333f94b182affeaf276de1dd57660524b37777106cb27c05ca9cd92133cb733651b9d9a476116a2ea80c9ce0acbec41c73eb22db03a9afc5f54c9103ae3606cc8ea73deff9a8d8955e5c166553524174a91c72fd98c79892c7c7d7491577daf74374a3518acbc3903373da538e9dd531689852575e8cb45906ae8094a027a96e6a5bed7c4305720edd8e49a28974fc7be1164cc9a1ddf8188aa91110850e74f39a0d48e8975702b5a9825bee018d59d942f6a4342349639dcecd6fbb2f165cb2610a50f278f609fc211c7a0df3508d365a26ba9a3f1d3f20c42a1556eb8f4d56e6a53d6ec200c249cf3038923746305f7a55960a385e0933508d00944d71e1840f138c461146123662da587adf3f94604acaa20e8396d13db3d379f38026ce36ceb3f1a6d7239db0cc8a44dc1996a134525a138082f10f4b2c29cfe929c263973db97c2ed47f384775980ea36a1cf60b05a8069777531293b62b416be34903d3889bcfc13a75acc9b9b13fa65bf981a6748cdd2570d380b67ae00d5a9188a3bb59aeb82ab8384ba02276053c98fc42405c31e074077384a4162a976149bfd8012c6cd113e1075d0cdea1b5145f05f41d03322ac4f132f38344dd1325e1ba3e867cc23c100aff80852b7ca1bf43ff850a98d46d21fe55eb324644075782720bef3610b4da90b91eefe4b360ee914d7f9a8bcb3033e5026da774488ee761b72ac3dc6119823023dc0bcf32f12bb1f947723470be778bf08821fd1e55a3b83073ebb2bba720cfc5cef7e0cd87fbe43af5ae2387f3e2b5b5187dbc22f5d03df849d88e1c744f1a9dfa59d3660bdd9c0a60c8fb01ac580b05a7d3c69ec528bb6105c86c124cff28baa85d4fe5e701394af7adbfaff741c73be9d8b2f62c43abf10cbee6dc923b218b54faaea66684907ca82915be02d51b74e363fba40bbfec073b88a054c27cda4b3aec94ecce2a17fcab3cf7a6c1c90b6e68278819f0f2ae1558a63cba0ef44ab6347648e17c9509715bd6f1d911775d45c42a5aeaf791aa9adb271c774af16fd530060d0c58ab7e816652e2d5d36e4c5e4d2ab5ce7119e41b61f39e9047743200da413b02d7e24eb562709761dd231e0946a5654f5c04a550c2a9b1d4d91d4fc223a342a4e73039a05e0ca8b27a8877494ca3a9e02941f655c061083be2b99bcb89fcf0f0feb48421f30cd646750b684793287de643c58ca93b373cfb24d9e2770c38c908f838a07aefe43b3e7132cd01a15d6b79855ea576763b50532316ae706b26775824bd4277733ceef7f312a0c3b6706fe00cc90246d923dd41466f02df54bd9c6ab28fb5b71a2aa8a6ef58d4cf6ec514bd7f014a54d9414d6f49ab722929b6c18382a4c6631494baa47f24016e04816eafe36ad124892487d044848a0f329c004b064ea6b5153080309f8057a29ddba131a3dea3ed3d7cc9aaf4e9eced745cdf95a04b483723f1e02857411f49c2750204a1d5df00674ac77a1c676a4d0850207f4357bcb9e7f09798f18828af672fede5aeae1812efb8a9783724693e2e4fdf9e2e78319be4be3e9a6487c114f466efbbf0d1e1c8f6363de5709596516e4b10f032cb5d14b924785ccd52f78300e4315ab37f67ba018ea9e58bcb0771ccbfb22eef06ec855ca2406f3222e3589e733eec12af653256cf3d60e14abd18f02eaef59cb45bf298f0339763a7fcd95917c281e053915cfca1bc748e4832b0dc7352b0e728525b2e82142930c122a8dffcee4713adf056b0ead4446e0b849920f53abc78565015a07b9b6c08b91af523df4af328bbc36d78a6b531dbcec10621b15dcebf0c531c9efcd0b2267e1cbed35fb5c4399b50e46406c851f6add41a52484825330494060aa5a50108b60911fafabe299949c69635dab7d31bdea88777954022cbf60fdc13df77d1eed2008a4fcce689ef9de88cc2c0dc7aa848a530ebb5ba2907afa464a0a2d26544dc4144a98cdbf93a2ddbe8c5ff82e461df4a06036fef18b033f0f232b4c5da687367cf373a838f539b912b7fbf70d21c1628f7a1ce8f1366a7ff97a0c0cfeb9893dc67be79f28a60395d432047b393818679f9dd0134e28ad2bdfa89178c2332a30230169c0b92f6969d72cb58c95cff4b77f91708f8e7cd96e42370707132f23a82fd84a80addefc0ac0f85b1eb6a1ae3655110c1b1f0a1f3e5c681c56f0d39b0ed3c1bfd1623415e4adcd1882aed5440d8f8d574f409d77e641e09a91a33c0d14da7ab445988cc845a4e16e3c98f1a2b20ba88e092e1d62971e19936bb4561a593a4af348a57d33077d46cf8393b2c48fffc3259f27581fa56b3a54829263eac6f964c71f469568254df7eb67abfcde4ffaef734d4b739f302b2903aaf1353309ab37a1ba8ea3810808e5f296b00763e34ee5ea1e245903fe16cef51ec5ce6a94386d42e4599fc05e0fec6c33ef3266c34a2ba7d59d8b252765779b7d63a53da6d51e21163d50f47d293625613e9f027500609eb93c4a73ac25a13996a1742340ea871870b2c69195c84a8c04e8e9f12a8a29525391b09f5ed2485ecb910f74d34c0a9748309039dbdc5bbec407cf1a77aaf961ffc3e94d70cb3a1d9cb6aeb59d3acb7497d4d35b233ff464c0a12fdfdd904d08e92737bb4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好，这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>加密文章tag</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang包</title>
    <link href="/2022/05/31/golang%E5%8C%85/"/>
    <url>/2022/05/31/golang%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>在编写代码的过程中，不同模块（包）之间为了实现某一个类似的功能可能会采用相同的名字去命名一个函数，如果一个软件开发过程中需要同时引用这两个模块（包），就会在调用函数时产生歧义。为了解决这个问题，GO语言引入了命名空间的概念，让每个包都定义一个命名空间，用于内部标识符的访问。</p><p>与大多数编译语言类似，在GO语言中，当改动了一个源文件时，就必须重新编译该文件，以及它对应的包和所有依赖该包的其它包。即使是从头构建，GO语言编译器的编译速度以明显快于绝大部分编译语言。这得益于其包设计的三个特性。</p><ul><li>显示声明：所有导入的包都必须在每个文件开头显示声明，这样编译器就没有必要读取和分析整个原文件来判断包的依赖关系。</li><li>无环依赖：禁止宝的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以独立编译，而且很可能是被并发编译。</li><li>无须遍历：编译后包的目标文件不仅记录包本身的导出信息，同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖文件，毕竟很多都是重复的间接依赖。</li></ul><h6 id="包的结构"><a href="#包的结构" class="headerlink" title="包的结构"></a>包的结构</h6><p>GO编译工具对源码目录有很严格的要求，每个工作空间（workspace）必须由bin、pkg、src三个目录组成。bin目录主要存放可执行文件，pkg存放编译好的库文件，主要是*.a文件；src目录主要存放GO语言的源文件。</p><blockquote><p>工作空间</p></blockquote><p>GO语言采用了工作空间这种方式来管理本地代码，这与大部分编程语言不一样，因此解释一下GOROOT和GOPATH之间的关系。首先，GOROOT是一个全局且唯一的变量，用于指定存放GO语言本身的目录路径（安装路径）；GOPATH是一个工作空间的变量，可以有很多个（用<code>;</code>分割），用于指定工作空间的目录路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GOPATH=<span class="hljs-variable">$HOME</span><span class="hljs-regexp">/workspace/g</span>olib:<span class="hljs-variable">$HOME</span><span class="hljs-regexp">/project/g</span>o<br></code></pre></td></tr></table></figure><p>通常<code>go get</code>会使用第一个工作空间保存下载的的第三方库（包），在开发时不管是哪一个工作空间下载的包都可以在任意工作空间使用。但需要使用时要注意不要将GOPATH和GOROOT设置为同一个路径</p><blockquote><p>包的源文件</p></blockquote><p>包的代码必须全部放在包中，并且源文件头都必须一致使用<code>package &lt;name&gt;</code>的语句进行声明。GO语言包可以由多个文件组成，所以文件名不需要和包名一致，包名建议使用小写字符。包名类似命名空间（namespace），与包所在目录、编译文件名无关，目录名尽量不要使用保留名称（main、all、std），对于可执行文件必须包含<code>package main</code>以及入口函数main</p><p>GO语言使用名称首字母大小写来判断一个对象（全局变量。全局常量、类型、结构字段、函数、方法）的访问权限，对于包也是如此。包中成员名称首字母大小写决定了该成员的访问权限。首字母大写，可悲包外访问，即public（公开的）；首字母小写，即仅包内成员可以访问，即internal（内部的）。</p><blockquote><p>包的声明</p></blockquote><p>上面提到的每一个包内源文件都需要在开头声明所在包，这就是包的声明。包的声明对于包内而言主要用于源文件编译时能够为编译器指明哪些是包的源代码；对于包外而言，对于导入包的时候可以使用“包名.函数名”的方式使用包内函数。</p><p>关于包的声明有一个例外，那就是包编译后是一个可执行程序时，会使用<code>package main</code>的方式声明main包，这时候main包本身的导入路径是无关紧要的，这个名字实际是给<code>go build</code>构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。</p><h6 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h6><p>使用包成员之前需要导入包。导入包的关键字是<code>import</code>，因为GO语言不能形成环形依赖，如果遇到导入包循环依赖的情况，GO语言的构建工具会返回错误。一般而言对于直接从分发渠道下载回来的包都不会轻易产生依赖环：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;相对目录/包主文件名&quot;</span><br></code></pre></td></tr></table></figure><p>相对目录是指从pkg&#x2F;开始的子目录，以标准库为例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">import <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-regexp">//</span> 对应<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/go/</span>pkg<span class="hljs-regexp">/linux_amd64/</span>fmt.a<br>import <span class="hljs-string">&quot;os/exec&quot;</span> <span class="hljs-regexp">//</span>对应<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/go/</span>pkg<span class="hljs-regexp">/linux_amd64/</span>os<span class="hljs-regexp">/exec/</span>a<br></code></pre></td></tr></table></figure><p>除了一行一个包的导入方式，还可以使用一条语句导入多个包的写法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os/exec&quot;</span><br>)<br></code></pre></td></tr></table></figure><blockquote><p>导入声明</p></blockquote><p>当有名称相同的包导入时会有冲突，为了避免这种去哪个看，因此GO语言在导入包时可以对包名做重定向，以解决包名冲突的情况，如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">import (<br>    <span class="hljs-string">&quot;crypto/rand&quot;</span> <span class="hljs-regexp">//</span> 默认模式<br>    mrand <span class="hljs-string">&quot;math/rand&quot;</span> <span class="hljs-regexp">//</span> 包重命名 R.Function<br>    _ <span class="hljs-string">&quot;crypto/rand&quot;</span> 匿名导入：仅让该包执行init函数<br>    . <span class="hljs-string">&quot;crypto/rand&quot;</span> 简便模式：Function<br>)<br><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>GO语言不允许包导入了但不适用，如果导入的包未使用，在编译时会被视为错误（不包含 import _）</li><li>包的重命名不仅可以用于解决包名冲突，还可以解决包名过长、避免与变量或常量名称冲突的情况。</li></ul><p>除了使用以上的包导入方式，还有子包导入以及自定义路径导入包方式，其中对于当前目录下的子包，除使用默认完整路径导入外，还可以使用相对路径的方式：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;test/test2&quot;</span> <span class="hljs-comment">// 一般使用这种方式导入</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./test2&quot;</span> <span class="hljs-comment">// 也可以使用相对目录，但这种方式导入的包仅对GO语言有效</span><br></code></pre></td></tr></table></figure><p>如果一个文件中导入的包比较多，为了管理源代码中导入的包，还可以使用空行来进行分割分组。</p><blockquote><p>导入路径</p></blockquote><p>当前GO语言的规范并没有强制包的导入路径字符串的格式，导入路径由构建工具来解释。但如果打算分享或发布自己编写的包，那么最好使用全球唯一的导入路径。<br>这主要是为了必变导入路径冲突，因此有一个约定俗成的路径格式是：所有非标准库包的导入路径以所在组织的互联网域名为前缀，这样一来就有了一个独一无二的路径，另外一方面也有利于包的检索。</p><blockquote><p>导入本地包</p></blockquote><p>安装GO语言时推荐将项目放置在GOPATH中的src目录，而项目开发时的自建包只需直接写明src目录下的相对路径既可：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;src下项目目录/包所在目录&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>自定义路径</p></blockquote><p>上面说了可以使用域名作为导入路径的前缀，对于编译器来说，只有较为流行的代码托管网站才可以使用这种路径。对于一些个人站点（比如企业自己搭建的私有GitLab仓库），为了可以更方便使用这种方式导入就需要告诉编译器这是一个包代码链接。</p><p>GO语言有三种方式实现这个功能，一种是直接在包连接上加上VCS格式，目前支持的格式有：</p><p>Bazaar     .bzr<br>Git        .Git<br>Mercurial  .hg<br>Subversion .svn</p><p>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;example.org/user/foo.git&quot;</span><br></code></pre></td></tr></table></figure><p>第二种方式是针对没有版本控制符的链接，<code>go get</code>甚至不知道该如何下载代码的情况，例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">example.org<span class="hljs-regexp">/repo/</span>foo<br></code></pre></td></tr></table></figure><p>这个时候就需要在网页中加入一句标签：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;go-import&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;import-prefix vcs repo-root&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>这样就可以使用链接导入：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;example/pkg/foo&quot;</span><br></code></pre></td></tr></table></figure><p>第三种是重定向网页链接，例如下面，<code>go get</code>访问链接时会被重定向到 <code>example.org/r/p/exproj</code> ：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;go-import&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;example.org git https://example.org/r/p/exproj&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>如果没有服务器还可以使用GO语言搭建一个本地服务器：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package main<br><br>import (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br>func handler(w http.ResponseWriter, r *http.Request) &#123;<br>fmt.<span class="hljs-constructor">Fprint(<span class="hljs-params">w</span>, `&lt;<span class="hljs-params">meta</span> <span class="hljs-params">name</span>=<span class="hljs-string">&quot;go-import&quot;</span> <span class="hljs-params">content</span>=<span class="hljs-string">&quot;example.com/zuolan/test git https://github.com/zuolan/test&quot;</span>&gt;`)</span><br>&#125;<br><br>func main<span class="hljs-literal">()</span>  &#123;<br>http.<span class="hljs-constructor">HandleFunc(<span class="hljs-string">&quot;/zuolan/test&quot;</span>, <span class="hljs-params">handler</span>)</span><br>http.<span class="hljs-constructor">ListenAndServe(<span class="hljs-string">&quot;:80&quot;</span>, <span class="hljs-params">nil</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>保存为<code>server.go</code>。然后编译执行，就可以实现把example.com&#x2F;zuolan&#x2F;test重定向到github.com&#x2F;zuolan&#x2F;test。</p><blockquote><p>匿名导入</p></blockquote><p>因为包引入了但没有使用会导致编译错误，但有时候只需要利用导入包产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数。这时候需要一直<code>unused import</code>编译错误，可以使用下划线来重命名导入的包。包被导入但不能被访问，这个称之为包的匿名导入，它通常用来实现一个编译时机制，然后通过main主程序入口选择性地导入附加的包。</p>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang函数</title>
    <link href="/2022/05/31/golang%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/31/golang%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>我们已经认识了main()函数，是程序的入口，因为go 是编译型语言，所以函数编写的顺序无关紧要，但是为了可读性，一般把main（）函数卸载文件前面，但是其他函数需要按照一定的逻辑顺序编写。</p><h4 id="认识函数"><a href="#认识函数" class="headerlink" title="认识函数"></a>认识函数</h4><p>在golang中，函数和其他语言的方法不一样，有明显的区分，函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接受者的，而方法是有接受者的，方法要么属于一个结构体，要么数以一个新定义的类型。（？？？？？）</p><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>一个完整的函数声明结构格式如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func func<span class="hljs-constructor">Name(<span class="hljs-params">input1</span> <span class="hljs-params">type1</span>, <span class="hljs-params">input2</span> <span class="hljs-params">type2</span>)</span>(output1 type1, outtype2 type2)  &#123;<br>return value1, value2 <span class="hljs-comment">// 返回多值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从以上可以看出 func 是用来声明函数的，而 funcName 是指函数名称（匿名函数和lambda函数除外）。函数名称如果是小写的，它的作用于只属于所声明的包，不能被其它包调用。如果函数名以大写字母开头，则该函数是公开的，可以被其他包调用。这是go语言中大小写的用处，这个规则适用于所有变量、函数等实体对象的声明，类似PHP的作用于关键字（private、public、protect等）。</p><p>此外，go语言不支持嵌套（nested）、重载（overload）和默认参数（default parameter）。</p><p>声明一个在外部定义的函数只需给出函数名和函数签名，不需要写出完整的函数体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(str, num <span class="hljs-type">int</span>)</span></span> <span class="hljs-comment">// 外部实现</span><br></code></pre></td></tr></table></figure><p>函数同样可以通过声明的方式作为一个函数类型被使用，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> addNum <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>此处不需要函数体{}，因为函数在go语言属于一等值（first-class value），函数也可以复制给变量，例如 add :&#x3D; addNum，由于变量执行了 addNum 函数的前面，所以不能再给他赋一个具有不同签名的函数值。</p><p>不过函数值（functions value）之间是可以相互比较的，比如他们引用的都是相同的函数，或者返回值都是nil，则可以认为它们是相同的函数。函数不能再其他函数里面声明，也就是不能嵌套（匿名函数除外）</p><p><font color="red">匿名函数就是没有名字的函数</font></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">res1 := <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n1 <span class="hljs-type">int</span>, n2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> n1 + n2<br>&#125;(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>)  <span class="hljs-comment">//括号里的10,30 就相当于参数列表，分别对应n1和n2</span><br><br>fmt.Println(<span class="hljs-string">&quot;res1=&quot;</span>,res1)<br></code></pre></td></tr></table></figure><p>函数可以有一个或者多个参数，每个参数后面带有类型，通过 ，分割。如果参数列表中若干个相邻参数的类型相同，比如下面例子中的a和b，则可以在参数列表中省略前面变量的类型声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span>(ret <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>如果返回值列表中多个返回值的类型相同，也可以用同样的方式合并，如果函数只有一个返回值，也可以这样写：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">Add(<span class="hljs-params">a</span>, <span class="hljs-params">b</span> <span class="hljs-params">int</span>)</span> <span class="hljs-built_in">int</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>函数可以有多个返回值，也是go语言的一大特性，多返回值也意味着有时候返回值并不是全部需要</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">float32</span><br>a, _, b = <span class="hljs-type">ThreeValues</span>()<br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;int is %d, float is %f \n&quot;</span>, a, b)<br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-type">ThreeValues</span>() (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">float32</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>.<span class="hljs-number">99</span><br>&#125;<br><br>/*<span class="hljs-type">int</span> <span class="hljs-keyword">is</span> <span class="hljs-number">5</span>, <span class="hljs-type">float</span> <span class="hljs-keyword">is</span> <span class="hljs-number">7</span>.<span class="hljs-number">990000</span> */<br></code></pre></td></tr></table></figure><p>代码中第一个与第三个值赋予了a和b，第二个返回值赋予了空白标识符“_”，然后自动丢弃掉<br>函数是第一类对象，可以作为参数传递，只要被调用函数的返回值个数、返回类型和返回值的顺序与调用函数所需要的参数一致，就可以把这个被调用的函数当做其他函数的参数。<br>同时建议将复杂签名定义为函数类型，以便于阅读</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pipe</span><span class="hljs-params">(ff <span class="hljs-keyword">func</span>()</span></span> <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> ff()<br>&#125;<br><br><span class="hljs-keyword">type</span> FormatFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>, x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">format</span><span class="hljs-params">(ff FormatFunc, s <span class="hljs-type">string</span>, x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> ff(s, x, y)<br>&#125;<br><br>s1 := pipe(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">300</span> &#125;)<br>s2 := format(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>, x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(s, x, y)<br>&#125;, <span class="hljs-string">&quot;%d, %d&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br><br>fmt.Println(s1, s2)<br><span class="hljs-comment">/*300 10, 10*/</span><br></code></pre></td></tr></table></figure><h6 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h6><p>函数在go语言中也是一种变量，前面多次使用type，它的类型就是所有拥有相同参数与返回值的一种函数类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isOdd</span><span class="hljs-params">(v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEven</span><span class="hljs-params">(v <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">type</span> boolFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">filter</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>, f boolFunc)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> result []<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> slice &#123;<br><span class="hljs-keyword">if</span> f(value) &#123;<br>result = <span class="hljs-built_in">append</span>(result, value)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br><br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;slice is &quot;</span>, slice)<br>odd := filter(slice, isOdd) <span class="hljs-comment">// 函数当作值传递</span><br>fmt.Println(<span class="hljs-string">&quot;odd : &quot;</span>, odd)<br>even := filter(slice, isEven) <span class="hljs-comment">// 函数当作值传递</span><br>fmt.Println(<span class="hljs-string">&quot;even : &quot;</span>, even)<br><br><span class="hljs-comment">/*//slice is  [3 1 4 5 9 2]</span><br><span class="hljs-comment">//odd :  [3 1 5 9]</span><br><span class="hljs-comment">//even :  [3 1 5 9]*/</span><br></code></pre></td></tr></table></figure><p>上面的 boolFunc 是一个函数类型，isOdd和isEven函数的参数和返回值相同，所以在调用filter函数时使filter函数实现不同的功能</p><h6 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h6><p>go语言支持可变参数（有着不定数量的参数）写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(arg ...<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>如果函数的最后一个参数是 <font color="red">…type</font> 的形式，那这个函数就是一个变参参数，且这个长度可以为0，无论变参有多少个，它们的类型始终一样<br>实例：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vim">func minOrMax(<span class="hljs-keyword">m</span> <span class="hljs-built_in">string</span>, <span class="hljs-keyword">a</span> ...<span class="hljs-keyword">int</span>) <span class="hljs-keyword">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-keyword">a</span>) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">m</span> == <span class="hljs-string">&quot;max&quot;</span> &#123;<br><span class="hljs-built_in">max</span> := <span class="hljs-keyword">a</span>[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-built_in">range</span> <span class="hljs-keyword">a</span> &#123;<br><span class="hljs-keyword">if</span> v &gt; <span class="hljs-built_in">max</span> &#123;<br><span class="hljs-built_in">max</span> = v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">m</span> == <span class="hljs-string">&quot;min&quot;</span> &#123;<br><span class="hljs-built_in">min</span> := <span class="hljs-keyword">a</span>[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-built_in">range</span> <span class="hljs-keyword">a</span> &#123;<br><span class="hljs-keyword">if</span> v &lt; <span class="hljs-built_in">min</span> &#123;<br><span class="hljs-built_in">min</span> = v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">e</span> := -<span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">e</span><br>&#125;<br>&#125;<br>// 手动填写参数<br><span class="hljs-built_in">min</span> := minOrMax(<span class="hljs-string">&quot;min&quot;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">3</span>)<br>fmt.Printf(<span class="hljs-string">&quot;min is %d&quot;</span>, <span class="hljs-built_in">min</span>)<br>age := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">22</span>, <span class="hljs-number">1</span>, <span class="hljs-number">55</span>, <span class="hljs-number">20</span>&#125;<br><span class="hljs-built_in">max</span> := minOrMax(<span class="hljs-string">&quot;max&quot;</span>, age...)<br>fmt.Printf(<span class="hljs-string">&quot;max is %d&quot;</span>, <span class="hljs-built_in">max</span>)<br>/*<span class="hljs-built_in">min</span> <span class="hljs-keyword">is</span> <span class="hljs-number">2</span><span class="hljs-built_in">max</span> <span class="hljs-keyword">is</span> <span class="hljs-number">55</span>*/<br></code></pre></td></tr></table></figure><p>上面的minOrMax就是使用了两种不同类型的参数，不同类型的参数需要单独声明，而可变参数必须是同一种类型<br>下面的例子就是接收一个变参并打印每个元素，比较f2和f3的区别，一个接收变参的函数可以将这个变参作为其他函数的参数进行传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">(arr ...<span class="hljs-type">int</span>)</span></span> &#123;<br>f2(arr...)<br>fmt.Println(<span class="hljs-string">&quot;&quot;</span>)<br>f3(arr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(arr ...<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, v)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, v)<br>&#125;<br>&#125;<br>age := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">32</span>, <span class="hljs-number">15</span>, <span class="hljs-number">55</span>&#125;<br>f1(age...)<br><span class="hljs-comment">/*17 20 32 15 55</span><br><span class="hljs-comment">17 20 32 15 55*/</span><br></code></pre></td></tr></table></figure><p>变长参数可以作为对应类型的slice进行二次传递，从内部实现机制来说，类型…type本质上是一个数组切片，也就是{}type，这也是arr可以用for循环来获得每个值的原因<br>函数f2和f3的最大区别在于调用方式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f2</span>(<span class="hljs-number">17</span> <span class="hljs-number">20</span> <span class="hljs-number">32</span> <span class="hljs-number">15</span> <span class="hljs-number">55</span>) // 可变参数，随便写多少个<br><span class="hljs-attribute">f3</span>([]int&#123;<span class="hljs-number">17</span> <span class="hljs-number">20</span> <span class="hljs-number">32</span> <span class="hljs-number">15</span> <span class="hljs-number">55</span>&#125;) // 需要加上[]int来创建一个数组切片实例<br></code></pre></td></tr></table></figure><p>如果可变参数是多种类型，可以指定类型为interface{}，也就是接口，下面是go语言标准库中fmt.PrintF()的函数原型：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">PrintF(<span class="hljs-params">format</span> <span class="hljs-params">string</span>, <span class="hljs-params">args</span> <span class="hljs-operator">...</span><span class="hljs-params">interface</span>&#123;&#125;)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>常用的PrintF函数就是一个变参函数，而且不限制参数类型，用interface{}传递任意类型数据是go语言的习惯用法。interface{}是类型安全的</p><h6 id="匿名函数与闭包"><a href="#匿名函数与闭包" class="headerlink" title="匿名函数与闭包"></a>匿名函数与闭包</h6><p>匿名函数是指不需要定义函数名的一种函数定义方式，以下就是一个简单的匿名函数例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> x + y&#125;<br></code></pre></td></tr></table></figure><p>因为在函数声明时没有函数名称，所以一般赋值于某个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">argPlus := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> x + y&#125;<br>argPlus(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 返回11</span><br></code></pre></td></tr></table></figure><p>同时也可以匿名参数后面紧跟函数运行参数直接调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> x + y&#125;(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>函数列表的第一对扩号必须紧挨着关键字func，因为匿名函数没有名称，花括号涵盖着函数体，最后的一对扩号表示对该函数的调用</p><h6 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h6><p>匿名函数同样称为闭包，简单来说闭包允许调用定义在其他环境下的变量，可以让某个函数捕捉到一些外部状态，例如函数被创建时的状态。用专业的语言来说就是：一个闭包继承了函数声明时的作用域，这种状态（作用域内的变量）会共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。闭包常用作包装函数，预先定义一个或者多个参数以用以包装，另一个常见的应用就是使用闭包来完成更加简介的错误检查，闭包的体现形式，通常就是用函数返回另一个函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">j := <span class="hljs-number">5</span><br>a := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">10</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;j is %d i is %d&quot;</span>, j, i)<br>&#125;<br>&#125;()<br><br>a()<br>j = <span class="hljs-number">12</span> <span class="hljs-comment">// 将一个新的值赋予j</span><br>a()<br><span class="hljs-comment">//j is 5 i is 10j is 12 i is 10</span><br></code></pre></td></tr></table></figure><p>上面这个例子中，j变量的值在闭包之外初始化，当闭包第一获取j 的值时，返回的是初始化的5，第二次获取时，闭包反悔了赋值之后的j值10。在变量a指向的闭包函数中，只有内部的函数才能访问变量i，其它途径无法访问到，因此保证了i的安全性。下面是另一种不一样的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f = adder()<br>fmt.Println(f(<span class="hljs-number">1</span>))<br>fmt.Println(f(<span class="hljs-number">2</span>))<br>fmt.Println(f(<span class="hljs-number">3</span>))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> <span class="hljs-comment">// 闭包中的变量可以在闭包函数体内声明，也可以在外部函数声明</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(d <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;x = &quot;</span>, x, <span class="hljs-string">&quot;d = &quot;</span>, d)<br>x += d<br><span class="hljs-keyword">return</span> x<br>&#125;<br>&#125;<br><span class="hljs-comment">/*x =  0 d =  1</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">x =  1 d =  2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">x =  3 d =  3</span><br><span class="hljs-comment">6*/</span><br></code></pre></td></tr></table></figure><p>三次调用函数adder中变量d的值分别是1，2，3，通过func(d int) 传递，而在多次调用中，变量x的值是保留的，一开始默认为0，即0+1&#x3D;1，1+2&#x3D;3，3+3&#x3D;6，闭包函数保存并积累其中的变量的值，不管外部函数是否退出，它都能够继续操作外部函数中的局部变量，这些局部变量同样可以是参数。以下是更直观的操作：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">func <span class="hljs-selector-tag">main</span>() &#123;<br>addNumber := <span class="hljs-built_in">getSequence</span>()<br><br>fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">addNumber</span>())<br>fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">addNumber</span>())<br>fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">addNumber</span>())<br><br>addNumber1 := <span class="hljs-built_in">getSequence</span>()<br>fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">addNumber1</span>())<br>fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">addNumber1</span>())<br>&#125;<br>func getSequence() func() int &#123;<br><span class="hljs-selector-tag">i</span> := <span class="hljs-number">0</span><br>return <span class="hljs-built_in">func</span>() int &#123;<br><span class="hljs-selector-tag">i</span>++<br>return <span class="hljs-selector-tag">i</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子清晰的展示了go语言闭包在环境继承方面的特性</p><h5 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h5><p>递归就是在运行的过程中调用自己，语法格式如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">func <span class="hljs-built_in">recursion</span>() &#123;<br>    <span class="hljs-built_in">recursion</span>()<br>&#125;<br><br><span class="hljs-built_in">recursion</span>()<br></code></pre></td></tr></table></figure><p>go语言支持递归，但是在使用递归时，需要设置退出条件，否则将陷入无限的循环当中。递归函数对于解决数学上的问题是非常有用的，一下实例通过go语言的递归函数实现阶乘运算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">60</span><br>fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>, Factorial(<span class="hljs-type">uint64</span>(i))) <span class="hljs-comment">// 因为阶乘的数字可能会过大，所以使用unint64位</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Factorial</span><span class="hljs-params">(n <span class="hljs-type">uint64</span>)</span></span> (result <span class="hljs-type">uint64</span>) &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> &#123;<br>result = n * Factorial(n<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下是使用递归实现斐波那契数列：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, fibonacci(i))<br>&#125;<br>&#125;<br><span class="hljs-comment">//0 1 1 2 3 5 8 13 21 34</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> n<br>&#125;<br><span class="hljs-keyword">return</span> fibonacci(n<span class="hljs-number">-2</span>) + fibonacci(n<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>递归可以优雅的解决很多问题，经常使用的快速排序就是通过递归实现的。有时候递归函数在使用时可能遇到栈溢出的问题，当大量的递归调用导致程序栈内存分配耗尽就会产生栈溢出，好在通过懒惰求值的方法可以解决这个问题，在go语言中可以通过管道（channel）和goroutine来解决</p><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><p>内置函数是不需要进行导入操作就可以直接使用的函数，有些可以根据不同的类型进行操作（len、cap和append），有些用于系统级的操作（panic），不管哪种，他们都需要直接获得编译器的支持。<br>常见内置函数有如下几种：</p><ul><li>close：用于管道通信</li><li>len：用于返回某个类型的长度或数量（字符串、数组、切片、map和管道）</li><li>cap：容量的意思，用于返回某个类型的最大容量（只能用于切片和map）</li><li>new、make：均用于内存分配，不过new用于值类型和用户定义的类型，如自定义结构，make用于内置引用类型（切片、map和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T)分配类型T的零值并返回器地址，也就是指向类型T的指针，它也可以用于基本类型：v:&#x3D;new(int)。make(T)返回T初始化之后的值，因此它比new做更多的工作。new()是一个函数，因此要记得加上扩号。</li><li>copy、append：用于复制和链接切片</li><li>panic、recover：两者均用于错误处理机制</li><li>print、println：底层打印函数（部署环境中建议使用fmt包）</li><li>complex、real imag：用于创建和操作复数</li></ul><h4 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h4><h6 id="函数传递机制"><a href="#函数传递机制" class="headerlink" title="函数传递机制"></a>函数传递机制</h6><p>go语言的参数传递可以分为“按值传递”和“按引用传递”，默认为按值传递，传递的是参数的副本，函数接收参数副本后，使用变量的过程中可能对副本的值进行更改，但不会影响原来的变量，换句话来说，调用函数时修改参数的值，不会影响原来的实参的值，因为数值变化只会作用在副本上。<br>所以要当函数直接修改参数的值，而不是对参数的副本进行修改，就需要将参数的地址（变量名前面添加&amp;符号）传递给函数，这就是“按引用传递”，此时传递给函数的是一个指针。<br>如果把指针传递给函数，指针的值（一个地址）就会被复制，但指针的值指向的地址上的那个值不会被复制（被复制的是指针，但两个指针实际上指向的是同一个实际的值）。这样一来，修改这个指针的值，实际上意味着这个值指向的地址上的值被修改了（指针也是变量类型，有自己的地址和值，通常指针的只指向一个变量的地址，所以按引用传递其实也是按值传递）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>x := <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;x= &quot;</span>, x, <span class="hljs-string">&quot;&amp;x= &quot;</span>, &amp;x)<br>y := add(x)<br>fmt.Println(<span class="hljs-string">&quot;x= &quot;</span>, x, <span class="hljs-string">&quot;y= &quot;</span>, y)<br>z := add1(&amp;x)<br>fmt.Println(<span class="hljs-string">&quot;x= &quot;</span>, x, <span class="hljs-string">&quot;z=&quot;</span>, z)<br>fmt.Println(<span class="hljs-string">&quot;&amp;x= &quot;</span>, &amp;x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>a++<br><span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add1</span><span class="hljs-params">(a *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>*a++<br><span class="hljs-keyword">return</span> *a<br>&#125;<br><span class="hljs-comment">/*x=  1 &amp;x=  0xc0000b2008</span><br><span class="hljs-comment">x=  1 y=  2</span><br><span class="hljs-comment">x=  2 z= 2</span><br><span class="hljs-comment">&amp;x=  0xc0000b2008*/</span><br></code></pre></td></tr></table></figure><p>add()函数中x变量的值没有发生变化，而add1()函数中的x值变了。当调用add()的时候，add()接受的参数其实是x的副本，而不是x本身；而add1()函数接受的参数是一个指针，指向的是x的本身，所以x实际的值发生了变化<br>使用指针最明显的三个好处如下</p><ul><li>传指针可以是多个函数能操作同一个对象</li><li>传指针比较轻量级（8B），因为只是传内存地址，可以用指针传递体积大的结构体，如果传递值，在每次创建副本上面就会花费相对较多的系统开销（内存和时间）。所以当要传递打的结构体的时候，用指针是一个明智的选择。一般来说，传递指针（一个32或者64位的值）的消耗傻逼传递副本占用更少资源。在函数调用是，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认引用传递（即使没有显示的支出指针）</li><li>传递指针给函数不但可以节省内存（因为没有赋值变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不需要再用return返回<br>关于第三点，下面的例子中res是一个只想int变量的指针，通过这个指针，在函数内修改了这个int变量的值<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim">func main() &#123;<br><span class="hljs-keyword">m</span> := <span class="hljs-number">2</span><br><span class="hljs-keyword">res</span> := &amp;<span class="hljs-keyword">m</span><br>multi(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">res</span>)<br>fmt.Println(<span class="hljs-string">&quot;res is &quot;</span>, *<span class="hljs-keyword">res</span>)<br>fmt.Println(<span class="hljs-string">&quot;m is &quot;</span>, <span class="hljs-keyword">m</span>)<br>&#125;<br><br>func multi(<span class="hljs-keyword">a</span>, <span class="hljs-keyword">b</span> <span class="hljs-keyword">int</span>, <span class="hljs-keyword">res</span> *<span class="hljs-keyword">int</span>) &#123;<br>*<span class="hljs-keyword">res</span> = <span class="hljs-keyword">a</span> * <span class="hljs-keyword">b</span><br>&#125;<br><span class="hljs-keyword">res</span> <span class="hljs-keyword">is</span>  <span class="hljs-number">30</span><br><span class="hljs-keyword">m</span> <span class="hljs-keyword">is</span>  <span class="hljs-number">30</span> // 因为指针指向的值发生了修改，所以原先的值也发生了修改<br></code></pre></td></tr></table></figure>实际开发中传递一个指针容易发生一些不确定的事，所以需要万分小心可以改变外部变量的函数，迫不得已使用时需要添加注意以便能清楚函数的具体作用<br>即使如此，传递指针的又是还是十分明显的，当需要在函数内改变一个占用内存比较大的变量时，传递指针可以极大减少内存，性能优势十分出色。但也是一把双刃剑</li></ul><h6 id="defer与跟踪"><a href="#defer与跟踪" class="headerlink" title="defer与跟踪"></a>defer与跟踪</h6><p>go语言中让人颇为沉到的一个设计就是延迟（defer）语句，开发者可以在函数中添加多个defer语句，当函数执行到最后时（return语句执行之前），这些defer语句会按照“逆序”执行，最后函数才退出。<br>在进行一些IO操作时，如果需要提前返回，而返回之前需要关闭相应的资源，否则容易造成资源泄露等问题，defer语句就可以优秀的解决这个问题，比如以下这个打开文件的例子：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stata">func ReadFile() bool &#123;<br><span class="hljs-keyword">file</span>.<span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;file&quot;</span>)<br><span class="hljs-comment">// 一些操作</span><br><span class="hljs-keyword">if</span> openFail &#123;<br><span class="hljs-keyword">file</span>.<span class="hljs-keyword">Close</span>()<br><span class="hljs-keyword">return</span> false<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> readFail &#123;<br><span class="hljs-keyword">file</span>.<span class="hljs-keyword">Close</span>()<br><span class="hljs-keyword">return</span> false<br>&#125;<br><br><span class="hljs-comment">// 读写正常</span><br><span class="hljs-keyword">file</span>.<span class="hljs-keyword">Close</span>()<br><span class="hljs-keyword">return</span> true<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子中有很多重复的代码，而使用go语言的defer语句可以解决这个问题，以下是go语言的写法，不仅使得代码量减少很多，程序也变得更加优雅</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">func ReadFile() <span class="hljs-keyword">bool</span> &#123;<br>file.<span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;file&quot;</span>)<br>defer file.Close() <span class="hljs-comment">// 打开和关闭写在一起方便管理，也不容易遗忘</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">openFail</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">readFail</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在defer后指定的函数会在函数退出前调用，如果多次使用defer，那么defer会采用后进先出顺序依次执行</p><p>关于defer、return、和返回值之间的执行顺序，很多人都容易搞混，下面几个例子可以简单说明。<br>首先需要特别注意函数的返回值是否被命名，以下是返回值无命名的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;return&quot;</span>, a()) <span class="hljs-comment">// return 0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i++<br>fmt.Println(<span class="hljs-string">&quot;defer 1 is &quot;</span>, i) <span class="hljs-comment">// defer 1 is  2</span><br>&#125;()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i++<br>fmt.Println(<span class="hljs-string">&quot;defer 2 is &quot;</span>, i) <span class="hljs-comment">// defet 2 is  1</span><br>&#125;()<br><span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是返回值有命名的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;return&quot;</span>, a()) <span class="hljs-comment">// return 2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i++<br>fmt.Println(<span class="hljs-string">&quot;defer 1 is &quot;</span>, i) <span class="hljs-comment">// defer 1 is  2</span><br>&#125;()<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i++<br>fmt.Println(<span class="hljs-string">&quot;defer 2 is &quot;</span>, i) <span class="hljs-comment">// defer 2 is  1</span><br>&#125;()<br><span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们知道，多个defer执行的顺序为逆序，defer、return、返回值三者的执行逻辑应该是：defer先执行；然后return执行，return负责将结果写入返回值中；最后函数携带当前返回值退出。<br>上面两段代码返回结果之所以不同，是因为a()int{}的返回值没有被命名，而且需要特别注意的是，尽管两个defer语句的匿名函数也没有返回值，但是匿名函数的特点是可以集成变量的值，所以defer2语句继承了defer1的值。按理说a()的返回值是2才对，但是返回0，这里是因为返回值没有被声明，所以函数a()的返回值还是0，然后b()(i int){}的返回值已经声明为i，也就意味着defer中是可以调用到真实返回值的，因此defer在return赋值返回值i之后，再一次修改了i的值，最终函数退出后的返回值才会是defer修改过的值。</p><p>defer原理<br>defer的实现逻辑简单来说就是：</p><ul><li>先给返回值赋值（若为有名返回值直接赋值，若为匿名返回值则先声明再赋值）</li><li>执行defer语句，defer语句后的参数获取会根据函数类型获取到不同作用域下的值</li><li>return 携带返回值退出函数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">//匿名返回值</span><br>r := <span class="hljs-number">6</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r *= <span class="hljs-number">7</span><br>&#125;()<br><span class="hljs-keyword">return</span> r <span class="hljs-comment">// return 6</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">//有名返回值</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 闭包能调用外界的 r 变量，当 r 赋值为7时，defer操作将 r 变为 49</span><br>r *= <span class="hljs-number">7</span><br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">7</span> <span class="hljs-comment">// return 49</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">//有名返回值</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r <span class="hljs-type">int</span>)</span></span> &#123; <span class="hljs-comment">// 匿名函数只能访问当前函数内变量，当 r 赋值为7时，defer操作对 r 不影响</span><br>r *= <span class="hljs-number">7</span><br>&#125;(r)<br><span class="hljs-keyword">return</span> <span class="hljs-number">7</span> <span class="hljs-comment">// return 7</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span></span> (z <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">// 有名返回值</span><br>r := <span class="hljs-number">6</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r *= <span class="hljs-number">7</span><br>&#125;()<br><span class="hljs-keyword">return</span> r <span class="hljs-comment">// return 6</span><br><span class="hljs-comment">//1、先设置 z = r = 6</span><br><span class="hljs-comment">//2、defer操作 r 赋值为42</span><br><span class="hljs-comment">//3、返回z = 6</span><br>&#125;<br></code></pre></td></tr></table></figure>f1的结果是6。f1是匿名返回值，匿名返回值是在return执行时被声明，因此defer声明时，还不能访问到匿名返回值，defer的修改不会影响到返回值。<br>f2先给返回值r赋值，r&#x3D;6，执行defer语句，defer修改r, r &#x3D; 42，然后函数return。<br>f3是有名返回值，但是因为r是作为defer的传参，在声明defer的时候，就进行参数拷贝传递，所以defer只会对defer函数的局部参数有影响，不会影响到调用函数的返回值。</li></ul><h6 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h6><p>defer 经常用于代码追踪执行，具体在进入和离开某个函数时打印相关的消息，比如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> un(trace(<span class="hljs-string">&quot;a&quot;</span>)) <span class="hljs-comment">// 初始化defer函数的参数，所以输出trace()的结果</span><br>fmt.Println(<span class="hljs-string">&quot;执行a&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> un(trace(<span class="hljs-string">&quot;b&quot;</span>))<br>fmt.Println(<span class="hljs-string">&quot;执行b&quot;</span>)<br>a()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;processing &quot;</span>, s)<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">un</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;endind &quot;</span>, s)<br>&#125;<br><br><span class="hljs-comment">/*processing  b</span><br><span class="hljs-comment">执行b</span><br><span class="hljs-comment">processing  a</span><br><span class="hljs-comment">执行a</span><br><span class="hljs-comment">endind  a</span><br><span class="hljs-comment">endind  b*/</span><br></code></pre></td></tr></table></figure><p>也可以使用defer语句来记录函数的参数与返回值。比如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">defer func<span class="hljs-literal">()</span> &#123;<br>log.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;func1(%q) = %d, %v&quot;</span>, <span class="hljs-params">s</span> ,<span class="hljs-params">n</span>, <span class="hljs-params">err</span>)</span><br>&#125;<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><p>使用这种方法可以获取函数调用时的输入和输出值。使用延迟语句还可以修改return语句的返回值，比如修改return的错误信息。</p><h5 id="错误与恢复"><a href="#错误与恢复" class="headerlink" title="错误与恢复"></a>错误与恢复</h5><p>go语言提供了panic和recover来支持异常机制，但是，panic应当作为最后的手段来使用，代码中应该没有或者少有panic语句，下面是panic()和recover()函数的声明格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panic</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recover</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br></code></pre></td></tr></table></figure><p>在了解panic的机制之前，先了解一下go语言是怎样处理程序错误的。</p><p>error</p><p>go语言的error是一个接口，定义极其简单，只有一个error()</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">type <span class="hljs-built_in">error</span><span class="hljs-built_in"> interface </span>&#123;<br>    <span class="hljs-built_in">Error</span>() string<br>&#125;<br></code></pre></td></tr></table></figure><p>对于大部分函数来说，返回错误基本都可以定义为以下模式，即将error作为多返回值的最后一个返回，并非强制要求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Foo</span><span class="hljs-params">(param <span class="hljs-type">int</span>)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">//  ....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用go语言标准库中的实际代码来演示如何使用自定义的error类型。首先需要定义一个类型，用于承载错误信息，不过因为go语言中接口十分灵活，所以不需要从error接口集成或者想Java一样使用implements来明确指定类型和接口之间的关系，所以具体代码如下：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">PathError</span> struct &#123;<br>    <span class="hljs-type">Op</span> string<br>    <span class="hljs-type">Path</span> string<br>    <span class="hljs-type">Err</span> error<br>&#125;<br></code></pre></td></tr></table></figure><p>现在为了让编译器知道PathError可以当一个error来传递，还需要关键一步，下面的代码实现了具体的Error()方法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func (e *PathError) <span class="hljs-built_in">Error</span>() string  &#123;<br>return e<span class="hljs-selector-class">.Op</span> + <span class="hljs-string">&quot; &quot;</span> + e<span class="hljs-selector-class">.path</span> + <span class="hljs-string">&quot;: &quot;</span> + e<span class="hljs-selector-class">.Err</span><span class="hljs-selector-class">.Error</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>关于接口的更多细节，这里不做更多讲解。现在可以直接返回PathError变量，比如下面的示例代码中，当syscall.Stat()失败返回err时，将该err包装到一个PathError对象中返回：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Stat</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> (fi FileInfo, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> stat syscall.Stat_t<br>err = syscall.Stat(name, &amp;stat)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, &amp;PathError&#123;<span class="hljs-string">&quot;stat&quot;</span>, name, err&#125;<br>&#125;<br><span class="hljs-keyword">return</span> fileInfoFormStat(&amp;stat, name), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过，很多时候在处理错误时，需要获得详细错误信息，这时候需要用到类型转换了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">fi, err := os.Stat(<span class="hljs-string">&quot;a.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> e, ok := err.(*os.PathError); ok &amp;&amp; e.Err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 获取PathError类型变量中e的其他信息并处理</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h6><p>panic 是一个内建函数，可以中断原有的控制流程。比如当函数Func1调用panic时，函数的执行就会被中断，但是Func1的defer函数会正常执行，然后Func1会返回到调用它的地方，panic继续蔓延，向外围扩散，直到panic的goroutine中所调用的函数返回。错误信息将会被上报，包括在调用panic()函数时传入的参数，这个过程称为错误处理流程<br>恐慌可以直接调用panic产生，也可以运行时错误产生，例如访问越界的数据，从上面的声明格式来看（参数是一个空接口），panic()函数接收任意类型的数据，比如整形、字符串、对象等。调用方式很简单：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">panic</span><span class="hljs-params">(<span class="hljs-number">404</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">panic</span><span class="hljs-params">(<span class="hljs-string">&quot;network error&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">panic</span><span class="hljs-params">(Error(<span class="hljs-string">&quot;file not exists&quot;</span>)</span></span>)<br></code></pre></td></tr></table></figure><p>在使用过程中，我们可以使用panic()抛出错误，但是产生的错误并不会影响defer的执行。<br>区别使用 panic 和 error 两种方式，导致关键流程出现不可修复性错误的情况使用panic，其他时间使用error</p><h6 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h6><p>recover是一个内建的函数，可以让进入panic的流程中的goroutine恢复过来，如果当前的goroutine陷入panic，调用recover可以捕获到panic的输入值，并且恢复过来执行。<br>由于recover() 函数用于错误处理流程，所以一般情况下，recover()仅在defer语句中的“函数”中有效，以有效截取错误处理流程，recover()只有在defer的“函数”内直接调用才会终止错误，否则总是返回nil。如果在没有发生异常的goroutine中明确调用recover()函数，会导致该goroutine所属的进程打印异常信息后直接退出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">func <span class="hljs-built_in">test</span>() &#123;<br>defer <span class="hljs-built_in">func</span>() &#123; <span class="hljs-comment">// 有效，在defer语句的匿名函数中调用</span><br>fmt<span class="hljs-selector-class">.Println</span>(recover())<br>&#125;()<br><br>defer <span class="hljs-built_in">func</span>() &#123; <span class="hljs-comment">// 无效，间接调用recover，返回nil</span><br><span class="hljs-built_in">func</span>() &#123;<br><span class="hljs-built_in">recover</span>()<br>&#125;()<br>&#125;()<br><br>defer fmt<span class="hljs-selector-class">.Println</span>(recover()) <span class="hljs-comment">// 无效，recover相当于直接调用然后被外部函数打印，返回nil</span><br>defer <span class="hljs-built_in">recover</span>()              <span class="hljs-comment">// 无效，相当于直接调用recover，返回nil</span><br><span class="hljs-built_in">panic</span>(&quot;error&quot;)<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是一个常见的例子，假设对于foo()函数的执行结果不确定，感觉可能会报错，或者自己在其中明确了按特定条件触发错误处理的语句，那么可以用如下党发在调用代码中截取recover()：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;异常： %v&quot;</span>, r)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;第二个错误&quot;</span>)<br>&#125;()<br><br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;第一个错误&quot;</span>)<br><br><span class="hljs-comment">//2022/04/19 11:50:26 异常： 第二个错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>无论foo()中是否触发了错误处理流程，该匿名defer函数都将在函数退出时执行。假如foo()触发了错误处理流程，执行recover()函数将使得该错误处理过程终止。如果错误处理流程触发，程序传给panic的参数不为nil，则该函数还会打印详细的错误信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>throwsPanic(genErr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genErr</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(time.Now(), <span class="hljs-string">&quot;normal sentence&quot;</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(time.Now(), <span class="hljs-string">&quot;defer normal sentence&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;second error&quot;</span>)<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;first error&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">throwsPanic</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span></span>) (b <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(time.Now(), <span class="hljs-string">&quot;error is: &quot;</span>, r)<br>b = <span class="hljs-literal">true</span><br>&#125;<br>&#125;()<br>f()<br><span class="hljs-keyword">return</span><br><br><span class="hljs-comment">//2022-04-19 11:59:47 normal sentence</span><br><span class="hljs-comment">//2022-04-19 11:59:47 defer normal sentence</span><br><span class="hljs-comment">//2022-04-19 11:59:47 error is: second error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意到，虽然第一个panic已经执行，但是在recover()函数中看不到错误捕获的时间，这是因为recover()只会捕捉最后一个错误，而且捕获的时机是在函数最后面，不影响第一个panic之后的defer语句的执行。</p>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang复合数据</title>
    <link href="/2022/05/31/golang%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/05/31/golang%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>复合数据类型是可以包含大量条目的数据结构，比如数组、切片和映射等。go语言的复合数据类型吸收了很多Python语言的优点，相对没有C语言那么灵活、复杂。<br>因为引入了切片这种概念使得GO语言的代码中并不容易见到数组，切片是构建在数组智商并且提供更强大的能力和便捷的一种数据类型，学好切片有助于在编成过程中灵活处理数据。GO语言的3中复合数据类型可以让开发者管理集合数据，这3中数据类型也是GO语言核心的一部分，在标准库中被广泛应用。掌握这些数据结构后，用GO语言编写程序会变得快速、有趣。且十分灵活。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>了解数据结构，一般会从数组开始，因为数组是切片和映射的基础数据结构。了解数组的工作原理，有助于理解切片和映射提供的优雅、强大的功能。<br>数组是具有想同类型的一组已经编号且长度固定的数据项序列，这个序列可以是有序的也可以是无序的，组成数组的各个变量称为数组的元素。这种类型可以是任意的原始类型，例如int、string和自定义类型。数组长度必须是一个非负整数的常量（或常量表达式），数组长度也是数组类型的一部分，所以[20]int和[100]不是同一种类型。</p><p>数组的声明需要指定元素的数据类型，以及存储元素的数量（数组长度），如以下代码所示：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">// 声明一个包含5个元素的整形数组<br>var<span class="hljs-built_in"> array </span>[5]int<br></code></pre></td></tr></table></figure><p>数组一旦声明，它所存储的数据类型和数组长度便都不能修改了。如果需要存储更多的元素，必须先创建一个更长的数组，然后把原来的数组里的值复制到新数组里面。<br>GO语言在声明变量时，都是使用相应类型的零值来初始化变量的，数组也一样。数组初始化时，其每个元素都被初始化对应类型的零值。比如上面的整形数组里，每个元素都被初始化为0（整形的零值）<br>使用数组字面量可以快速创建并初始化数组，数组字面量可以声明数组里元素的数量，并指定每个元素的值，如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">// 声明一个包含5个元素的整形数组<br>// 用具体值初始化每个元素<br>var<span class="hljs-built_in"> array </span>[5]int(1,2,3,4,5)<br></code></pre></td></tr></table></figure><p>如果使用…来代替数组的长度，GO语言会根据初始化数组元素的数量来确定该数组的长度，如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">// 声明一个整形数组<br>// 用具体值初始化每个元素<br>// 容量由初始化值的数量决定<br>var<span class="hljs-built_in"> array </span>[...]int(1,2,3,4,5)<br></code></pre></td></tr></table></figure><p>如果知道数组的长度，还可以给特定下标指定具体值，如：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">test </span>:= [5]int&#123;1: 20, 3: 50&#125;<br>// [0 20 0 50 0]<br></code></pre></td></tr></table></figure><h6 id="数组访问与修改"><a href="#数组访问与修改" class="headerlink" title="数组访问与修改"></a>数组访问与修改</h6><p>GO语言通过数组下标（索引位置）来读取和修改数组元素，下标（索引）从0开始，逐渐类推。元素的数目（长度或数组大小）必须是固定的并且在声明数组时就指定的（编译时需要知道数组长度以便分配内存），数组最大长度为2GB。</p><p><strong>访问元素</strong><br>对于数组arr[]，第一个元素是arr[0]，第三个元素是arr[2]，总体来说下标i代表的元素是arr[i]，最后一个元素是arr[len(arr)-1]</p><p><strong>修改元素</strong><br>数组是效率很高的数据结构，因为数组在内存分配中是连续的，要访问数组里某个单独的值，使用[]运算符既可。<br>数组的值也可以是指针，下面声明一个所有元素都是指针的数组，然后使用*运算符就可以访问元素指针所指向的值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 声明包含5个元素的指向整数的数组</span><br><span class="hljs-comment">// 用整形指针初始化索引为0和1的数组元素</span><br><span class="hljs-keyword">array</span> := [<span class="hljs-number">5</span>]*<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>(<span class="hljs-keyword">int</span>), <span class="hljs-number">1</span>: <span class="hljs-keyword">new</span>(<span class="hljs-keyword">int</span>)&#125;<br><span class="hljs-comment">// 为索引0和1的元素赋值</span><br>*<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span><br>*<span class="hljs-keyword">array</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span><br><br>fmt.<span class="hljs-title function_ invoke__">Println</span>(*<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>])<br><span class="hljs-comment">//输出为：10</span><br></code></pre></td></tr></table></figure><p>在GO语言中，数组是一个类型值，这意味着数组也可以像函数一样用在赋值操作中，变量名代表整个数组，因此同样类型的数组可以赋值类另一个数组，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个包含4个元素的字符串数组</span><br><span class="hljs-keyword">var</span> array1 [<span class="hljs-number">5</span>]<span class="hljs-type">string</span><br><span class="hljs-comment">// 声明第二个包含5个元素的字符串数组并初始化</span><br>array2 := [<span class="hljs-number">5</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>&#125;<br>array1 = array2<br></code></pre></td></tr></table></figure><p>数组作为一个变量类型，它包括数组长度和每个元素的类型两个部分。只有两部分都相同的数组才是类型相同的数组，才能相互赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个包含4个元素的字符串数组</span><br><span class="hljs-keyword">var</span> array1 [<span class="hljs-number">4</span>]<span class="hljs-type">string</span><br><span class="hljs-comment">// 声明第二个包含5个元素的字符串数组并初始化</span><br>array2 := [<span class="hljs-number">5</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>&#125;<br>array1 = array2<br><span class="hljs-comment">// 数组长度不同，无法赋值</span><br></code></pre></td></tr></table></figure><p>与之前的参数传递一样，如果复制数组指针，只会复制指针的值（一个地址），而不会赋值指针所指向的值，如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 声明一个包含3个元素的指向字符串的指针数组</span><br><span class="hljs-selector-tag">var</span> array1 <span class="hljs-selector-attr">[3]</span>*string<br><span class="hljs-comment">// 声明第二个包含3个元素的指向字符串的指针数组</span><br><span class="hljs-comment">// 使用字符串指针初始化这个数组</span><br>array2 := <span class="hljs-selector-attr">[3]</span>*string&#123;<span class="hljs-built_in">new</span>(string), <span class="hljs-built_in">new</span>(string), <span class="hljs-built_in">new</span>(string)&#125;<br>*array2<span class="hljs-selector-attr">[0]</span> = <span class="hljs-string">&quot;a&quot;</span><br>*array2<span class="hljs-selector-attr">[1]</span> = <span class="hljs-string">&quot;b&quot;</span><br>*array2<span class="hljs-selector-attr">[2]</span> = <span class="hljs-string">&quot;c&quot;</span><br><br>array1 = array2<br>*array2<span class="hljs-selector-attr">[1]</span> = <span class="hljs-string">&quot;d&quot;</span><br>fmt<span class="hljs-selector-class">.Println</span>(*array1<span class="hljs-selector-attr">[1]</span>)<br><span class="hljs-comment">// 输出d</span><br></code></pre></td></tr></table></figure><p>在上面操作中，复制操作后，两个数组指向同一组字符串，修改其中一个数组的某个值后，另一个数组的值也相应改变。</p><h6 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h6><p>数组本身只有一个维度，但是可以组合多个数组创建多维数组。多维数组用于管理具有依赖关系的数据（比如坐标系），下面是声明二维数组的示例代码：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs smali">//声明一个二维整形数组，两个维度分别存储4个元素和2个元素<br>var<span class="hljs-built_in"> array </span>[4][2]int<br>//使用数组字面量来声明并初始化一个二维整形数组<span class="hljs-built_in"></span><br><span class="hljs-built_in">array </span>:= [4][2]int&#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;, &#123;7, 8&#125;&#125;<br>//声明并初始化外层数组中索引为1和3的元素<span class="hljs-built_in"></span><br><span class="hljs-built_in">array </span>:= [4][2]int&#123;1: &#123;3, 4&#125;, 3: &#123;7, 8&#125;&#125;<br>//声明并初始化外层数组和内层数组的单个元素<span class="hljs-built_in"></span><br><span class="hljs-built_in">array </span>:= [4][2]int&#123;1: &#123;0: 1&#125;, 3: &#123;1: 2&#125;&#125;<br></code></pre></td></tr></table></figure><p>访问单个元素，需要组合[]运算符。如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">array</span>[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>和一维数组一样，只要类型一致，就可以将多维数组互相赋值，又因为每个数组都是一个单独的值，所以还可以独立赋值某个维度，如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 将array1的索引为1的维度赋值到一个同类型的新数组里</span><br><span class="hljs-selector-tag">var</span> array3 <span class="hljs-selector-attr">[2]</span>int = array1<span class="hljs-selector-attr">[1]</span><br><span class="hljs-comment">// 将外层数组的索引为1、内层数组的索引为0的整形值复制到新的整形变量里</span><br><span class="hljs-selector-tag">var</span> value int = array1<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-attr">[0]</span><br></code></pre></td></tr></table></figure><h6 id="将数组传递给函数"><a href="#将数组传递给函数" class="headerlink" title="将数组传递给函数"></a>将数组传递给函数</h6><p>前面讲过，在GO语言中数组是一个值类型(value type)，所有的值类型变量在赋值和作为参数传递时都将产生一次复制操作。如果直接将数组作为函数的参数，则在函数调用时数组会复制一份作为函数参数。因此，在函数体内无法修改传入的数组的内容，因为函数内操作的只是所传入的数组的一个副本。<br>如此依赖，从内存和性能角度看，在函数间传递数组是一个开销很大的操作。特别是当这个变量是一个数组是，意味着整个数组，不管有多长，都会完整复制，并传递给函数（别忘了在函数之间传递变量时，默认以值的方式传递）<br>为了体验这个操作到底有多消耗性能，我们来创建一个包含100万个int类型元素的数组。在64位架构上，这将需要800万字节，即8MB的内存。如果声明了这种大小的数组，并传递给函数，可以想象是一个非常“重”的操作。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 声明一个需要8MB的数组</span><br><span class="hljs-selector-tag">var</span> array <span class="hljs-selector-attr">[1e6]</span>int<br><span class="hljs-comment">// 将数组传递给函数foo</span><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">(array)</span></span><br><span class="hljs-comment">// 函数foo接收一个包含100万个整形的数组</span><br>func <span class="hljs-built_in">foo</span>(array <span class="hljs-selector-attr">[1e6]</span>int) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每次当函数foo调用时，必须在栈上分配8MB的内存。之后，整个数组的值（大小8MB）被复制到刚分配的内存里。<br>虽然GO语言会处理这个复制操作，不过其实有一种更好且更高效分方法来处理这个操作，那就是只传入数组的指针，这样只需赋值8字节的数据而不是8MB的内存数据到栈上，如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 声明一个需要8MB的数组</span><br><span class="hljs-selector-tag">var</span> array <span class="hljs-selector-attr">[1e6]</span>int<br><span class="hljs-comment">// 将数组的地址传递给函数foo</span><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">(&amp;array)</span></span><br><span class="hljs-comment">// 函数foo接收一个包含100万个整形的数组的指针</span><br>func <span class="hljs-built_in">foo</span>(array *<span class="hljs-selector-attr">[1e6]</span>int) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这次函数foo()接受一个指向100万个整形值的数组的指针，现在将数组的地址传入函数，只需要在栈上分配8字节的内存给指针既可。<br>这个才做会更有效的利用内存，性能也更好，但是要注意，因为现在传递的事指针，所以如果改变指针指向的值，会改变共享内存的值，为了解决这个问题，就需要使用切片来更好的处理这类共享问题了。</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>切片是GO语言中比较特殊的数据结构，，这种数据结构更便于使用和管理数据集合。<br>切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是通过内置函数append()来实现的，这个函数</p><p>可以快速且搞笑地增长切片，也可以通过对切片再次切割，缩小一个切片的大小。因为切片的底层内存也是在连续内存快中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处。</p><h6 id="创建数组切片"><a href="#创建数组切片" class="headerlink" title="创建数组切片"></a>创建数组切片</h6><p>GO语言中创建和初始化切片的方法有几种，而能否确定切片的容量是创建切片的关键，它决定了以何种方式创建切片。</p><ul><li>make和切片字面量<br>一种创建切片的方式使用内置的make()函数。当使用make()时，需要传入一个参数，指定切片的长度，如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个长度和容量都是5的字符串切片</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>如果只指定长度，那么切片的容量和长度也相等。也可以分别指定长度和容量，如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个长度为3容量为5的整形切片</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>分别指定长度和容量时，创建出来的切片的底层数组长度就是创建时指定的容量，但是初始化后并不能访问所有的数组元素。上面代码中的切片可以访问3个元素，而底层数组拥有5个元素，因此剩余的2个元素可以在后期操作中合并到切片，然后才可以通过切片访问这些元素。<br>基于上面这个切片创建的新的切片，新切片会和原有切片共享底层数组，也能通过后期操作来访问多余容量的元素。不过不允许创建容量小于底层数组长度的切片</li><li>切片字面量创建切片<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 长度和容量都是5的字符串切片</span><br>slice := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>&#125;<br></code></pre></td></tr></table></figure>这种方式和创建数组类似，但是不需要指定[]运算符里面的值，初始的长度和容量会基于初始化提供的元素的个数决定。<br>当时用切片字面量时，可以设置初始长度和容量，要坐的就是在初始化时给出所需的长度和容量作为索引（下标），下面的代码展示了如何创建长度和容量都是100个元素的切片：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">slice := []string&#123;<span class="hljs-number">99</span>:<span class="hljs-string">&quot;&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li>nil和空切片<br>有时候程序可能需要一个值为nil的切片，只需要在声明时不做任何初始化，就会创建nil切片，如：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">slice</span> []string<br></code></pre></td></tr></table></figure>在GO语言中，nil切片是常见的创建切片的方法。nil切片多用于标准库和内置函数，在需要描述一个目前暂时不存在的切片时，nil切片十分好用。比如，函数要求返回一个切片但是发生异常的时候，利用初始化，通过声明一个切片可以创建一个nil切片：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用make创建空的整形切片</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 使用切片字面量创建空的字符串切片</span><br>slice := []<span class="hljs-type">string</span>&#123;&#125;<br></code></pre></td></tr></table></figure>nil切片在底层数组中包含0个元素，也没有分配任何存储空间。<br>此外，nil切片还可以表示空集合，比如，数据库查询返回0个查询结果时，nil切片和普通切片一样，调用append、len、cap的效果都是一样的。</li></ul><h6 id="切片之间的比较"><a href="#切片之间的比较" class="headerlink" title="切片之间的比较"></a>切片之间的比较</h6><p>切片之间是不能比较的，我们不能使用 &#x3D;&#x3D; 运算符判断两个切片是否拥有完全相同元素。切片唯一合法的比较操作是和nil比较。一个nil值的切片没有底层数组，长度和容量都为0，但是一个长度和容量都为0的切片就是nil，判断切片是否为空不能通过切片是否为nil，可以通过len()获取切片长度是否为0来判断。</p><p><font color="red">切片需要初始化后才可以使用。</font></p><h6 id="切片的删除"><a href="#切片的删除" class="headerlink" title="切片的删除"></a>切片的删除</h6><p>切片删除示例如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> := <span class="hljs-selector-attr">[]</span>int&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-attr">[]</span>int <span class="hljs-comment">// 声明一个新切片（也可以赋值给原有的切片a）</span><br><span class="hljs-selector-tag">b</span> = <span class="hljs-built_in">append</span>(<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[0:2]</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[3:]</span>...)<br>fmt<span class="hljs-selector-class">.Println</span>(b)<br><span class="hljs-comment">// [1 2 4 5]</span><br></code></pre></td></tr></table></figure><h6 id="切片的使用"><a href="#切片的使用" class="headerlink" title="切片的使用"></a>切片的使用</h6><p>给切片的某个元素赋值和给数组的某个元素赋值在方法上完全一样，使用[]运算符就可以改变某个元素的值。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">slice</span> := []int&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// 改变索引为1的值</span><br><span class="hljs-built_in">slice</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>切片之所以被称之为切片，是因为每创建一个新的切片就是把底层数组切出一部分，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// 创建一个新切片，长度和容量分别为2和4</span><br>newSlice := slice[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] <span class="hljs-comment">// 等于从2开始切割，取2，3两个值，而容量是除去1以外的原切片的长度作为容量</span><br></code></pre></td></tr></table></figure><p>执行上述代码后，就有个两个切片，它们共享同一段底层数组，但通过不同的切片会看到底层数组的不同部分。<br>第一个切片slice能访问底层数组全部5个元素的容量，之后的newSlice就不行，newSlice切片的容量为4，无法访问到指向的底层数组第一个元素之前的部分，换而言之，之前的元素是不存在的。<br>一个常见的描述是，对于底层数组容量是k的切片slice[i:j:k]，长度为j-i，容量为k-i。<br>需要注意的是，现在的两个切片共享同一个底层数组，如果一个切片修改了底层数组的共享部分，另一个也会被影响。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">slice :<span class="hljs-type"></span>= []int&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">new</span><span class="hljs-type">Slice</span> :<span class="hljs-type"></span>= slice[<span class="hljs-number">1</span>:<span class="hljs-type">3</span>]<br><span class="hljs-keyword">new</span><span class="hljs-type">Slice</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span><br><span class="hljs-comment">// 此时slice输出为：[1 2 6 4 5]</span><br></code></pre></td></tr></table></figure><p>切片只能访问到它自身长度内的元素，试图访问超出其长度的元素将会导致语言运行时异常。</p><h6 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h6><p>对于数组而言，因为数组长度是固定的，使用切片的好处是可以按需增加数据集合的容量。GO语言的内置append()函数可以处理增加长度时所有的操作细节。<br>使用append()时，需要一个被操作的切片和一个要追加的值：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">slice :<span class="hljs-type"></span>= []int&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">new</span><span class="hljs-type">Slice</span> :<span class="hljs-type"></span>= slice[<span class="hljs-number">1</span>:<span class="hljs-type">3</span>]<br><span class="hljs-keyword">new</span><span class="hljs-type">Slice</span> = append(<span class="hljs-keyword">new</span><span class="hljs-type">Slice</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 输出： [2 3 6]</span><br></code></pre></td></tr></table></figure><p>当append()被调用时会返回一个包含修改结果的新切片。函数append()只能增加新的切片的长度，而容量有可能会改变，也有可能不会改变，因为newSlice在底层数组里还有额外的可用容量，append()操作将可用的元素合并到切片的长度，并对其赋值。如果切片的底层数组没有足够的可用容量，append()会创建一个新的底层数组，将被引用的现有的值复制到新数组，再追加新的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>newSlice := <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>在这个append()操作完成后，newSlice拥有一个全新的底层数组，容量为原有的两倍</p><p>可以通过<code>$GOROOT/src/runtime/slice.go</code>源码，查看GO语言扩容策略：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span><span class="hljs-type">cap</span> :<span class="hljs-type"></span>= old.cap<br>doublecap :<span class="hljs-type"></span>= <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> + <span class="hljs-keyword">new</span><span class="hljs-type">cap</span><br><span class="hljs-keyword">if</span> cap &gt; doublecap &#123;<br>    <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = cap<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> old.cap &lt; <span class="hljs-number">1024</span> &#123;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = doublecap<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><br>        <span class="hljs-comment">// and prevent an infinite loop.</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &amp;&amp; <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &lt; cap &#123;<br>                <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> += <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> / <span class="hljs-number">4</span><br>        &#125;<br>        <span class="hljs-comment">// Set newcap to the requested cap when</span><br>        <span class="hljs-comment">// the newcap calculation overflowed.</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &lt;= <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = cap<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看出：</p><ul><li>首先判断，如果新申请容量(cap)大于2倍的旧容量(old.cap)，最终容量(newcap)就是新申请的容量(cap).&#x3D;。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即(newcap&#x3D;doublecap)</li><li>否则判断，如果旧切片大于1024，则最终容量(newcap)就是从旧容量(old.cap)循环增加原来的四分之一，即(newcap&#x3D;old.cap,for(newcap +&#x3D; newcap&#x2F;4))，直到最终容量大于新申请的容量(cap)，即(newcap &gt;&#x3D; cap)</li><li>如果最终值(cap)计算溢出，则最终容量(cap)就是新申请容量(cap)</li></ul><p>需要注意的是，切片扩容还会根据切片中元素类型的不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不同。</p><h6 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h6><p>切片是一个集合，那么自然可以迭代其中的元素，那么自然可以迭代其中的元素，可以使用特殊关键字range，配合关键字for来迭代切片里的元素。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">slice</span> := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>// 迭代元素并输出<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">index</span>, <span class="hljs-keyword">value</span> := range <span class="hljs-keyword">slice</span> &#123;<br>    fmt.printF(&quot;index : %d value : %d&quot;, <span class="hljs-keyword">index</span>, <span class="hljs-keyword">value</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>和数组迭代类似，迭代切片时，range会返回两个值。第一个值是当前迭代到的索引位置，第二个值是该位置对应元素的一份副本。</p><p>注意，range创建的事每个元素的副本，而不是对该元素的引用，如下面代码所示。如果使用该值变量的地址作为指向每个元素的指针，就会造成错误。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada">slice := []int&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> slice &#123;<br>fmt.Printf(<span class="hljs-string">&quot;value : %d valueAddr : %X elemAddr : %X\n&quot;</span>, value, &amp;value, &amp;slice[index])<br>&#125;<br>/*value : 1 <span class="hljs-type">valueAddr</span> : <span class="hljs-type">C0000B2008</span> elemAddr : <span class="hljs-type">C0000AA060</span><br>value : 2 <span class="hljs-type">valueAddr</span> : <span class="hljs-type">C0000B2008</span> elemAddr : <span class="hljs-type">C0000AA068</span><br>value : 3 <span class="hljs-type">valueAddr</span> : <span class="hljs-type">C0000B2008</span> elemAddr : <span class="hljs-type">C0000AA070</span><br>value : 4 <span class="hljs-type">valueAddr</span> : <span class="hljs-type">C0000B2008</span> elemAddr : <span class="hljs-type">C0000AA078</span><br>value : 5 <span class="hljs-type">valueAddr</span> : <span class="hljs-type">C0000B2008</span> elemAddr : <span class="hljs-type">C0000AA080</span>*/<br></code></pre></td></tr></table></figure><p>上面的valueAddr之所以全部一样，是因为range执行时返回的这个value变量实际上是同一个变量，被依次不断输出，所以value的值总是相同的。因此想要获取每个元素的地址，可以使用切片变量和索引值。如果不使用索引值，可以使用空白占位符忽略这个值。</p><p>关键字range总是从切片头部开始迭代的，如果想对迭代做更多的控制，可以用传统的for循环：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">index</span> := <span class="hljs-number">2</span>, <span class="hljs-keyword">index</span> &lt; len(slice), <span class="hljs-keyword">index</span>++ &#123;<br>    fmt.PrintF(<span class="hljs-string">&quot;index %d value %d\n&quot;</span>, <span class="hljs-keyword">index</span>, value)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码用到了一个内置函数，在GO语言中，有两个特殊的内置函数len()和cap()，可以处理数组、切片和通道，对于切片，函数len()返回切片的长度，函数cap()返回切片的容量。</p><h6 id="限制容量"><a href="#限制容量" class="headerlink" title="限制容量"></a>限制容量</h6><p>在创建切片时，还可以使用之前没有提到的第三个索引选项。第三个索引可以用来控制新切片的容量，其目的并不是要增加容量，而是要限制容量。可以看到，允许限制新切片的容量为底层数组提供了一定的保护，可以更好的控制追加操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// 将第三个元素做切片，并限制容量，其长度为1，容量为2</span><br>newSlice := slice[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>:<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>这个切片操作执行后，新切片从底层数组引用了1个元素，容量是2个元素。具体来说，新切片引用了<code>3</code>元素，并将容量扩展到<code>4</code>元素。可以用之前的计算方法来计算新切片的长度和容量：newSlice<a href="%5B2:3:4%5D">i:j:k</a>，长度为j-i(3-2&#x3D;1)，容量为k-i(4-2&#x3D;2)。</p><p>和之前一样，第一个值表示新切片开始的元素的索引位置，这个例子是2。第二个值表示开始的索引位置（2）加上希望包括的元素的个数（1），2+1&#x3D;3，所以第二个元素就是3。为了设置容量，从索引位置2开始，加上希望容量中包括的元素个数（2），就得到了第三个值4。</p><p>如果试图设置的容量比可用的容量还大，就会得到一个语言运行时错误。</p><p>之前有提到过，内置函数append()会首先使用可用容量。一旦没有可用容量，会分配一个新的底层数组，这导致很容易忘记切片间正在共享同一个底层数组，一旦发生这种情况，对切片进行修改，很可能会导致随机且奇怪的问题。<br>对切片内容的修改会影响多个切片，却很难找到问题的原因。如果在创建切片时设置切片的容量长度一样，就可以强制让切片的第一个append()操作创建新的底层数组，与原有的底层数组分离。<br>新切片与原有的底层数组分离后，可以安全的进行后续的修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">source := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>&#125;<br><span class="hljs-comment">// 对第三个元素做切片并限制长度和容量都为1</span><br>slice := source[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>:<span class="hljs-number">3</span>]<br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-string">&quot;f&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果不追加第三个索引，由于剩下的容量都属于slice，向slice追加<code>f</code>元素会改变原有底层数组索引为3的元素，不过因为限制了slice的容量为1，当第一次使用append()函数时，会返回一个新的底层数组，这个数组包括两个元素，并将<code>c</code>复制进来，再追加<code>f</code>，并返回了一个引用了这个底层数组的新切片。<br>因为新的切片slice拥有了自己的底层数组，所以杜绝了可能发生的问题。所以可以继续向新切片追加数据，而不会担心不小心修改了其他切片中的数据，同时也保持了为切片申请新的底层数组的便捷性。</p><p>内置函数append()也是一个可变参数的函数，这意味着可以在一次调用中传递多个追加的值。使用<code>...</code>运算符，可以将一个切片的所有元素追加到另一个切片中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>fmt.PrintF(<span class="hljs-string">&quot;%v\n&quot;</span>, <span class="hljs-built_in">append</span>(s1, s2...))<br><span class="hljs-comment">// 返回[1 2 3 4]</span><br></code></pre></td></tr></table></figure><h6 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h6><p>和数组一样，切片是一维的。不过合之前提过的数组一样，可以组合多个切片形成多维切片。</p><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs twig"><span class="language-xml">slice := [][]int</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>一个包含两个元素的外层切片，每个元素包含一个内层的整形切片，外层的切片包含两个元素，每个元素都是一个切片。<br>第一个元素中的切片使用单个整数来初始化，第二个元素中的切片包括两个整数，这种组合可以让用户创建非常复杂且强大的数据结构。关于内置函数append()的规则也可以应用到组合后的切片上：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">slice := <span class="hljs-selector-attr">[]</span><span class="hljs-selector-attr">[]</span>int&#123;&#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;<br>slice<span class="hljs-selector-attr">[0]</span> = <span class="hljs-built_in">append</span>(slice<span class="hljs-selector-attr">[0]</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>GO语言中使用append()函数处理追加的方式很简明：先增长切片，再将新的整形切片赋值给外层切片的第一个元素。执行以上代码以后，会为新的整形切片分配新的底层数组，然后将切片赋值到外层切片的索引为0的元素中。<br>即使是这么简单的多维切片，操作时也会设计众多布局和值。看起来在函数间像这样传递数据结构也会很复杂，不过切片本身结构很简单，可以以很小的成本在函数间传递。</p><h6 id="将切片传递给函数"><a href="#将切片传递给函数" class="headerlink" title="将切片传递给函数"></a>将切片传递给函数</h6><p>在函数间传递切片是指在函数间以值的方式传递切片。由于切片的尺寸很小，在函数间复制和传递切片成本很低。创建一个大切片，并将这个切片以值的方式传递给函数foo()：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 分配包含100万个整形数值的切片</span><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1e6</span>)<br>slice = foo(slice)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure><p>在64位架构的机器上，一个切片需要24B的内存：指针字段需要8B，长度和容量字段分别需要8B，由于切片关联的数据包含在底层数组里，并不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组。<br>在函数间传递24B的数据会非常快速、简单，这也是切片高效的地方。不需要传递指针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本。</p><h4 id="印射（map）"><a href="#印射（map）" class="headerlink" title="印射（map）"></a>印射（map）</h4><p>印射是一种数据结构，用于存储一系列无序的键值对（类似PHP的对象），印射基于键来存储值。印射功能强大的地方是，能够基于键快速索引数据。键就像索引一样，指向该键关联的值。</p><h6 id="印射的实现"><a href="#印射的实现" class="headerlink" title="印射的实现"></a>印射的实现</h6><p>因为印射也是一个数据集合，所以也可以使用类似处理数组和切片的方式来迭代印射中的元素。但是印射是无序集合，所以即使以同样的顺序来保存键值对，每次迭代印射时，元素顺序也可能不一样。无序的原因是因为印射使用了散列表。<br>GO语言的map在底层是用hash(哈希)表实现的，在<code>$GOROOT/src/pkg/runtime/hashmap.go</code>可以查看具体实现细节（不同版本golang文件存储可能不同）。GO语言的map是一个hash数组列表，而不是像C++一样使用红黑树，与传统的hashmap一样，GO语言的map由一个个bucket组成。<br>hashmap列表中的每一个元素都被称为bucket的结构体，每个bucket可以保存8个键值对，所有元素将被hash算法填入到数组的bucket中，bucket填满后，将通过一个overflow指针来扩展一个bucket，从而形成链表，已解决hash冲突的问题。简单来说，这个map就是一个bucket指针型的一维数组，而每个bucket指针下面则不定长，可能挂着bucket指针list，也可能只有一个，视hash冲突而定。</p><h6 id="创建印射"><a href="#创建印射" class="headerlink" title="创建印射"></a>创建印射</h6><p>GO语言中创建并初始化映射的方法有很多种，使用内置的make函数或者使用映射字面量都是常见的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个键的类型是string，值的类型为int的映射</span><br>dict := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><span class="hljs-comment">// 创建一个键和值类型都为string的映射并初始化</span><br>dict := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>使用映射字面量是更常用的方法，映射的初始长度会根据初始化指定的键值对的数量来决定。</p><p>和数组、切片不同，映射可以根据新增的key-value动态伸缩，因此不存在固定长度和最大限制，但是也可以选择标明映射的初始容量capacity，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[keytype]valuetype, <span class="hljs-built_in">cap</span>)<br><br>dict := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>当map增长到容量上限时，如果再增加新的key-value，容量会自动加1，所以出于性能考虑，对于大的映射或者可能快速扩张的映射，即使只知道大概容量，也最好先标明。</p><p>映射的键可以是任何值，值的类型并不限制，内置的类型或者结构类型都可以，不过需要确定这个值可以使用<code>==</code>运算符作比较。需要注意的是，切片、函数以及包含切片的结构类型具有引用语义，都不能作为映射的键，使用这些类型会造成编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">dict := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">string</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>在使用一个映射键对应一组数据时，会非常有用。</p><h6 id="映射的使用"><a href="#映射的使用" class="headerlink" title="映射的使用"></a>映射的使用</h6><ul><li>元素赋值<br>通过指定适当类型的键并给这个键赋值就完成了映射的键值对赋值（需要注意的是，未初始化的映射不能直接对键赋值）：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> dict <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 只声明未初始化，此时dict为nil，不可使用，需要dict = map[int]int&#123;&#125;初始化才能使用</span><br>dict := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125; <span class="hljs-comment">// 声明并自动初始化，可以使用</span><br>dict[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span><br>fmt.Println(dict)<br><br><span class="hljs-comment">// 类型为切片的映射</span><br>mapSlice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 仅初始化了切片，map未初始化，还需要 mapSlice = make(map[string]int, 8)初始化</span><br><br><span class="hljs-comment">// 类型为映射的切片</span><br>sliceMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">int</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 仅初始化了map，切片未初始化，还需要sliceMap := make([]int, 8, 8)初始化</span><br></code></pre></td></tr></table></figure></li></ul><p>与切片类似，通过声明一个未初始化的映射可以创建一个值为nil的映射（称为nil映射），nil映射不能用于存储键值对，否则会产生语言运行时的错误。</p><ul><li>查找与遍历<br>从映射中取数据有两种方式，一种是获得值以及一个表示这个键是否存在的标志：<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hsp">value, <span class="hljs-keyword">exist</span> := colors[<span class="hljs-string">&quot;red&quot;</span>]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">exist</span> &#123;<br>    fmt.PrintLn(<span class="hljs-string">&quot;exist&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>另一种方式是，只返回对应的值，再判断这个值是否为0值，以此来确定键是否存在，这种只能用在映射存储的值都是非零值的情况：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">value := <span class="hljs-attribute">color</span>[<span class="hljs-string">&quot;red&quot;</span>]<br><span class="hljs-keyword">if</span> value != <span class="hljs-string">&quot;&quot;</span> &#123;<br>    fmt<span class="hljs-selector-class">.PrintLn</span>(<span class="hljs-string">&quot;exist&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>在GO语言中，通过键来索引映射时，即便这个键不存在也会返回该值对应的数据类型的零值。</li></ul><p>和迭代数组和切片一样，使用range关键字可以迭代映射里的所有值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">alphabet := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;A&quot;</span>,<br>    <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-string">&quot;B&quot;</span>,<br>    <span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-string">&quot;C&quot;</span>,<br>&#125;<br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> alphabet &#123;<br>fmt.Printf(<span class="hljs-string">&quot;key is : %s value is %s\n&quot;</span>, key, value)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>元素删除<br>GO语言提供了一个内置函数delete()用于删除容器内的元素，下面是例子：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">delete</span><span class="hljs-params">(alphabet, <span class="hljs-string">&quot;a&quot;</span>)</span></span><br></code></pre></td></tr></table></figure>上面代码会从alphabet中删除键位<code>a</code>的键值对，如果这个键不存在，那么这个调用将什么都不发生，也不会有什么副作用。但是如果传入的map变量的值是nil，该调用将导致程序抛出异常(panic)</li></ul><h6 id="将映射传递给函数"><a href="#将映射传递给函数" class="headerlink" title="将映射传递给函数"></a>将映射传递给函数</h6><p>在函数间传递映射并不会创造出该映射的一个副本。实际上，当映射传递给一个函数，并对这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs maxima">alphabet := <span class="hljs-built_in">map</span>[<span class="hljs-built_in">string</span>]<span class="hljs-built_in">string</span>&#123;<br><span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;A&quot;</span>,<br><span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-string">&quot;B&quot;</span>,<br><span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-string">&quot;C&quot;</span>,<br><span class="hljs-string">&quot;d&quot;</span>: <span class="hljs-string">&quot;D&quot;</span>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">key</span>, value := <span class="hljs-built_in">range</span> alphabet &#123;<br>fmt.Printf(<span class="hljs-string">&quot;key is : %s value is %s\n&quot;</span>, <span class="hljs-built_in">key</span>, value)<br>&#125;<br><br><span class="hljs-built_in">delete</span>(alphabet, <span class="hljs-string">&quot;c&quot;</span>)<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">key</span>, value := <span class="hljs-built_in">range</span> alphabet &#123;<br>fmt.Printf(<span class="hljs-string">&quot;key is : %s value is %s\n&quot;</span>, <span class="hljs-built_in">key</span>, value)<br>&#125;<br>//<span class="hljs-built_in">key</span> <span class="hljs-built_in">is</span> : a value <span class="hljs-built_in">is</span> A<br>//<span class="hljs-built_in">key</span> <span class="hljs-built_in">is</span> : b value <span class="hljs-built_in">is</span> B<br>//<span class="hljs-built_in">key</span> <span class="hljs-built_in">is</span> : d value <span class="hljs-built_in">is</span> D<br></code></pre></td></tr></table></figure><p>可以看到调用了delete()函数后，alphabet映射之后的值中也不再有<code>c</code>键值对应的值。这个特性和切片类似，保证可以用很小的成本来复制映射</p><p>因为map的键值对顺序是无序的，所以有些时候可以通过特殊的方法来对其进行排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">dict := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">100</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++ &#123;<br>key := fmt.Sprintf(<span class="hljs-string">&quot;stu%02d&quot;</span>, i)<br>value := rand.Intn(<span class="hljs-number">50</span>)<br>dict[key] = value<br>&#125;<br><br>fmt.Println(dict)<br>mapKey := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">for</span> oldKey := <span class="hljs-keyword">range</span> dict &#123;<br>mapKey = <span class="hljs-built_in">append</span>(mapKey, oldKey)<br>&#125;<br><br>sort.Strings(mapKey)<br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> mapKey &#123;<br>fmt.Println(v, dict[v])<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是根据key值对映射进行排序，如果想根据value值对映射排序，可以使用struct存放key和value，实现sort接口，调用sort.Sort进行排序</p>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang常用数据类型</title>
    <link href="/2022/05/31/golang%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/05/31/golang%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang接口与反射</title>
    <link href="/2022/05/31/golang%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/05/31/golang%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口在GO语言中有着至关重要的地位，如果说goroutine和channel是支撑GO语言的并发模型的基石，让GO语言在如此集群化和多核化的时代称为一道极为靓丽的风景，那么接口就是整个类型系统的基石，让GO语言语言在基础编程哲学的探索上各个过达到前所未有的高度。</p><h6 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h6><p><font color="red">接口是一种类型，一种抽象的类型。</font></p><p>GO语言是“非传统”的面向对象编程语言，它没有类和继承的概念，但是GO语言有灵活的接口概念，通过它可以实现很多面向对象的特性。接口提供了一种方式来说明对象的行为：如果谁能实现这件事，那么它就可以在这里调用。<br>接口定义了一组方法（方法集），但是这些方法不包含（实现）代码–他们没有被实现（它们是抽象的），接口里也不能包含变量。<br>接口可以通过下面方式定义：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">接口类型名 </span><span class="hljs-keyword">interface</span>&#123;<br>    方法名<span class="hljs-number">1</span>( 参数列表<span class="hljs-number">1</span> ) 返回值列表<span class="hljs-number">1</span><br>    方法名<span class="hljs-number">2</span>( 参数列表<span class="hljs-number">2</span> ) 返回值列表<span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的接口名是一个接口类型。按照约定，只包含一个方法的接口名字由方法名加[e]r后缀组成，例如Pointer，Writer，Logger等。还有一些不常用的方式（后缀不适合er时），比如Recoverable，此时以able结尾，胡哦哦这以I开头。</p><p>GO语言的接口都很简短，通常会包含0~3个方法。不像大多数面向对象编程语言，在GO语言中接口可以有值，一个接口类型的变量或者一个接口值，例如 var in Writer，其中in是一个多字(multiword)数据结构，它的值为nil，它本质上是一个指针，虽然完全不是一回事。指向接口值的指针是非法的，它们不仅一点用没有，还会导致代码错误，此处的方法指针是通过运行时反射能力构建的。</p><p>类型（比如结构体）实现接口方法集中的方法，每一个方法的实现说明了此方法是如何作用于该类型的：即实现接口，同时方法集也集成了该类型的接口，同时方法集也构成了该类型的接口。实现了Writer接口类型的变量可以赋值给 in （接收者值），此时方法表中的指针会指向被实现的接口方法。当然如果另一个类型（也实现了该接口）的变量被赋值给ai，对应指针和方法实现也会随之改变。</p><p>类型不需要显式声明它实现了某个接口：接口被隐式实现。多个类型可以实现同一个接口，实现某个接口的类型（除了实现接口方法外），还可以有其他的方法。一个类型可以实现多个接口，接口类型可以包含一个实例的引用，该实例的类型实现了此接口（接口是动态类型）。</p><p>即使接口在类型实现之后才定义，二者处于不同的包中，被单独编译，只要类型实现了接口中的方法，它就实现了此接口，所有这些特性使得接口有很大的灵活性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Sharper <span class="hljs-keyword">interface</span> &#123;<br>area() <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Square <span class="hljs-keyword">struct</span> &#123;<br>side <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Square)</span></span> area() <span class="hljs-type">float32</span> &#123;<br><span class="hljs-keyword">return</span> s.side * s.side<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>square1 := <span class="hljs-built_in">new</span>(Square)<br>square1.side = <span class="hljs-number">6.2</span><br><br><span class="hljs-comment">//定义 squareArea</span><br><span class="hljs-comment">//squareArea = square1 // 实际会报错，没有解析</span><br><span class="hljs-comment">//更简洁，不需要分开定义</span><br><span class="hljs-comment">//squareArea := Sharper(square1)</span><br><span class="hljs-comment">//甚至这样</span><br>squareArea := square1<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;area is &quot;</span>, squareArea.area())<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序定义了一个接口体Square和一个借口Sharper，接口有一个方法area()，在main()方法中创建了一个Square的实例。在主程序外面定义了一个接收者类型是Square的area()方法，用来计算正方形的面积，结构体Square实现了接口Sharper。<br>所以可以将一个Square类型的变量赋值给一个接口类型的变量：squareArea &#x3D; square1。<font color="red">存疑，实际操作会报未解析的变量</font><br>现在接口变量包含一个指向Square变量的引用，通过它可以调用Square上的方法area()。当然也可以直接在Square的实例上调用此方法，但是在接口实例上调用此方法更具有通用性。接口变量包含了接收者实例的值和指向对应方法表的指针。<br>这就是GO语言版本的“多态”，多态是面向对象编程中一个广为人知的概念：根据当前的类型选择正确的方法，或者说同一种类型在不同的实例上表现出不同的行为。<br>如果Square没有实现area()方法，编译器就会给出清晰的报错信息。<br>同时如果Sharper有另一个方法Perimeter()，但是Square没有实现它，即使没有人在Square实例上调用这个方法，编译器也会报错。<br>扩展上面的例子，类型Rectangle也实现了Sharper接口。接着创建一个Sahrper类型的数据，迭代它的每一个元素并在上面调用area()方法，以此来展示多态行为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Sharper <span class="hljs-keyword">interface</span> &#123;<br>area() <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Square <span class="hljs-keyword">struct</span> &#123;<br>side <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Square)</span></span> area() <span class="hljs-type">float32</span> &#123;<br><span class="hljs-keyword">return</span> s.side * s.side<br>&#125;<br><br><span class="hljs-keyword">type</span> Rectangle <span class="hljs-keyword">struct</span> &#123;<br>width, length <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Rectangle)</span></span> area() <span class="hljs-type">float32</span> &#123;<br><span class="hljs-keyword">return</span> r.width * r.length<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := &amp;Rectangle&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125; <span class="hljs-comment">// 传入指针</span><br>s := Square&#123;<span class="hljs-number">5</span>&#125;        <span class="hljs-comment">// 传入值</span><br><span class="hljs-comment">//shapes := []Sharper&#123;Sharper(r), Sharper(s)&#125;</span><br><span class="hljs-comment">//简洁写法</span><br>shapes := []Sharper&#123;r, s&#125;<br><br><span class="hljs-keyword">for</span> n, _ := <span class="hljs-keyword">range</span> shapes &#123;<br>fmt.Println(<span class="hljs-string">&quot;形状参数：&quot;</span>, shapes[n])<br>fmt.Println(<span class="hljs-string">&quot;形状面积：&quot;</span>, shapes[n].area())<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用shapes[n].area()时，只知道shapes[n]是一个Sharper对象，最后摇身一变成为了一个Square或Rectangle对象，并展示了相应的行为。<br>下面是一个更具体的例子：有两个类型stockPosition和car，他们都有一个getValue()方法，可以定义一个具有此方法的接口valuable。接着定义一个使用valuable类型作为参数的函数showValue()，所有实现了valuable接口的类型都可以使用这个函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> stockPosition <span class="hljs-keyword">struct</span> &#123;<br>ticker     <span class="hljs-type">string</span><br>sharePrice <span class="hljs-type">float32</span><br>count      <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s stockPosition)</span></span> getValue() <span class="hljs-type">float32</span> &#123;<br><span class="hljs-keyword">return</span> s.sharePrice * s.count<br>&#125;<br><br><span class="hljs-keyword">type</span> car <span class="hljs-keyword">struct</span> &#123;<br>brand <span class="hljs-type">string</span><br>price <span class="hljs-type">float32</span><br>model <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c car)</span></span> getValue() <span class="hljs-type">float32</span> &#123;<br><span class="hljs-keyword">return</span> c.price<br>&#125;<br><br><span class="hljs-keyword">type</span> valuable <span class="hljs-keyword">interface</span> &#123;<br>getValue() <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showValue</span><span class="hljs-params">(asset valuable)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;价值为：&quot;</span>, asset.getValue())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> o valuable<br>o = stockPosition&#123;<span class="hljs-string">&quot;DIDI&quot;</span>, <span class="hljs-number">121.5</span>, <span class="hljs-number">2000</span>&#125;<br>showValue(o)<br>o = car&#123;price: <span class="hljs-number">100000</span>, brand: <span class="hljs-string">&quot;Benz&quot;</span>&#125;<br>showValue(o)<br>&#125;<br></code></pre></td></tr></table></figure><p>举一个标准库的例子，io包里面有一个借口Reader：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>定义变量var r io.Reader，那么就可以写如下代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> r io<span class="hljs-selector-class">.Reader</span><br>r = os<span class="hljs-selector-class">.Stdin</span><br>r = bufio<span class="hljs-selector-class">.NewReader</span>(r)<br>r = <span class="hljs-built_in">new</span>(bytes.Buffer)<br>f, _ := os<span class="hljs-selector-class">.Open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)<br>r = bufio<span class="hljs-selector-class">.NewReader</span>(f)<br></code></pre></td></tr></table></figure><p>上面r右边的类型都实现了Read()方法，并且有相同的方法签名，r的静态类型是io.Reader。<br>注意，有些时候也会用一种稍微不同的方式来使用接口这个词，从某个类型的角度来看，它的接口指的是：它的所有导出方法，只不过没有显示的为这些导出方法额外指定一个接口而已。</p><h6 id="接口类型与约定"><a href="#接口类型与约定" class="headerlink" title="接口类型与约定"></a>接口类型与约定</h6><p>接口类型实际上是描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。<br>io.Writter类型是用的最广泛的接口之一，因为它提供了所有的类型写入bytes（字节）的抽象，包括文件类型、内存缓冲区、网络连接、HTTP客户端、压缩工具、哈希等。io包中定义了很多其他游泳的接口类型。io.Reader可以代表任意可读取bytes的类型，io.Closer可以是任意可以关闭的值，例如一个文件或者网络连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> io<br><br><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Closer <span class="hljs-keyword">interface</span> &#123;<br>Close() <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>再往下看，我们发现有些的接口类型通过组合已经有了接口来定义，如下例：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">ReadWriter</span> interface &#123;<br><span class="hljs-type">Reader</span><br><span class="hljs-type">Writer</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">ReadWriteCloser</span> interface &#123;<br><span class="hljs-type">Reader</span><br><span class="hljs-type">Writer</span><br><span class="hljs-type">Closer</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面用到的语法和结构内嵌相似，可以用这种方式以一个简写命名另一个接口，而不用声明它所有的方法，这种方式被称为接口内嵌。尽管略失简洁性，可以像下面这样，不用使用内嵌来声明io.Writer接口：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> ReadWriter interface &#123;<br>    <span class="hljs-constructor">Read(<span class="hljs-params">p</span> []<span class="hljs-params">byte</span>)</span> (n <span class="hljs-built_in">int</span>, err error)<br>    <span class="hljs-constructor">Write(<span class="hljs-params">p</span> []<span class="hljs-params">byte</span>)</span> (n <span class="hljs-built_in">int</span>, err error)<br>&#125;<br>或者使用混合的方式：<br><span class="hljs-keyword">type</span> ReadWriter interface &#123;<br>    <span class="hljs-constructor">Read(<span class="hljs-params">p</span> []<span class="hljs-params">byte</span>)</span> (n <span class="hljs-built_in">int</span>, err error)<br>    Writer<br>&#125;<br></code></pre></td></tr></table></figure><p>上面三种定义方式效果都是一样的。方法的顺序变化也没有影响，唯一重要的就是这个集合里面的方法。</p><blockquote><p>动态类型（类型断言）</p></blockquote><p>一个接口类型的变量param1中可以包含任何类型的值，必须有一种方法来检测它的动态类型，即运行时在变量中存储的值的实际类型。在执行过程中动态类型可能会有所不同，但是它一定是可以分配给接口变量的类型。通常可以使用类型断言（GO语言内置的一种智能推断类型的功能）来测试某个时刻param1中是否包含类型T的值：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">v := para<span class="hljs-name">m1.</span><span class="hljs-comment">(T)</span> <span class="hljs-comment">// T代表可能是的类型</span><br></code></pre></td></tr></table></figure><p>param1必须是一个借口变量，否则编译器会报错。<br>类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能遇见所有的可能性，如果在程序运行时失败，会导致错误产生，所以更安全的方式用以下的方式断言：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">if</span> v, ok := para<span class="hljs-name">m1.</span><span class="hljs-comment">(T)</span><br><span class="hljs-keyword">if</span> ok &#123;<br>    Process<span class="hljs-comment">(v)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果对一个接口值有多个实际类型需要判断，可以使用Switch语句来判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isInterface</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">switch</span> v := i.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>fmt.Println(v, <span class="hljs-string">&quot;is string&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>fmt.Println(v, <span class="hljs-string">&quot;is int&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果转换合法，v是param1转换到类型T的值，ok会是true；否则v会是类型T的零值，ok也是false，也没有运行时错误发生。</p><p>下面是接口在runtime 中的实现，注意其中包含了接口本身和实际数据类型的类型信息：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">// src/runtime/runtime2.go</span><br><span class="hljs-built_in">type</span> iface <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 包含接口的静态类型信息、数据的动态类型信息和函数表</span><br>    <span class="hljs-built_in">tab</span> *itab<br>    <span class="hljs-comment">// 指向具体数据的内存地址，比如slice、map 等，或者在接口转换时直接存放小效据(一个指针的长度</span><br>    data unsafe.Pointer<br>&#125;<br><span class="hljs-built_in">type</span> itab <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// 接口的类型信息</span><br>    inter *interfacetype<br>    <span class="hljs-comment">// 具体数据的类型信息</span><br>    _type <span class="hljs-built_in">type</span><br>    link *itab<br>    hash uint32<br>    bad <span class="hljs-keyword">bool</span><br>    inhash <span class="hljs-keyword">bool</span><br>    unused [<span class="hljs-number">2</span>]byte<br>    <span class="hljs-comment">// 函数地址表，这里放置和接口方法对应的具体数据类型的方法地址实现接口调用方法的动态分派，一般在每次给接口賦值发生转换时会更新此表，或者直接获取缓存的itab</span><br>    fun [<span class="hljs-number">1</span>]uintptr <span class="hljs-comment">// 变量大小</span><br></code></pre></td></tr></table></figure><p>此外，需要注意与接口相关的两点优化，会影响到反射等的实现。</p><ol><li>空接口（intertacef3）的 itab优化：当将菜个类型赋值给空接口时。由于空接口没有方法，所以上面空接口iface的tab字段会直接指向数据的具体类型。在GO语言的reflect包中，reflect.TypeOf 和 refleet.ValueOf的参数都是空接口，因此所有参数都会先转换为空接口奖型，这样反射就安现了对所有参数类型获取实际数据类型的统一，这在后面反射的基本实现中会分析到。</li><li>发生“接口转換”时 data 字段相关的优化：当被转换为接口的数据的类型长度<br>不超过一个指针的长度时（比如pointer、map、func、chan、[1]int 等类型），接口转换时会将数据直接复制到接口的 data 字段（Driectface） 中，而不再额外分配内存并复制。另外，从GO1.8+的源码来看除 Driectface 的优化以外，还对长度较小（不超过64B，未初始化数据内存的 array、空字符串等）的零值做了优化，也不会重新分配内存，而是直接指向一个包级全局数组变量 zeroVal的首地址。注意这里的优化发生在接口转换时生成的<br>临时接口上，而不是被赋值的接口左值上。<br>再者，在 Go 语言中只有值传递（包括接口类型），与具体的类型实现无关，但是某些类型具有引用的属性。典型的9种非基础类型中：</li></ol><ul><li>array 传递会复制整块数据内存，传递长度为 len(arr) * Sizeof(elem)。</li><li>string.slice、interface 传递的是其 runtime 的实现，所以长度是固定的，分别为 16B、24B、16B (AMD64)</li><li>map、func、 chan、pointer 传递的是指针，所以长度固定为 8B (AMD64)</li><li>struct 传递的是所有字段的内存副本，所以长度是所有字段的长度之和。</li></ul><h6 id="嵌套接口"><a href="#嵌套接口" class="headerlink" title="嵌套接口"></a>嵌套接口</h6><p>一个接口可以包含一个或者多个接口，这相当于将这些内嵌接口的方法列举在外层接口中。</p><h6 id="接口赋值"><a href="#接口赋值" class="headerlink" title="接口赋值"></a>接口赋值</h6><p>接口赋值在GO语言中分为两种情况：把对象实例赋值给接口；将一个接口赋值给另一个接口。</p><p>先说将某种类型的对象实例赋值给接口，这要求该对象实例实现了接口所要求的的所有方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">type</span> <span class="hljs-type">Integer</span> <span class="hljs-type">int</span><br><br>func (a <span class="hljs-type">Integer</span>) less(b <span class="hljs-type">Integer</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> a &lt; b<br>&#125;<br><br>func (a *<span class="hljs-type">Integer</span>) <span class="hljs-keyword">add</span>(b <span class="hljs-type">Integer</span>) &#123;<br>*a += b<br>&#125;<br><br><span class="hljs-keyword">type</span> lessAdd interface &#123;<br>less()<br><span class="hljs-keyword">add</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果现在有一个Integer类型的对象实例，下面该如何才能赋值给lessAdd接口呢？</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> Integer<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> lessAdd = &amp;<span class="hljs-selector-tag">a</span> <span class="hljs-comment">// 语句1</span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> lessAdd = <span class="hljs-selector-tag">a</span> <span class="hljs-comment">// 语句2</span><br></code></pre></td></tr></table></figure><p>答案应该是语句1，因为add()方法中需要的接收者是指针类型，GO语言可以根据方法less()自动生成一个使用指针接收者的方法，这样一样类型Integer为指针传值时同时满足了接口lessAdd，而GO语言不能自动生成一个值接收者的add()方法，所以语句2不行。</p><p>接下来是另一种情况————将一个接口赋值给另一个接口。在GO语言中，只要两个接口拥有相同的方法列表（方法顺序不影响），那么它们就是等同的，可以相互赋值：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">package</span> <span class="hljs-title">one</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">look </span><span class="hljs-keyword">interface</span> &#123;<br>    read()<br>&#125;<br><br><span class="hljs-keyword">package</span> <span class="hljs-title">two</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">listen </span><span class="hljs-keyword">interface</span> &#123;<br>    read()<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有两个不同包的不同接口，但是都实现了read()方法，在GO语言中，这两个接口并无区别，因为任何实现了one.look接口的类，均实现了two.listen；任何one.look接口都可以赋值给two.listen，相反也是一样。<br>接口赋值并不需要两个接口必须等价。如果接口A的方法列表是接口B的方法列表的子集，那么接口B就可以赋值给接口A，反之却不行，因为接口A没有实现B所有的方法列表。</p><h6 id="接口查询"><a href="#接口查询" class="headerlink" title="接口查询"></a>接口查询</h6><p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库io源码中就有很多接口之间互相组合的示例。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs elm">// src/io/io.go<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">Reader</span> interface &#123;<br><span class="hljs-type">Read</span>(p []byte) (n int, err error)<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">Writer</span> interface &#123;<br><span class="hljs-type">Write</span>(p []byte) (n int, err error)<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">Closer</span> interface &#123;<br><span class="hljs-type">Close</span>() error<br>&#125;<br><br>// <span class="hljs-type">ReadWriter</span> 是组合<span class="hljs-type">Reader</span>接口和<span class="hljs-type">Writer</span>接口形成的新接口类型<br><span class="hljs-keyword">type</span> <span class="hljs-type">ReadWriter</span> interface &#123;<br><span class="hljs-type">Reader</span><br><span class="hljs-type">Writer</span><br>&#125;<br><br>// <span class="hljs-type">ReadCloser</span> 是组合<span class="hljs-type">Reader</span>接口和<span class="hljs-type">Closer</span>接口形成的新接口类型<br><span class="hljs-keyword">type</span> <span class="hljs-type">ReadCloser</span> interface &#123;<br><span class="hljs-type">Reader</span><br><span class="hljs-type">Closer</span><br>&#125;<br><br>// <span class="hljs-type">WriteCloser</span> 是组合<span class="hljs-type">Writer</span>接口和<span class="hljs-type">Closer</span>接口形成的新接口类型<br><span class="hljs-keyword">type</span> <span class="hljs-type">WriteCloser</span> interface &#123;<br><span class="hljs-type">Writer</span><br><span class="hljs-type">Closer</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p><p>接口也可以作为结构体的一个字段，我们来看一段Go标准库sort源码中的示例。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// src/sort/sort.go</span><br><br><span class="hljs-comment">// Interface 定义通过索引对元素排序的接口类型</span><br><span class="hljs-keyword">type</span> Interface interface &#123;<br>    <span class="hljs-constructor">Len()</span> <span class="hljs-built_in">int</span><br>    <span class="hljs-constructor">Less(<span class="hljs-params">i</span>, <span class="hljs-params">j</span> <span class="hljs-params">int</span>)</span> <span class="hljs-built_in">bool</span><br>    <span class="hljs-constructor">Swap(<span class="hljs-params">i</span>, <span class="hljs-params">j</span> <span class="hljs-params">int</span>)</span><br>&#125;<br><br><br><span class="hljs-comment">// reverse 结构体中嵌入了Interface接口</span><br><span class="hljs-keyword">type</span> reverse <span class="hljs-keyword">struct</span> &#123;<br>    Interface<br>&#125;<br></code></pre></td></tr></table></figure><p>通过在结构体中嵌入一个接口类型，从而让该结构体类型实现了该接口类型，并且还可以改写该接口的方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Less 为reverse类型添加Less方法，重写原Interface接口类型的Less方法</span><br>func (r reverse) <span class="hljs-constructor">Less(<span class="hljs-params">i</span>, <span class="hljs-params">j</span> <span class="hljs-params">int</span>)</span> <span class="hljs-built_in">bool</span> &#123;<br>return r.Interface.<span class="hljs-constructor">Less(<span class="hljs-params">j</span>, <span class="hljs-params">i</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Interface类型原本的Less方法签名为Less(i, j int) bool，此处重写为r.Interface.Less(j, i)，即通过将索引参数交换位置实现反转。<br>在这个示例中还有一个需要注意的地方是reverse结构体本身是不可导出的（结构体类型名称首字母小写），sort.go中通过定义一个可导出的Reverse函数来让使用者创建reverse结构体实例。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">func <span class="hljs-keyword">Reverse</span>(data <span class="hljs-keyword">Interface</span>) <span class="hljs-keyword">Interface</span> &#123;<br><span class="hljs-keyword">return</span> &amp;<span class="hljs-keyword">reverse</span>&#123;data&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做的目的是保证得到的reverse结构体中的Interface属性一定不为nil，否者r.Interface.Less(j, i)就会出现空指针panic。</p><h6 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h6><p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。</p><p>通常在使用空接口时，定义方式如下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">type</span> Any <span class="hljs-keyword">interface</span><span class="hljs-comment">&#123;&#125;</span><br><span class="hljs-comment">// 或直接在代码中声明并命名</span><br><span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span><span class="hljs-comment">&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>使用空接口可以实现接收任意类型参数的函数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 空接口作为函数参数</span><br>func <span class="hljs-built_in">show</span>(<span class="hljs-selector-tag">a</span> interface&#123;&#125;) &#123;<br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;type:%T value:%v\n&quot;</span>, <span class="hljs-selector-tag">a</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以实现保存任意类型数据的map</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> studentInfo = <span class="hljs-built_in">make</span>(map<span class="hljs-selector-attr">[string]</span>interface&#123;&#125;)<br>studentInfo<span class="hljs-selector-attr">[<span class="hljs-string">&quot;name&quot;</span>]</span> = <span class="hljs-string">&quot;john&quot;</span><br>studentInfo<span class="hljs-selector-attr">[<span class="hljs-string">&quot;age&quot;</span>]</span> = <span class="hljs-number">18</span><br>studentInfo<span class="hljs-selector-attr">[<span class="hljs-string">&quot;married&quot;</span>]</span> = false<br>fmt<span class="hljs-selector-class">.Println</span>(studentInfo)<br></code></pre></td></tr></table></figure><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h2>反射介绍</h2>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。<p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><p>Go程序在运行期使用reflect包访问程序的反射信息。</p><p>反射是一个强大的工具，但是也存在一定的隐患，除非真的有必要，否则应当避免使用或者小心使用。</p><p>反射应谨慎使用的原因有三：</p><ul><li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li><li>大量使用反射的代码通常难以理解。</li><li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li></ul><h6 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h6><p>在Go语言中，使用reflect.TypeOf()函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectType</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>v := reflect.TypeOf(x)<br>fmt.Printf(<span class="hljs-string">&quot;type:%v\n&quot;</span>, v)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">float32</span> = <span class="hljs-number">3.14</span><br>reflectType(a) <span class="hljs-comment">// type:float32</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int64</span> = <span class="hljs-number">100</span><br>reflectType(b) <span class="hljs-comment">// type:int64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在反射中关于类型还划分为两种：类型（Type）和种类（Kind）。因为在GO语言中我们可以使用type关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类（Kind）。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectType</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>t := reflect.TypeOf(x)<br>fmt.Printf(<span class="hljs-string">&quot;type:%v kind:%v\n&quot;</span>, t.Name(), t.Kind())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a *<span class="hljs-type">float32</span> <span class="hljs-comment">// 指针</span><br><span class="hljs-keyword">var</span> b myInt    <span class="hljs-comment">// 自定义类型</span><br><span class="hljs-keyword">var</span> c <span class="hljs-type">rune</span>     <span class="hljs-comment">// 类型别名</span><br>reflectType(a) <span class="hljs-comment">// type: kind:ptr</span><br>reflectType(b) <span class="hljs-comment">// type:myInt kind:int64</span><br>reflectType(c) <span class="hljs-comment">// type:int32 kind:int32</span><br><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>age  <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">type</span> book <span class="hljs-keyword">struct</span>&#123; title <span class="hljs-type">string</span> &#125;<br><span class="hljs-keyword">var</span> d = person&#123;<br>name: <span class="hljs-string">&quot;john&quot;</span>,<br>age:  <span class="hljs-number">18</span>,<br>&#125;<br><span class="hljs-keyword">var</span> e = book&#123;title: <span class="hljs-string">&quot;《GOLANG》&quot;</span>&#125;<br>reflectType(d) <span class="hljs-comment">// type:person kind:struct</span><br>reflectType(e) <span class="hljs-comment">// type:book kind:struct</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空。</p><p>在reflect包中定义的Kind类型如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">type Kind uint<br>const (<br>    Invalid Kind = iota  <span class="hljs-regexp">//</span> 非法类型<br>    Bool                 <span class="hljs-regexp">//</span> 布尔型<br>    Int                  <span class="hljs-regexp">//</span> 有符号整型<br>    Int8                 <span class="hljs-regexp">//</span> 有符号<span class="hljs-number">8</span>位整型<br>    Int16                <span class="hljs-regexp">//</span> 有符号<span class="hljs-number">16</span>位整型<br>    Int32                <span class="hljs-regexp">//</span> 有符号<span class="hljs-number">32</span>位整型<br>    Int64                <span class="hljs-regexp">//</span> 有符号<span class="hljs-number">64</span>位整型<br>    Uint                 <span class="hljs-regexp">//</span> 无符号整型<br>    Uint8                <span class="hljs-regexp">//</span> 无符号<span class="hljs-number">8</span>位整型<br>    Uint16               <span class="hljs-regexp">//</span> 无符号<span class="hljs-number">16</span>位整型<br>    Uint32               <span class="hljs-regexp">//</span> 无符号<span class="hljs-number">32</span>位整型<br>    Uint64               <span class="hljs-regexp">//</span> 无符号<span class="hljs-number">64</span>位整型<br>    Uintptr              <span class="hljs-regexp">//</span> 指针<br>    Float32              <span class="hljs-regexp">//</span> 单精度浮点数<br>    Float64              <span class="hljs-regexp">//</span> 双精度浮点数<br>    Complex64            <span class="hljs-regexp">//</span> <span class="hljs-number">64</span>位复数类型<br>    Complex128           <span class="hljs-regexp">//</span> <span class="hljs-number">128</span>位复数类型<br>    Array                <span class="hljs-regexp">//</span> 数组<br>    Chan                 <span class="hljs-regexp">//</span> 通道<br>    Func                 <span class="hljs-regexp">//</span> 函数<br>    Interface            <span class="hljs-regexp">//</span> 接口<br>    Map                  <span class="hljs-regexp">//</span> 映射<br>    Ptr                  <span class="hljs-regexp">//</span> 指针<br>    Slice                <span class="hljs-regexp">//</span> 切片<br>    String               <span class="hljs-regexp">//</span> 字符串<br>    Struct               <span class="hljs-regexp">//</span> 结构体<br>    UnsafePointer        <span class="hljs-regexp">//</span> 底层指针<br>)<br></code></pre></td></tr></table></figure><p>reflect.ValueOf()返回的是reflect.Value类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以互相转换。</p><p>reflect.Value类型提供的获取原始值的方法如下：</p><p>Interface() interface {}<br>&amp;emsp;&amp;emsp; 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型<br>Int() int64<br>&amp;emsp;&amp;emsp; 将值以 int 类型返回，所有有符号整型均可以此方式返回<br>Uint() uint64<br>&amp;emsp;&amp;emsp; 将值以 uint 类型返回，所有无符号整型均可以此方式返回<br>Float() float64<br>&amp;emsp;&amp;emsp; 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回<br>Bool() bool<br>&amp;emsp;&amp;emsp; 将值以 bool 类型返回<br>Bytes() []bytes<br>&amp;emsp;&amp;emsp; 将值以字节数组 []bytes 类型返回<br>String() string<br>&amp;emsp;&amp;emsp; 将值以字符串类型返回</p><blockquote><p>通过反射获取值</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">reflectValue</span>(x interface&#123;&#125;) &#123;<br>v := reflect<span class="hljs-selector-class">.ValueOf</span>(x)<br>k := v<span class="hljs-selector-class">.Kind</span>()<br>switch k &#123;<br>case reflect<span class="hljs-selector-class">.Int64</span>:<br><span class="hljs-comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span><br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;type is int64, value is %d\n&quot;</span>, <span class="hljs-built_in">int64</span>(v<span class="hljs-selector-class">.Int</span>()))<br>case reflect<span class="hljs-selector-class">.Float32</span>:<br><span class="hljs-comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span><br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;type is float32, value is %f\n&quot;</span>, <span class="hljs-built_in">float32</span>(v<span class="hljs-selector-class">.Float</span>()))<br>case reflect<span class="hljs-selector-class">.Float64</span>:<br><span class="hljs-comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span><br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;type is float64, value is %f\n&quot;</span>, <span class="hljs-built_in">float64</span>(v<span class="hljs-selector-class">.Float</span>()))<br>&#125;<br>&#125;<br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> float32 = <span class="hljs-number">3.14</span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> int64 = <span class="hljs-number">100</span><br><span class="hljs-built_in">reflectValue</span>(a) <span class="hljs-comment">// type is float32, value is 3.140000</span><br><span class="hljs-built_in">reflectValue</span>(b) <span class="hljs-comment">// type is int64, value is 100</span><br><span class="hljs-comment">// 将int类型的原始值转换为reflect.Value类型</span><br>c := reflect<span class="hljs-selector-class">.ValueOf</span>(<span class="hljs-number">10</span>)<br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;type c :%T\n&quot;</span>, c) <span class="hljs-comment">// type c :reflect.Value</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过反射设置变量的值</p></blockquote><p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的Elem()方法来获取指针对应的值。使用CanSet方法判断是否可以被修改，而当一个Value持有值可以被寻址同时又不是来自非导出字段时，它才可以被修改。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">reflectSetValue1</span>(x interface&#123;&#125;) &#123;<br>v := reflect<span class="hljs-selector-class">.ValueOf</span>(x)<br><span class="hljs-keyword">if</span> v<span class="hljs-selector-class">.Kind</span>() == reflect<span class="hljs-selector-class">.Int64</span> &#123;<br>v<span class="hljs-selector-class">.SetInt</span>(<span class="hljs-number">200</span>) <span class="hljs-comment">//修改的是副本，reflect包会引发panic</span><br>&#125;<br>&#125;<br>func <span class="hljs-built_in">reflectSetValue2</span>(x interface&#123;&#125;) &#123;<br>v := reflect<span class="hljs-selector-class">.ValueOf</span>(x)<br><span class="hljs-comment">// 反射中使用 Elem()方法获取指针对应的值</span><br><span class="hljs-keyword">if</span> v<span class="hljs-selector-class">.Elem</span>()<span class="hljs-selector-class">.Kind</span>() == reflect<span class="hljs-selector-class">.Int64</span> &#123;<br>v<span class="hljs-selector-class">.Elem</span>()<span class="hljs-selector-class">.SetInt</span>(<span class="hljs-number">200</span>)<br>&#125;<br>&#125;<br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> int64 = <span class="hljs-number">100</span><br>v := reflect<span class="hljs-selector-class">.ValueOf</span>(a)<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;canSet: &quot;</span>, v<span class="hljs-selector-class">.CanSet</span>()) <span class="hljs-comment">// canSet:  false</span><br><span class="hljs-comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span><br><span class="hljs-built_in">reflectSetValue2</span>(&amp;a)<br>fmt<span class="hljs-selector-class">.Println</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>isNil()和isValid()</p></blockquote><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title function_">IsNil</span><span class="hljs-params">()</span> <span class="hljs-title function_">bool</span><br></code></pre></td></tr></table></figure><p>IsNil()报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title function_">IsValid</span><span class="hljs-params">()</span> <span class="hljs-title function_">bool</span><br></code></pre></td></tr></table></figure><p>IsValid()返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p><p>IsNil()常被用于判断指针是否为空；IsValid()常被用于判定返回值是否有效。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// *int类型空指针</span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> *int<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;var a *int IsNil:&quot;</span>, reflect<span class="hljs-selector-class">.ValueOf</span>(a)<span class="hljs-selector-class">.IsNil</span>()) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// nil值</span><br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;nil IsValid:&quot;</span>, reflect<span class="hljs-selector-class">.ValueOf</span>(nil)<span class="hljs-selector-class">.IsValid</span>()) <span class="hljs-comment">// false</span><br><span class="hljs-comment">// 实例化一个匿名结构体</span><br><span class="hljs-selector-tag">b</span> := struct&#123;&#125;&#123;&#125;<br><span class="hljs-comment">// 尝试从结构体中查找&quot;abc&quot;字段</span><br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;不存在的结构体成员:&quot;</span>, reflect<span class="hljs-selector-class">.ValueOf</span>(b)<span class="hljs-selector-class">.FieldByName</span>(<span class="hljs-string">&quot;abc&quot;</span>)<span class="hljs-selector-class">.IsValid</span>()) <span class="hljs-comment">// false</span><br><span class="hljs-comment">// 尝试从结构体中查找&quot;abc&quot;方法</span><br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;不存在的结构体方法:&quot;</span>, reflect<span class="hljs-selector-class">.ValueOf</span>(b)<span class="hljs-selector-class">.MethodByName</span>(<span class="hljs-string">&quot;abc&quot;</span>)<span class="hljs-selector-class">.IsValid</span>()) <span class="hljs-comment">// false</span><br><span class="hljs-comment">// map</span><br>c := map<span class="hljs-selector-attr">[string]</span>int&#123;&#125;<br><span class="hljs-comment">// 尝试从map中查找一个不存在的键</span><br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;map中不存在的键：&quot;</span>, reflect<span class="hljs-selector-class">.ValueOf</span>(c)<span class="hljs-selector-class">.MapIndex</span>(reflect<span class="hljs-selector-class">.ValueOf</span>(<span class="hljs-string">&quot;ab&quot;</span>))<span class="hljs-selector-class">.IsValid</span>()) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h5 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h5><p>任意值通过reflect.TypeOf()获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的NumField()和Field()方法获得结构体成员的详细信息。</p><p>reflect.Type中与获取结构体成员相关的的方法如下所示。</p><p>Field(i int) StructField<br>&amp;emsp;&amp;emsp; 根据索引，返回索引对应的结构体字段的信息。<br>NumField() int<br>&amp;emsp;&amp;emsp; 返回结构体成员字段数量。<br>FieldByName(name string) (StructField, bool)<br>&amp;emsp;&amp;emsp; 根据给定字符串返回字符串对应的结构体字段的信息。<br>FieldByIndex(index []int) StructField<br>&amp;emsp;&amp;emsp; 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。<br>FieldByNameFunc(match func(string) bool) (StructField,bool)<br>&amp;emsp;&amp;emsp; 根据传入的匹配函数匹配需要的字段。<br>NumMethod() int<br>&amp;emsp;&amp;emsp; 返回该类型的方法集中方法的数目<br>Method(int) Method<br>&amp;emsp;&amp;emsp; 返回该类型方法集中的第i个方法<br>MethodByName(string)(Method, bool)<br>&amp;emsp;&amp;emsp; 根据方法名返回该类型方法集中的方法</p><p>我们同样能够调用已经定义的函数在结构上的方法，例如，使用索引n来调用Method(n).Call(in []Value)</p><h2>StructField类型</h2><p>StructField类型用来描述结构体中的一个字段的信息。</p><p>StructField的定义如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">type StructField struct &#123;<br>    <span class="hljs-regexp">//</span> Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为<span class="hljs-string">&quot;&quot;</span>。<br>    <span class="hljs-regexp">//</span> 参见http:<span class="hljs-regexp">//g</span>olang.org<span class="hljs-regexp">/ref/</span>spec<span class="hljs-comment">#Uniqueness_of_identifiers</span><br>    Name    string<br>    PkgPath string<br>    Type      Type      <span class="hljs-regexp">//</span> 字段的类型<br>    Tag       StructTag <span class="hljs-regexp">//</span> 字段的标签<br>    Offset    uintptr   <span class="hljs-regexp">//</span> 字段在结构体中的字节偏移量<br>    Index     []int     <span class="hljs-regexp">//</span> 用于Type.FieldByIndex时的索引切片<br>    Anonymous bool      <span class="hljs-regexp">//</span> 是否匿名字段<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">type</span> student struct &#123;<br><span class="hljs-built_in">Name</span>  string `json:<span class="hljs-string">&quot;name&quot;</span>`<br><span class="hljs-built_in">score</span> int    `json:<span class="hljs-string">&quot;score&quot;</span>`<br>&#125;<br><br>func main() &#123;<br>stu1 := student&#123;<br><span class="hljs-built_in">Name</span>:  <span class="hljs-string">&quot;john&quot;</span>,<br><span class="hljs-built_in">score</span>: <span class="hljs-number">90</span>,<br>&#125;<br><br>t := reflect.<span class="hljs-built_in">TypeOf</span>(stu1)<br>fmt.Println(t.<span class="hljs-built_in">Name</span>(), t.Kind()) <span class="hljs-comment">// student struct</span><br><span class="hljs-comment">// 通过for循环遍历结构体的所有字段信息</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>fmt.Printf(<span class="hljs-string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.<span class="hljs-built_in">Name</span>, field.Index, field.<span class="hljs-built_in">Type</span>, field.Tag.<span class="hljs-built_in">Get</span>(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// 通过字段名获取指定结构体字段信息</span><br><span class="hljs-keyword">if</span> scoreField, ok := t.FieldByName(<span class="hljs-string">&quot;Score&quot;</span>); ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.<span class="hljs-built_in">Name</span>, scoreField.Index, scoreField.<span class="hljs-built_in">Type</span>, scoreField.Tag.<span class="hljs-built_in">Get</span>(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br>v := reflect.ValueOf(stu1)<br>v.FieldByName(<span class="hljs-string">&quot;score&quot;</span>).SetInt(<span class="hljs-number">91</span>) <span class="hljs-comment">// reflect.Value.SetInt using value obtained using unexported field，结构体中只有被导出字段（首字母大写）才可以被设置</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个例子用来调用结构体下所有包含的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>score <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;score&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s student)</span></span> Study() <span class="hljs-type">string</span> &#123;<br>msg := <span class="hljs-string">&quot;好好学习，天天向上。&quot;</span><br>fmt.Println(msg)<br><span class="hljs-keyword">return</span> msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s student)</span></span> Sleep() <span class="hljs-type">string</span> &#123;<br>msg := <span class="hljs-string">&quot;好好睡觉，快快长大。&quot;</span><br>fmt.Println(msg)<br><span class="hljs-keyword">return</span> msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMethod</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>t := reflect.TypeOf(x)<br>v := reflect.ValueOf(x)<br><br>fmt.Println(t.NumMethod())<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumMethod(); i++ &#123;<br>methodType := v.Method(i).Type()<br>fmt.Printf(<span class="hljs-string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)<br>fmt.Printf(<span class="hljs-string">&quot;method:%s\n&quot;</span>, methodType)<br><span class="hljs-comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span><br><span class="hljs-keyword">var</span> args = []reflect.Value&#123;&#125;<br>v.Method(i).Call(args)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> stu student<br>printMethod(stu)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang数据类型</title>
    <link href="/2022/05/31/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/05/31/golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>boolean 布尔型，值只能为常量 true 或 false。</li><li>int&#x2F;uint 整数类型，go语言支持无符号和带符号两种整形（有符号数为正负，无符号数只有正值）。go 的位数整形有：int8，int32（rune），int64 和uint8（byte），uint16， uint32，uint64。其中int8、int16、int32和int64 分别对应8、16、32、64b的有符号整数，无符号整数为unit8、uint16、uint32和unit64，使用是除了可以指定整形位数，也可以直接使用int和uint。</li><li>float32&#x2F;float64 浮点型，只有 float32 和 float64 这两种浮点型，没有float，默认为float64，长度分别为4字节和8字节，此外还有两个复数类型，complex64.complex128，其中complex64带有float32实部和虚部，complex128带有float64实部和虚部。</li><li>string 字符串类型，默认字符串类型字节使用UTF-8编码标识Unicode文本，且字符串类型不可变化。</li><li>派生类型 派生类型包括切片（slice），字典（map），通道（channel），指针（pointer），数组（array），结构化（struct），函数（function），接口（interface），错误（error），它们内部结构复杂，不仅需要申请内存，还需要初始化相关属性。</li></ul><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><p>有符号和无符号整形数的区别。有符号数最高位表示正负，进制转化后的最高位表示正负，同样一个字节无符号数： 11111111 值：255，而有符号数： 01111111 值：127，无符号数最大值为255，有符号数最大值为127，原因是因为有符号数最大值用来表示正负，所以值的大小缩小了。两者表达的不同的数值的个数都是256个，无符号的为0-255这256个数，有符号的为-128-127这256个数。</p><p>go 语言使用八进制，十进制，十六进制以及科学计数法标识数字，标准库math定了个各种数字类型的取值范围，int8为-128~127，unit8为0~255，int16为-32768~32767，uint16为0~65535。</p><h4 id="整形运算"><a href="#整形运算" class="headerlink" title="整形运算"></a>整形运算</h4><p>运算方式和比较方式与php大致相同，但不支持&#x3D;&#x3D;&#x3D;全等判断<br>两个类型不同的整形不能直接比较和操作<br>整形数支持&lt;&lt;、&gt;&gt;、^（异或）、&amp;（与）、|（或）、^x（取反）等位操作</p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>go支持float32和float64两种浮点型。float32精确到小数点后7位，float64精确到小数点后15位，由于标准库math包含所有有关数字运算的函数都要求接受float64这个函数，所以尽可能使用float64，避免类型转换。</p><p>浮点型运算和整形相同，但是因为精度不同结果会有差别，比如 1 和1.0000000000000001进行判断，两者会被判断相同，因为精度限制在小数点后15位，多余的值已被舍弃，所以二者相同。</p><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>go语言的复数类型关键字有两个complex64（32位实数和虚数）、complex128（64位实数和虚数），复数声明时若无指定，默认为complex128，使用函数real（v）和imag（v）可以分别获取相应的实部和虚部的数值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> := <span class="hljs-number">3</span>.<span class="hljs-number">2</span> + <span class="hljs-number">12</span>i<br><span class="hljs-attribute">b</span> := complex(<span class="hljs-number">3</span>.<span class="hljs-number">2</span>, <span class="hljs-number">12</span>)<br><span class="hljs-attribute">v</span> := a + b<br><span class="hljs-attribute">vr</span> := real(v)<br><span class="hljs-attribute">vi</span> := imag(v)<br><br><span class="hljs-attribute">println</span>(v, vr, vi) //(+<span class="hljs-number">6</span>.<span class="hljs-number">400000</span>e+<span class="hljs-number">000</span>+<span class="hljs-number">2</span>.<span class="hljs-number">400000</span>e+<span class="hljs-number">001</span>i) +<span class="hljs-number">6</span>.<span class="hljs-number">400000</span>e+<span class="hljs-number">000</span> +<span class="hljs-number">2</span>.<span class="hljs-number">400000</span>e+<span class="hljs-number">001</span><br></code></pre></td></tr></table></figure><p>复数支持常规数学运算，但是因为实部和虚部都为浮点型，所以运算是需要注意数据精度。cmath中包含了一些操作复数的公共方法，除非是堆内存有严格限制的程序，一般用complex128来声明类型，避免类型转换。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>在go语言中，字符串是一个不可改变的utf-8字符序列<font color="red">（通常操作时返回的是十进制的字符序列值）<a href="#str_range">（根据range字符串得出的结论）</a></font>，一个ASCII码占用1字节，其他字符根据需要占用2~4字节。go默认使用utf-8编码格式进行文件存储，所以可能根据需要因不同字符占用1~4个字节，减少内存使用，解约硬盘空间，减少读取时的编码和解码操作</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> := <span class="hljs-string">&quot;1你wo.X &quot;</span><br>for i := <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; len(<span class="hljs-selector-tag">a</span>); <span class="hljs-selector-tag">i</span>++ &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span>) //返回字符串中第<span class="hljs-selector-tag">i</span>字节的字节值，而非值<br>&#125;<br><span class="hljs-selector-tag">b</span> := <span class="hljs-string">&quot;hello&quot;</span><br>c := b<br>b += <span class="hljs-string">&quot;,world&quot;</span> // hello,world 字符串可以连接，但原字符串不会改变<br>fmt.<span class="hljs-built_in">Println</span>(b)<br>fmt.<span class="hljs-built_in">Println</span>(c) // hello 原字符串没有修改<br></code></pre></td></tr></table></figure><p>go字符串支持解释字符串和非解释字符串两种。</p><p>go 的字符有以下两种：</p><ul><li>uint8类型，或者叫byte型，代表ASCII码的一个字符</li><li>rune型，代表一个utf-8字符，当需要处理中文、日文，或者其它符合字形时，则需要用到rune类型。rune等价于int32类型</li></ul><p>解释字符串：<br>&amp;emsp;&amp;emsp;使用” “扩起来，不支持换行，其中的转义字符将被替换，包括\a（响铃）、\b（退格）、\f（换页）、\t（回车）、制表符、\u（Unicode字符）、\v（垂直制表符）、&#39;（单引号）、&quot;（双引号）、\\（反斜杠）</p><p>非解释字符串：<br>&amp;emsp;&amp;emsp;使用&#96;&#96;扩起来，支持换行。</p><p><font color="red">单个字符可以使用单引号，否则只能使用 “” 或 &#96;&#96;</font></p><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>获取字符串时使用的下标为字节位置(一般汉字为3字节)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> := <span class="hljs-string">&quot;还好好吗&quot;</span><br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[:3]</span>)  <span class="hljs-comment">// 还  取3个字节钱的字符</span><br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[3:]</span>)  <span class="hljs-comment">//好好吗  取3个字节后的字符</span><br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[0:6]</span>) <span class="hljs-comment">//还好  取0-6个字节中的字符</span><br></code></pre></td></tr></table></figure><p>字符间可以使用 + 相连接，也可以使用 &#x3D;&#x3D; 和 &lt; 等符号进行比较，通过比较各个字节的大小获得结果</p><p>字符串可以使用 range 方式进行遍历，遍历后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;新年快乐&quot;</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, v)<br>&#125;<br>fmt.Print(<span class="hljs-string">&quot;\n&quot;</span>) <span class="hljs-comment">// 必须加，不然输出会带有 %</span><br></code></pre></td></tr></table></figure><p>go语言中，字符串不可修改，如需修改字符串中的字节，需要转换为[]byte格式，修改字符需要转换为[]rune格式。</p><p>修改字节范例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> := <span class="hljs-string">&quot;hello 你好&quot;</span><br><span class="hljs-selector-tag">b</span> := <span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(a) <span class="hljs-comment">// 转换为[]byte</span><br><span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[5]</span> = <span class="hljs-string">&#x27;!&#x27;</span><br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, a) <span class="hljs-comment">// hello 你好  原值不便</span><br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, b) <span class="hljs-comment">// hello!你好  修改后的数据</span><br></code></pre></td></tr></table></figure><p>修改字符范例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> := <span class="hljs-string">&quot;hello 你好&quot;</span><br><span class="hljs-selector-tag">b</span> := <span class="hljs-selector-attr">[]</span><span class="hljs-built_in">rune</span>(a) <span class="hljs-comment">// 转换为[]rune</span><br><span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[6]</span> = <span class="hljs-string">&#x27;!&#x27;</span><br>fmt<span class="hljs-selector-class">.Println</span>(a)         <span class="hljs-comment">// hello 你好 原值不便</span><br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-built_in">string</span>(b)) <span class="hljs-comment">// hello !好  修改后的数据</span><br></code></pre></td></tr></table></figure><p>一般的比较运算符通过内存中按字节比较实现字符串的对比，可以通过len（）函数获取字符串所占字节长度，也可以通过标准索引法来获取，在中括号 [] 内写入索引获取字节，但只对纯ASCII码字符串<font color="red">（中文字）</font>有效，<font color="red">且不能获取字符串中字节的地址</font></p><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>Contains 判断字符串是否包含子串， ContainsAny 判断字符串是否包含子串任一字符</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">str := <span class="hljs-string">&quot;this is a example&quot;</span><br>fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;是否包含前缀th %t\n&quot;</span>, strings.<span class="hljs-built_in">HasPrefix</span>(str, <span class="hljs-string">&quot;thi&quot;</span>))<br>fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;是否包含后缀th %t\n&quot;</span>, strings.<span class="hljs-built_in">HasSuffix</span>(str, <span class="hljs-string">&quot;example&quot;</span>))<br>fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;是否包含内容a %t\n&quot;</span>, strings.<span class="hljs-built_in">Contains</span>(str, <span class="hljs-string">&quot;a&quot;</span>))<br>fmt.<span class="hljs-built_in">Printf</span>(<span class="hljs-string">&quot;是否包含任意内容 %t\n&quot;</span>, strings.<span class="hljs-built_in">ContainsAny</span>(str, <span class="hljs-string">&quot;2a&quot;</span>))<br></code></pre></td></tr></table></figure><h4 id="定位字符串"><a href="#定位字符串" class="headerlink" title="定位字符串"></a>定位字符串</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">str := <span class="hljs-string">&quot;this is a example&quot;</span><br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;第一次出现的位置是：%d\n&quot;</span>, strings<span class="hljs-selector-class">.Index</span>(str, <span class="hljs-string">&quot;is&quot;</span>))      <span class="hljs-comment">// 2</span><br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;最后一次出现的位置是：%d\n&quot;</span>, strings<span class="hljs-selector-class">.LastIndex</span>(str, <span class="hljs-string">&quot;is&quot;</span>)) <span class="hljs-comment">// 5</span><br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;第一次出现的位置是：%d\n&quot;</span>, strings<span class="hljs-selector-class">.Index</span>(str, <span class="hljs-string">&quot;z&quot;</span>))       <span class="hljs-comment">// -1 不存在字符时返回-1</span><br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;第一次出现的位置是：%d\n&quot;</span>, strings<span class="hljs-selector-class">.IndexRune</span>(str, <span class="hljs-string">&#x27;啊&#x27;</span>))   <span class="hljs-comment">// 18  ASCII编码的字符串使用 IndexRune 方法获取位置</span><br></code></pre></td></tr></table></figure><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fmt.<span class="hljs-constructor">Println(<span class="hljs-params">strings</span>.Replace(<span class="hljs-params">str</span>, <span class="hljs-string">&quot;啊&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>, 1)</span>) <span class="hljs-comment">// 字符串替换  最后一个参数代表替换几个目标字符，-1代表替换所有目标字符</span><br></code></pre></td></tr></table></figure><h4 id="字符串统计"><a href="#字符串统计" class="headerlink" title="字符串统计"></a>字符串统计</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fmt.<span class="hljs-constructor">Println(<span class="hljs-params">strings</span>.Count(<span class="hljs-params">str</span>, <span class="hljs-string">&quot;啊&quot;</span>)</span>) <span class="hljs-comment">// 字符串统计出现次数</span><br></code></pre></td></tr></table></figure><h4 id="字符串数量统计"><a href="#字符串数量统计" class="headerlink" title="字符串数量统计"></a>字符串数量统计</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-params">len</span>([]<span class="hljs-params">rune</span>(<span class="hljs-params">str</span>)</span>)) <span class="hljs-comment">// 字符串统计数量</span><br>fmt.<span class="hljs-constructor">Println(<span class="hljs-params">utf8</span>.RuneCountInString(<span class="hljs-params">str</span>)</span>) <span class="hljs-comment">// 同样效果，但更推荐</span><br></code></pre></td></tr></table></figure><h4 id="字符串大小写转化"><a href="#字符串大小写转化" class="headerlink" title="字符串大小写转化"></a>字符串大小写转化</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-params">strings</span>.ToLower(<span class="hljs-params">str</span>)</span>) <br>fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-params">strings</span>.ToUpper(<span class="hljs-params">str</span>)</span>) <br></code></pre></td></tr></table></figure><h4 id="字符串修剪"><a href="#字符串修剪" class="headerlink" title="字符串修剪"></a>字符串修剪</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, <span class="hljs-params">strings</span>.Trim(<span class="hljs-params">str</span>, <span class="hljs-string">&quot;this&quot;</span>)</span>) <span class="hljs-comment">// is a example 啊</span><br>fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, <span class="hljs-params">strings</span>.TrimSpace(<span class="hljs-string">&quot;  a aa aa  &quot;</span>)</span>) <span class="hljs-comment">// a aa aa</span><br></code></pre></td></tr></table></figure><h4 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, strings.Split(str, <span class="hljs-string">&quot; &quot;</span>))  <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;this&quot;</span> <span class="hljs-string">&quot;is&quot;</span> <span class="hljs-string">&quot;a&quot;</span> <span class="hljs-string">&quot;example&quot;</span> <span class="hljs-string">&quot;啊&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="字符串插入"><a href="#字符串插入" class="headerlink" title="字符串插入"></a>字符串插入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">strSli := strings.Fields(str) <span class="hljs-comment">// 转化为字符串切片 [this is a example 啊]</span><br>str2 := strings.Join(strSli, <span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment">// this,is,a,example,啊  string 插入指定字符</span><br></code></pre></td></tr></table></figure><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h4><ul><li>%% 字面量</li><li>%b 一个二进制整数，将一个整数格式化为二进制的表达方式</li><li>%c Unicode字符</li><li>%d 十进制数值</li><li>%x 小写的十六进制数值</li><li>%X 大写的十六进制数值</li><li>%U Unicode表示法表示的整形码值，默认是4个数字字符</li><li>%s 输出以原生UTF-8字节表示的字符，如果console不支持UTF-8编码，输出乱码</li><li>%t 以 true 或 false 输出</li><li>%v 使用默认格式输出，或者如果方法存在，则使用类型的string（）方法输出的自定义值</li><li>%T 输出值的类型</li><li>%p 指针</li></ul><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>布尔类型无法被其他类型复制，也不支持类型转换，只有 true 和 false 两个值，不支持使用 0 和 1 表示</p><p>在go中， &amp;&amp; 和 || 是具有快捷性质的运算符，当运算符左边表达式的值已经能够决定整个表达式的值（&amp;&amp;左边的值为false，|| 左边的值为true），右边的表达式将不会被执行，所以当有多个条件判断，复杂的表达式应放在右侧，减少运算</p><h3 id="基本数据类型扩展"><a href="#基本数据类型扩展" class="headerlink" title="基本数据类型扩展"></a>基本数据类型扩展</h3><p>go 语言可以将一种数据类型的变量转换为另一种类型的变量，在做强制类型转换是，需要注意数据长度被截短以及值溢出的问题</p><p>go 语言可以自定义数据类型别名，但是数据类型别名不能和数据类型直接操作，需要进行数据转换</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针是一个变量，其值是另一个变量的值，即存储器位置的直接地址，使用前需要先声明，才能使用它来存储任何变量地址，声明方式为：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> *<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>所有指针的值的数据类型都相同，表示内存地址的十六进制数，使用指针的步骤为：定义一个指针变量，将一个变量的地址赋值给指针，最后访问指针变量中可用地址的值</p><p>go 不支持指针运算，也不支持-&gt;运算符</p><h5 id="nil指针"><a href="#nil指针" class="headerlink" title="nil指针"></a>nil指针</h5><p>go 语言编译器为指针变量分配一个nil值，以防指针没有确切的地址分配，一般是在变量声明的时候完成的。nil指针是在几个标准库中定义的值为0的常量。</p><p>对空指针的反向引用是不合法的，会使程序崩溃</p><p>定义指针的指针：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">var</span> <span class="hljs-keyword">ptr</span> **<span class="hljs-type">int</span>;<br></code></pre></td></tr></table></figure><h5 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h5><p>数组一般有多个值，所以指向数组的指针也有多个值</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">const</span> <span class="hljs-type">MAX</span> <span class="hljs-type">int</span> = <span class="hljs-number">3</span><br><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">ptr</span> [<span class="hljs-type">MAX</span>]*<span class="hljs-type">int</span> // [&lt;<span class="hljs-keyword">nil</span>&gt; &lt;<span class="hljs-keyword">nil</span>&gt; &lt;<span class="hljs-keyword">nil</span>&gt;] 定义指针数组，数组中默认为<span class="hljs-keyword">nil</span><br></code></pre></td></tr></table></figure><h5 id="传递给函数"><a href="#传递给函数" class="headerlink" title="传递给函数"></a>传递给函数</h5><p>go 语言允许传递指针到函数中，只需将函数的参数声明为指针类型</p>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang流程控制</title>
    <link href="/2022/05/31/golang%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/05/31/golang%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>一般一堆大括号中的代码称为一个代码块，比如一个函数，或者一个if语句都是一个代码块，每个代码块内部都可以拥有自己的局部变量</p><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><h5 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> := <span class="hljs-number">9</span><br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> &gt; <span class="hljs-number">10</span> &#123;<br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;a &gt; 10&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> &lt; <span class="hljs-number">8</span> &#123;<br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;a &lt; 8&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;a &gt; 10 且 a &lt; 8&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>if 语句可以有一个子语句，用于初始化局部变量：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">if <span class="hljs-selector-tag">a</span> := <span class="hljs-number">10</span>; <span class="hljs-selector-tag">a</span> &lt; <span class="hljs-number">20</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>子语句只能有一个表达式，且不能再代码块之外调用</p><h5 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h5><p>Switch语句中也支持初始化子语句，写在关键字后，且只能有一句语句。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 范围表达式写法</span><br>size := <span class="hljs-string">&quot;mid&quot;</span><br><span class="hljs-keyword">switch</span> a := <span class="hljs-number">50</span>; &#123;<br><span class="hljs-keyword">case</span> a &gt;= <span class="hljs-number">90</span>:<br>size = <span class="hljs-string">&quot;big&quot;</span><br><span class="hljs-keyword">case</span> a &gt;= <span class="hljs-number">70</span>:<br>size = <span class="hljs-string">&quot;mid&quot;</span><br><span class="hljs-keyword">case</span> a &gt;= <span class="hljs-number">60</span>:<br>size = <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-keyword">default</span>:<br>size = <span class="hljs-string">&quot;suck&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 单值表达式写法</span><br>size := <span class="hljs-string">&quot;mid&quot;</span><br><span class="hljs-keyword">switch</span> a := <span class="hljs-number">50</span>; a&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">90</span>:<br>size = <span class="hljs-string">&quot;big&quot;</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">70</span>:<br>size = <span class="hljs-string">&quot;mid&quot;</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">60</span>:<br>size = <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-keyword">default</span>:<br>size = <span class="hljs-string">&quot;suck&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Switch语句的case可以拥有多个表达式，如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">case</span> <span class="hljs-keyword">a</span> &gt;= <span class="hljs-number">90</span>, <span class="hljs-keyword">a</span> &gt;= <span class="hljs-number">120</span>:<br>size = <span class="hljs-string">&quot;ok&quot;</span><br></code></pre></td></tr></table></figure><p>代表只要有其中一个条件满足，就执行后面的代码</p><h5 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h5><p>golang 中的选择语句，除了Switch语句，还有select，一般配合通道（channel）的读写操作，用于多个channel的读写操作。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> := <span class="hljs-built_in">make</span>(chan int, <span class="hljs-number">1024</span>)<br>b := <span class="hljs-built_in">make</span>(chan int, <span class="hljs-number">1024</span>)<br><br>for i := <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; <span class="hljs-number">10</span>; <span class="hljs-selector-tag">i</span>++ &#123;<br>fmt<span class="hljs-selector-class">.Printf</span>(&quot;第%d次&quot;, <span class="hljs-selector-tag">i</span>)<br><span class="hljs-selector-tag">a</span> &lt;- <span class="hljs-number">1</span><br><span class="hljs-selector-tag">b</span> &lt;- <span class="hljs-number">1</span><br><br>select &#123;<br>case &lt;-<span class="hljs-selector-tag">a</span>:<br>fmt.<span class="hljs-built_in">Println</span>(<span class="hljs-string">&quot;from a&quot;</span>)<br>case &lt;-b:<br>fmt.<span class="hljs-built_in">Println</span>(<span class="hljs-string">&quot;from b&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><font color="red">这块没搞懂<p>上述代码意思是，同时在a和b中选择，哪个有内容就从哪个读，由于channel的读写操作是阻塞操作，使用select语句可以避免单个channel的阻塞。此外select同样可以使用default代码块，用于避免所有channel同时阻塞，具体见并发编程。<br></font></p><h5 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h5><p>go 语言中没有 while 关键字，for 语句根据指定的条件重复执行内部代码块，由for后面的子语句判定</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">for <span class="hljs-selector-tag">i</span> := <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; <span class="hljs-number">10</span>; <span class="hljs-selector-tag">i</span>++ &#123;<br>fmt<span class="hljs-selector-class">.Printf</span>(&quot;第%d次&quot;, <span class="hljs-selector-tag">i</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>for 语句后面的三个子语句分别称为：初始化子语句，条件子语句，后置子语句。顺序不可颠倒，条件子语句必需，条件成立则执行代码块，反之退出循环，下面是一个省略了初始化子语句和后置子语句的for循环。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> := <span class="hljs-number">0</span><br><span class="hljs-selector-tag">b</span> := <span class="hljs-number">5</span><br><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">a</span> &lt; <span class="hljs-selector-tag">b</span> &#123;<br>a++<br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;a 为%d\n&quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子中，for后面只有一个a &lt; b 的判断语句，实际上等于</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">for ; <span class="hljs-selector-tag">a</span> &lt; <span class="hljs-selector-tag">b</span>;<br></code></pre></td></tr></table></figure><p>省略了 a :&#x3D; 0 和 a++ 初始化子语句和后置子语句。</p><h5 id="range-子语句"><a href="#range-子语句" class="headerlink" title="range 子语句"></a>range 子语句</h5><p>每一个for语句都可以使用一个特殊的 range 子语句，起作用相当于迭代器（相当于php 的 foreach），轮训数组或者切片值华中的每一个元素，也可以轮询字符串的每一个字符，以及字典（数组）值中的每个键值对，甚至还可以持续读取一个通道类型值中的元素，例：<span id="str_range"></span></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-type">str</span> := <span class="hljs-string">&quot;abcd&quot;</span><br><span class="hljs-keyword">for</span> <span class="hljs-title class_">i</span>, <span class="hljs-type">char</span> := range <span class="hljs-type">str</span> &#123;<br>fmt.<span class="hljs-title function_ invoke__">Printf</span>(<span class="hljs-string">&quot;字符串第%d个字符的值为%d\n&quot;</span>, i, <span class="hljs-type">char</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-title class_">_</span>, <span class="hljs-type">char</span> := range <span class="hljs-type">str</span> &#123; <span class="hljs-comment">// 忽略 index，返回的是utf-8的10进制字符序列值</span><br>fmt.<span class="hljs-title function_ invoke__">Printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, <span class="hljs-type">char</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-title class_">i</span> := range <span class="hljs-type">str</span> &#123;<br><span class="hljs-title function_ invoke__">println</span>(i) <span class="hljs-comment">// 返回index</span><br>&#125;<br><span class="hljs-comment">/*返回：</span><br><span class="hljs-comment">字符串第0个字符的值为97</span><br><span class="hljs-comment">字符串第1个字符的值为98</span><br><span class="hljs-comment">字符串第2个字符的值为99</span><br><span class="hljs-comment">字符串第3个字符的值为100</span><br><span class="hljs-comment">a</span><br><span class="hljs-comment">b</span><br><span class="hljs-comment">c</span><br><span class="hljs-comment">d</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3*/</span><br></code></pre></td></tr></table></figure><p>range 关键字左边表示的是一对索引-值对，根据不同的表达式返回不同的结果：</p><table><thead><tr><th>右边表达式返回的类型</th><th>第一个值</th><th>第二个值</th></tr></thead><tbody><tr><td>string</td><td>index</td><td>str[index]，返回类型为rune</td></tr><tr><td>array|slice</td><td>index</td><td>str[index]</td></tr><tr><td>map</td><td>key</td><td>m[key]</td></tr><tr><td>channel</td><td>element</td><td></td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br><span class="hljs-built_in">println</span>(k, v) <span class="hljs-comment">// 返回（key，value）</span><br>&#125;<br><br>a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> a &#123;<br>fmt.Printf(<span class="hljs-string">&quot;第%d次，值为%d\n&quot;</span>, k, v)<br>&#125;<br><span class="hljs-comment">/*返回：</span><br><span class="hljs-comment">a 1</span><br><span class="hljs-comment">b 2</span><br><span class="hljs-comment">第0次，值为1</span><br><span class="hljs-comment">第1次，值为2</span><br><span class="hljs-comment">第2次，值为3</span><br><span class="hljs-comment">第3次，值为4*/</span><br></code></pre></td></tr></table></figure><p>返回的第一个值为索引（键值），有时候并用不到键值，所以可以用 _ 来代替表示忽略第一个返回值，对于空字典或切片、空数组、空字符串等情况，for语句会直接结束。<br>如果需要指定for循环的次数，比如数组中有一个值是空字符串，则可以指定数组长度（或者其它支持类型）长度，强制让for循环相应次数，（暂未找到其它支持的类型）如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">a := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> a &#123;<br>fmt.Printf(<span class="hljs-string">&quot;第%d次，值为%d\n&quot;</span>, k, v)<br>&#125;<br><span class="hljs-comment">/*返回：</span><br><span class="hljs-comment">第0次，值为1</span><br><span class="hljs-comment">第1次，值为2</span><br><span class="hljs-comment">第2次，值为3</span><br><span class="hljs-comment">第3次，值为4</span><br><span class="hljs-comment">第4次，值为0*/</span><br></code></pre></td></tr></table></figure><p>由于定义了数组长度为5，但a中只有4个值，因此最后一个为空值，但代码循环了5次。</p><h5 id="延迟语句"><a href="#延迟语句" class="headerlink" title="延迟语句"></a>延迟语句</h5><p>除了以上的流程控制语句，还有一些特殊的流程控制语句———— defer。defer用于延迟调用指定函数，且只能出现在函数内部</p><p>defer 后面的表达式必须是外部函数的调用，defer 函数有两大特点：</p><ul><li>只有当defer语句全部执行，defer所在函数才算真正的结束执行</li><li>当函数中有defer 语句时，需要等待所有defer 语句执行完毕，才会执行return语句</li></ul><p>因为defer的延迟特点，可以吧defer语句用户回收资源、清理收尾等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">func print(<span class="hljs-selector-tag">i</span> int) &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">i</span>)<br>&#125;<br>func <span class="hljs-selector-tag">main</span>() &#123;<br>    for <span class="hljs-selector-tag">i</span> := <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; <span class="hljs-number">5</span>; <span class="hljs-selector-tag">i</span>++ &#123;<br>defer print(<span class="hljs-selector-tag">i</span>)<br>&#125;<br>&#125;<br><span class="hljs-comment">/*4</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">0*/</span><br></code></pre></td></tr></table></figure><p>上面例子之所以是一个反序的数列，是因为defer是一个栈，遵循先入后出，或者理解为后进先出。<br>简单来说，就是当一个函数内部有多个defer语句时，最后面的defer语句最先执行</p><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><p>go语言有一个特殊的概念就是标签，可以给for、swith或select等流程控制代码块打上一个标签，配合标签标识符可以方便跳转到某一个地方继续执行，有助于提高编程效率</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">L1:</span><br>switch <span class="hljs-title class_">i</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-comment">// 代码块</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>标签名区分大小写，建议使用大写字母和数字。标签可以标记任何语句，并不限定流程控制语句，未使用的标签会引发错误。</p><h5 id="break"><a href="#break" class="headerlink" title="break"></a>break</h5><p>break 的用法与PHP并无差别，但当遇见嵌套的流程控制语句，标签就用上了。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">L1:<br><span class="hljs-keyword">for</span> &#123;<br>x := <span class="hljs-number">1</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> x &gt; <span class="hljs-number">0</span>:<br>fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;yes&quot;</span>)<br><span class="hljs-keyword">break</span> L1<br><span class="hljs-keyword">case</span> x &lt; <span class="hljs-number">0</span>:<br>fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;no&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码 break L1 表示调出到标签 L1的代码块之外</p><h5 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h5><p>与break相反，continue用于跳转到指定代码块位置继续执行，continue 只能用于for循环。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css">L1:<br>for i := <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; <span class="hljs-number">5</span>; <span class="hljs-selector-tag">i</span>++ &#123;<br>switch &#123;<br>case <span class="hljs-selector-tag">i</span> &gt; <span class="hljs-number">0</span>:<br>fmt.<span class="hljs-built_in">Println</span>(<span class="hljs-string">&quot;yes&quot;</span>)<br>continue L1<br>case i &lt; <span class="hljs-number">0</span>:<br>fmt.<span class="hljs-built_in">Println</span>(<span class="hljs-string">&quot;no&quot;</span>)<br>default:<br>fmt.<span class="hljs-built_in">Println</span>(<span class="hljs-string">&quot;emmmmmm&quot;</span>)<br>&#125;<br>fmt<span class="hljs-selector-class">.Printf</span>(&quot;<span class="hljs-selector-tag">i</span> is %d\n&quot;, <span class="hljs-selector-tag">i</span>)<br>&#125;<br><br><span class="hljs-comment">/*emmmmmm</span><br><span class="hljs-comment">i is 0</span><br><span class="hljs-comment">yes</span><br><span class="hljs-comment">yes</span><br><span class="hljs-comment">yes</span><br><span class="hljs-comment">yes*/</span><br></code></pre></td></tr></table></figure><p>上面语句因为使用了continue跳转到了外围for循环，导致后面的printf没有执行。</p><h5 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h5><p>goto语句可以无条件跳转到相同函数中的带标签语句，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">i</span> int<br>for &#123;<br>println(<span class="hljs-selector-tag">i</span>)<br><span class="hljs-selector-tag">i</span>++<br>if <span class="hljs-selector-tag">i</span> &gt; <span class="hljs-number">2</span> &#123;<br>goto BREAK<br>&#125;<br>&#125;<br><br>BREAK:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;break&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">/*0</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">break*/</span><br></code></pre></td></tr></table></figure><p>上面代码中，goto语句指向了BREAK标签，所以当循环中i&gt;2时，直接跳转标签代码块。goto只能在同一个代码块中跳转。</p>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang方法</title>
    <link href="/2022/05/31/golang%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/31/golang%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在GO语言中，GO方法是作用在接受者（receiver）上的一个函数，接受者是某种类型的变量。所以在GO语言里方法是一种特殊类型的函数。<br>接受者几乎可以是任意类型（接口、指针除外），包括结构体类型，函数类型，可以是int、bool、string或者数组别名类型。接受者不能是一个接口类型，因为接口是一个抽象定义，但是方法必须是具体的实现。<br>接受者也不能是一个指针类型，但需要注意的是它可以是允许其他任何允许类型的指针。<br>一个类型加上它的方法就像面向对象的一个类，不同的是，在GO语言中，类型的代码和它相关的方法代码可以存在于不同的源文件中，当然它们必须在同一个包中。</p><h6 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h6><p>方法是函数，所以不允许方法重载，对于一个类型只能有一个给定名称的方法。但如果基于接受者类型，则允许重载，具有同样名字的方法可以在多个不同的接受者类型上存在，比如在同一个包中这样做是允许的：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *denseMatrix)</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(b Matrix)</span>  <span class="hljs-title function_">Matrix</span>&#123;&#125;<br><span class="hljs-keyword">func</span> <span class="hljs-params">(a *sparseMatrix)</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(b Matrix)</span> <span class="hljs-title function_">Matrix</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>方法的声明</p></blockquote><p>定义方法的一般格式如下：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">func</span> (recv receiver_type) methodName(parameter_list) (reture_value_list) <span class="hljs-meta">&#123;...&#125;</span><br><span class="hljs-keyword">func</span> (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为p，Connector类型的接收者变量应该命名为c等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同<br>在方法名之前，func关键字之后的括号中指定接收者。<br>如果recv是接收者的一个实例，Method1是接收者类型的一个方法名，那么方法调用遵循传统的选择器符号：recv.Method1()。<br>如果recv是一个指针，GO语言会自动解析该引用值，如果调用的方法不需要使用recv的值，可以用<code>_</code>符号替换它，如：<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">func</span> (_ receiver_type) methodName(parameter_list) (reture_value_list) <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure>recv 与面向对象语言中的this和self等类似，但是recv并不是一个关键字，GO语言中也没有this和self关键字，所以也可以使用this和self作为接受者的实例化名字。下面是一个结构体上的简单方法的例子：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TwoInts <span class="hljs-keyword">struct</span> &#123;<br>a, b <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tn *TwoInts)</span></span> addThem() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> tn.a + tn.b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tn *TwoInts)</span></span> addWithParam(param <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> tn.a + tn.b + param<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>two1 := <span class="hljs-built_in">new</span>(TwoInts)<br>two1.a = <span class="hljs-number">1</span><br>two1.b = <span class="hljs-number">2</span><br>fmt.Printf(<span class="hljs-string">&quot;plus is : %d\n&quot;</span>, two1.addThem()) <span class="hljs-comment">// plus is : 3</span><br>fmt.Printf(<span class="hljs-string">&quot;plus with param is : %d\n&quot;</span>, two1.addWithParam(<span class="hljs-number">20</span>)) <span class="hljs-comment">// plus with param is : 23</span><br>&#125;<br></code></pre></td></tr></table></figure>下面是非结构体类型方法的例子：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntVector []<span class="hljs-type">int</span> <span class="hljs-comment">// 空切片</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v IntVector)</span></span> Sum() (s <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> v &#123;<br>s += x<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := IntVector&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(a.Sum()) <span class="hljs-comment">// 15</span><br>&#125;<br></code></pre></td></tr></table></figure>类型与在它上面定义的方法必须在同一个包里定义，像int、float或类似的类型属于GO语言的基本类型，开发者无法在基本类型上定义方法，除非修改GO语言的源代码。<br>比如在time.Time上定义如下方法：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">func (t time.Time) <span class="hljs-built_in">first3Chars</span>() string &#123;<br>return <span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.LocalTime</span>()<span class="hljs-selector-class">.String</span>()<span class="hljs-selector-attr">[0:3]</span><br>&#125;<br></code></pre></td></tr></table></figure>如果类型在非本地包定义，在非本地包上面定义的方法都会得到以下错误：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">cannot define <span class="hljs-built_in">new</span> methods <span class="hljs-keyword">on</span> non-<span class="hljs-keyword">local</span> <span class="hljs-keyword">type</span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure>不过别名类型并不受这个规则限制，可以把非本地包定义的类型指定一个别名，然后在别名类型上定义方法，或者像下面这样将它作为匿名类型嵌入在一个新的结构体中。这种方式定义的方法只在这个别名类型上有效：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type nowTime struct &#123;<br><span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Time</span><br>&#125;<br><br>func (t nowTime) <span class="hljs-built_in">first3Chars</span>() string &#123;<br>return t<span class="hljs-selector-class">.Time</span><span class="hljs-selector-class">.String</span>()<span class="hljs-selector-attr">[0:19]</span><br>&#125;<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br>now := nowTime&#123;<span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Now</span>()&#125;<br>fmt<span class="hljs-selector-class">.Println</span>(now<span class="hljs-selector-class">.String</span>())               <span class="hljs-comment">// 2022-05-17 17:08:12.10256 +0800 CST m=+0.000111592</span><br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;标准格式：&quot;</span>, now<span class="hljs-selector-class">.first3Chars</span>()) <span class="hljs-comment">// 标准格式： 2022-05-17 17:08:12</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>函数与方法的区别</p></blockquote><p>函数将变量作为参数：Function1(recv)；方法在变量上被调用：recv.Method1()。<br>当接收者是指针时，方法可以改变接收者的值或状态。这一点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。<br>接收者必须有一个显式的名字，这个名字必须在方法中被调用。receiver_type叫做“接收者类型”，这个类型必须在和方法同样的包中被声明。<br>在GO语言中，“接收者类型”对应的方法不应该写在类型结构中，就像面向对象语言的类一样，降低耦合性，类型和方法之间的关联由接收者来建立。</p><h6 id="为类型添加方法"><a href="#为类型添加方法" class="headerlink" title="为类型添加方法"></a>为类型添加方法</h6><p>GO语言的大多数类型都是值语义，并且都包含对应的操作方法。在需要的时候，可以给任何类型（包括内置类型）“增加”新方法，而实现某个接口时，无序从该接口继承（因为GO语言不支持面向对象思想中的继承语法），只需要实现该接口要求的所有方法既可。任何类型都可以被Any类型引用，Any类型就是空接口，即interface{}。例如</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">type</span> <span class="hljs-type">Integer</span> <span class="hljs-type">int</span><br>func (i <span class="hljs-type">Integer</span>) less(b <span class="hljs-type">Integer</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> a &lt; b<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类型中，定义了一个新类型Integer，它和int没有本质上的不同，只是为内置的int类型增加了一个新方法Less()。这样实现了Integer后，就可以让整形像一个普通的类一样使用：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> Integer = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.less</span>(<span class="hljs-number">3</span>) &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">a</span>, <span class="hljs-string">&quot;less than 3&quot;</span>) <span class="hljs-comment">// 1 less than 3</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个Integer例子如果不使用GO语言的面向对象特性，而是用之前所说的面向过程方式实现，具体实现如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">IntegerLess</span>(<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> Integer) bool &#123;<br>return <span class="hljs-selector-tag">a</span> &lt; <span class="hljs-selector-tag">b</span><br>&#125;<br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> Integer = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">IntegerLess</span>(<span class="hljs-selector-tag">a</span>, <span class="hljs-number">5</span>) &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a is less than b&quot;</span>) <span class="hljs-comment">// a is less than b</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比两段代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func (<span class="hljs-selector-tag">i</span> Integer) <span class="hljs-built_in">less</span>(<span class="hljs-selector-tag">b</span> Integer) bool &#123; <span class="hljs-comment">// 面向对象</span><br>return <span class="hljs-selector-tag">i</span> &lt; <span class="hljs-selector-tag">b</span><br>&#125;<br><br>func <span class="hljs-built_in">IntegerLess</span>(<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> Integer) bool &#123; <span class="hljs-comment">// 面向过程</span><br>return <span class="hljs-selector-tag">a</span> &lt; <span class="hljs-selector-tag">b</span><br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.less</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 面向对象的用法</span><br><span class="hljs-function"><span class="hljs-title">IntegerLess</span><span class="hljs-params">(a, <span class="hljs-number">2</span>)</span></span> <span class="hljs-comment">// 面向过程的用法</span><br></code></pre></td></tr></table></figure><p>可以看出，面向对象只是用了另一种语法形式来表达。GO语言中的面向对象最为直观，也无需支付额外的成本。如果要求对象必须以指针传递，有时会有额外成本，因为对象有时很小（比如4B），用指针传递兵不划算，只需要在修改对象的时候，才必须用指针。</p><h6 id="工厂方式创建结构体"><a href="#工厂方式创建结构体" class="headerlink" title="工厂方式创建结构体"></a>工厂方式创建结构体</h6><p>在面向对象编程中，可以通过构造字方法实现工厂模式（一般是new Object等），但是在GO语言中不能这样构造子方法，而是提供了其它的方案。以结构体为例，通常会为结构体类型定义一个工厂，按惯例，工厂的名字以new或New开头，假设定义了如下的File结构体类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> File <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 不强制使用构造函数，首字母大写</span><br>fd <span class="hljs-type">int</span> <span class="hljs-comment">// 文件描述符</span><br>name <span class="hljs-type">string</span> <span class="hljs-comment">// 文件名</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFile</span><span class="hljs-params">(fd <span class="hljs-type">int</span>, name <span class="hljs-type">string</span>)</span></span> *File  &#123; <span class="hljs-comment">// File结构体对应的工厂方法，返回一个指向结构体实例的指针</span><br><span class="hljs-keyword">if</span> fd &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;File&#123;fd, name&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后可以这么调用它：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f</span> := NewFile(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;./test.txt&quot;</span>)<br></code></pre></td></tr></table></figure><p>在GO语言中尝尝像上面这样在工厂方法里使用初始化来简便的实现构造函数。<br>如果File是一个机构提类型，表达式new(File)和&amp;File{}是等价的，这可以和大多数面向对象编程语言中笨拙的初始化方式做个比较：File f &#x3D; new File(…)。<br>可以说工厂实例化了类型的一个对象，就像在基于类的面向对象语言中哪那样。如果想知道结构体类型T的一个实例占用了多少内存，可以使用：size :&#x3D; unsafe.Sizeof(T{})。<br>强制使用工厂方法，通过应用可见性规则就可以禁止使用new函数，强制用户使用工厂方法，从而使类型变成私有的，就像在面向对象语言中那样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> file <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 强制使用构造函数，首字母小写</span><br>fd   <span class="hljs-type">int</span>    <span class="hljs-comment">// 文件描述符</span><br>name <span class="hljs-type">string</span> <span class="hljs-comment">// 文件名</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFile</span><span class="hljs-params">(fd <span class="hljs-type">int</span>, name <span class="hljs-type">string</span>)</span></span> *file &#123;<br><span class="hljs-keyword">if</span> fd &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;file&#123;fd, name&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，在其他包使用工厂方法是不能通过new的方式私建，因为file类型是私有的，实例化该结构体的唯一方式只能通过NewFile来实现。</p><h6 id="基于指针对象的方法"><a href="#基于指针对象的方法" class="headerlink" title="基于指针对象的方法"></a>基于指针对象的方法</h6><p>现在知道了GO语言不支持类似其他面向对象语言的那种传统类，相反，GO语言使用结构体替代，由于GO语言支持在结构体类型上定义方法，所以这一点非常类似其他面向对象语言中的传统类方法。<br>在结构体类型上可以定义两种方法，分别基于指针接收器和基于值接收器，显然，从之前的内容可以知道，值接收器代表复制整个值到内存中，内存开销大，而基于指针的接收器只需要一个指针大小的内存。<br>因此，性能决定了指针接收器的方式更适合我们使用。recv最常见的是一个指向receiver_type的指针（因为不需要复制整个实例，但如果按值调用就会复制整个实例），特别是在接收者类型是结构体时，性能优势就更明显了。<br>如果想要方法改变接收器的数据，就在接收器的指针类型上定义该方法，否在就在普通的值类型上定义方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HttpResponse <span class="hljs-keyword">struct</span> &#123;<br>statusCode <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *HttpResponse)</span></span> validResponse() &#123;<br>r.statusCode = <span class="hljs-number">200</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r HttpResponse)</span></span> updateStatus() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprint(r)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> r1 HttpResponse <span class="hljs-comment">// 值类型</span><br>r1.validResponse()<br>fmt.Println(r1.updateStatus()) <span class="hljs-comment">// 200</span><br><br>r2 := <span class="hljs-built_in">new</span>(HttpResponse) <span class="hljs-comment">// 指针类型(new函数返回指向类型的指针)</span><br>r2.validResponse()<br>fmt.Println(r1.updateStatus()) <span class="hljs-comment">// 200</span><br>&#125;<br></code></pre></td></tr></table></figure><p>validResponse()接收一个指向 HttpResponse 的指针，并且改变其内部成员；updateStatus()复制 HttpResponse 的值并只输出 HttpResponse 的内容，r1输出值，r2输入指针。<br>然后，在 updateStatus() 中改变接收者 r 的值，将会看到它可以正常编译，但是开始的 r 值没有改变，因为指针作为接收者不是必须的。如下例所示，Point 的值仅仅用于计算：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type Point struct&#123; x, y, z float64 &#125;<br><br>func (<span class="hljs-selector-tag">p</span> Point) <span class="hljs-built_in">abs</span>() float64 &#123;<br>return math<span class="hljs-selector-class">.Sqrt</span>(<span class="hljs-selector-tag">p</span>.x*<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.x</span> + <span class="hljs-selector-tag">p</span>.y*<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.y</span> + <span class="hljs-selector-tag">p</span>.z*<span class="hljs-selector-tag">p</span>.z)<br>&#125;<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">p</span> := &amp;Point&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125; <span class="hljs-comment">// 定义为指针减少内存占用</span><br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.abs</span>()) <span class="hljs-comment">// 7.0710678118654755</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在后续代码中，都可以使用p.abs()来替代之前的(*p).abs()这种写法</p><h6 id="方法值和方法表达式"><a href="#方法值和方法表达式" class="headerlink" title="方法值和方法表达式"></a>方法值和方法表达式</h6><p><font color="red">这块没搞懂，详见书的191页</font><br>我们有时会在一个表达式中执行一个甚至多个方法，比如常见的p.Distance()形式，实际上还可以将其分成两部来执行，其中p.Distance中的小数点叫做“选择器”，选择器会返回它前面那个方法（或变量）的“值”并传递给后面的那个方法（Point.Distance），其中Distance一定是一个绑定到特定接收器变量的函数，这个函数可以不通过指定其接收器既可被调用，调用时不需要指定接收器，只需要传入函数的参数既可：</p><p>非接口方法，不管接收器的类型是指针类型还是值类型，值对象和指针对象都可以调用</p><h6 id="方法和未导出字段"><a href="#方法和未导出字段" class="headerlink" title="方法和未导出字段"></a>方法和未导出字段</h6><p>当类型被明确导出时（首字母大写可被外部包调用），它的字段并没有被导出，例如p.firstName就无法被外界调用，想在另一个程序中修改护着读取可以通过面向对象语言中一个众所周知的方式来完成：提供getter和setter方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>firstName <span class="hljs-type">string</span><br>LastName  <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> FirstName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> p.firstName<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> SetFirstName() (newName <span class="hljs-type">string</span>) &#123;<br>p.firstName = newName<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码设置了firstName的getter和setter方法，如果需要改变Person类型中的字段的值，需要在外部调用Setter方法，下面是main.go的代码，展示如何改变未导出的字段的值：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang_test/person&quot;</span><br>)<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">p</span> := <span class="hljs-built_in">new</span>(person.Person)<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.LastName</span> = <span class="hljs-string">&quot;wick&quot;</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.SetFirstName</span>(<span class="hljs-string">&quot;john&quot;</span>)<br>name := <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.FirstName</span>()<br>fmt<span class="hljs-selector-class">.Println</span>(p)    <span class="hljs-comment">// &amp;&#123;john wick&#125;</span><br>fmt<span class="hljs-selector-class">.Println</span>(name) <span class="hljs-comment">// john</span><br>&#125;<br></code></pre></td></tr></table></figure><p>应该避免多个线程同时操作对象的字段的值，这会导致线程之间产生竞争并极有可能返回无法预料的结果（无法得知那个线程最后操作了该字段的值）。如果程序执行时发生这种情况，为了安全并发访问，可以使用GO语言官方提供的sync标准库中的方法。在后面章节会通过goroutines和channels探索并发访问对象的方式。</p><h6 id="嵌入类型的方法和继承"><a href="#嵌入类型的方法和继承" class="headerlink" title="嵌入类型的方法和继承"></a>嵌入类型的方法和继承</h6><blockquote><p>嵌入类型的方法</p></blockquote><p>GO语言并不是一门传统意义上的面向对象编程语言（Java，PHP等），所以GO语言无法在语言层面上实现累得继承和亚类的实现，但由于GO语言提供了创建匿名结构体的方法，所以可以发匿名结构体嵌入具名结构体内部，这样具名结构体也会拥有其内部匿名结构体的那些方法，在效果上等于面向对象变成中的类的继承。这与Python，Ruby等语言的混入（mixin）相似。<br>下面是一个完整例子，它展示了内嵌结构体上的方法可以直接在外层类型的实例上调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>x, y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(p.x*p.x + p.y*p.y)<br>&#125;<br><br><span class="hljs-keyword">type</span> NamedPoint <span class="hljs-keyword">struct</span> &#123;<br>Point<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := &amp;NamedPoint&#123;Point&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, <span class="hljs-string">&quot;test&quot;</span>&#125;<br>fmt.Println(n.Abs()) <span class="hljs-comment">// 5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将一个已存在类型的字段和方法注入另一个类型即为内嵌，匿名字段上的方法“晋升”为了外层类型的方法。当然类型可以有只作用于本身实例而不作用于内嵌“父”类型的方法，可以覆写字段（像字段一样）。<br>和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法，如下例：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *NamedPoint)</span> <span class="hljs-title function_">Abs</span><span class="hljs-params">()</span> <span class="hljs-title function_">float64</span> &#123;<br><span class="hljs-keyword">return</span> n.Point.<span class="hljs-built_in">Abs</span>() * <span class="hljs-number">100</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在fmt.PrintLn(n.Abs())会输出500。<br>因为一个结构体可以嵌入多个匿名类型，所以时间上可以有一个简单版本的多重继承，就像：type Child struct {Mother, Father}。在多重继承中会进一步进行讲解。<br>结构体内嵌和自己在同一个包中的结构体时，可以访问对方所有的字段和方法。</p><blockquote><p>多重继承</p></blockquote><p>多重继承在生活中很常见，比如孩子继承父母，父母是两个父级类，在大部分面向对象语言中，是不允许有多重继承的，因为这样会导致编译器变得复杂，不过由于GO语言没有类的概念，所以继承其实是内嵌结构体，通过在类型中嵌入所有必须的父类型，可以很简单的实现多重继承。GO语言的多重继承不支持多重嵌套（即父级类型内部不允许有匿名结构体字段）。<br>以下是一个例子，假设有一个类型CameraPhone，通过它可以调用Call()函数，也可以调用TakePicture()函数，但是第一个方法属于类型Phone，第二个属于类型Camera，只要嵌入这两个类型就可以解决这个问题，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Camera <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Camera)</span></span> TakePicture() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;take picture&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Phone <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Phone)</span></span> Call() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;calling&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> CameraPhone <span class="hljs-keyword">struct</span> &#123;<br>Camera<br>Phone<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>cp := <span class="hljs-built_in">new</span>(CameraPhone)<br>fmt.Println(cp.Call())        <span class="hljs-comment">// calling</span><br>fmt.Println(cp.TakePicture()) <span class="hljs-comment">// take picture</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang的channel</title>
    <link href="/2022/05/31/golang%E7%9A%84channel/"/>
    <url>/2022/05/31/golang%E7%9A%84channel/</url>
    
    <content type="html"><![CDATA[<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>channel是Go语言在语言级别提供的goroutine间的通讯方式，可以使用channel在两个或者多个goroutine之间传递消息。channel是进程内的通信方式，因此通过channel传递对象的过程和调用函数时的参数传递行为比较一致。</p><p>GO语言采用的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<font color="red">通过通信共享内存</font>而不是<font color="red">通过共享内存来实现通信</font></p><p>channel是类型相关的，一个channel只能传递一种类型的值，通过声明channel时指定。channel类似于队列，遵循先入先出的规则，保证收法数据的顺序。</p><h5 id="声明channel"><a href="#声明channel" class="headerlink" title="声明channel"></a>声明channel</h5><p>channel是GO语言独有的一种类型，声明方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 变量名称 <span class="hljs-keyword">chan</span> 元素类型<br></code></pre></td></tr></table></figure><p>又或者声明一个map，元素是bool型的channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p>未初始化的channel通道类型变量默认为nil，声明后的channel需要是用内置的<code>make</code>函数初始化才能使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, 缓冲大小)<br></code></pre></td></tr></table></figure><p>其中缓冲大小可选。<br>以上初始化了一个int型的名为 ch 的channel，在channel的用法中，最常见的包括写入和读出，将数据写入至channel的语法很直观：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ch</span> &lt;- <span class="hljs-number">10</span> // 把<span class="hljs-number">10</span>发送到ch中<br></code></pre></td></tr></table></figure><p>向channel写入数据通常会导致程序阻塞，直到有其他goroutine从这个channel中读取数据。读取数据的语法为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">x := &lt;- ch <span class="hljs-regexp">//</span> 从ch中接收值并赋值给变量x<br>&lt;-ch       <span class="hljs-regexp">//</span> 从ch中接收值，忽略结果<br></code></pre></td></tr></table></figure><p>如果channel之前没有写入数据，那么从channel中读取数据也会导致程序阻塞，直到channel中被写入数据为止。<br>channel可以通过内置的<code>close</code>函数来进行关闭</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">close</span><span class="hljs-params">(ch)</span></span><br></code></pre></td></tr></table></figure><p><font color="red">注意</font>：一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。<br>关闭后的通道有以下特点：</p><ul><li>对一个关闭的通道再发送值就会导致 panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致 panic。</li></ul><h5 id="缓冲机制"><a href="#缓冲机制" class="headerlink" title="缓冲机制"></a>缓冲机制</h5><h6 id="无缓冲的channel"><a href="#无缓冲的channel" class="headerlink" title="无缓冲的channel"></a>无缓冲的channel</h6><p>之前示范创建的都是基本不带缓冲的channel，对于传递单个数据的场景可以接受，但是也有可能造成死锁，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码可以编译成功，但是执行时会出现错误</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fatal error: <span class="hljs-attribute">all</span> goroutines are asleep - deadlock!<br><br>goroutine <span class="hljs-number">1</span> <span class="hljs-selector-attr">[chan send]</span>:<br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.main</span>()<br>        .../<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.go</span>:<span class="hljs-number">8</span> +<span class="hljs-number">0</span>x54<br></code></pre></td></tr></table></figure><p><code>deadlock</code>表示我们的程序出现了死锁，会出现这种情况的原因是因为：<br>我们创立的是无缓冲的channel，无缓冲的channel只要在接收方可以接受值的时候才能发送成功，否则一直会在等待发送的状态。同理，一个无缓冲channel在执行接受操作的时候，没有任何向通道中发送值的操作也会导致channel阻塞。</p><p>上面的代码会在<code>ch &lt;- 10</code>这一行造成死锁，如何去解决呢？有一种可行的方式是创建一个goroutine去接受值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recv</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>ret := &lt;-c<br>fmt.Println(<span class="hljs-string">&quot;接收成功&quot;</span>, ret)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> recv(ch) <span class="hljs-comment">// 创建一个 goroutine 从通道接收值</span><br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先无缓冲channel<code>ch</code>的发送操作会阻塞，直到goroutine在该channel中执行接受操作，这时数据才能发送成功，两个goroutine将会继续执行。相反，如果接受方先操作，接受方的goroutine将会阻塞，直到main中的goroutine执行发送操作。<br>使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h6 id="有缓冲的channel"><a href="#有缓冲的channel" class="headerlink" title="有缓冲的channel"></a>有缓冲的channel</h6><p>还有一种解决上面死锁的方法，就是建立有缓冲的channel。我们可以在使用make函数初始化channel时，为其指定channel的容量，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>只要channel的容量大于0，那它就属于有缓冲的channel，channel的容量代表最大能存放的元素数量。当channel中已有元素数量达到最大容量时，再往channel中执行发送操作就会造成阻塞，除非有channel在外执行接受操作，就好比，小区快递柜中只有固定数量储物柜，装满了没有人取，就造成了阻塞，直到有人取走快递才能存放下一个。</p><h6 id="多返回值模式"><a href="#多返回值模式" class="headerlink" title="多返回值模式"></a>多返回值模式</h6><p>当向通道发送完数据后，我们可以通过<code>close</code>函数来关闭channel。当channel被关闭时，再往里发送数据会造成<code>panic</code>，从该通道取值的操作会先取完通道中的值。通道内的值被接收完后再对通道执行接收操作得到的值会一直都是对应元素类型的零值。那我们如何判断一个通道是否被关闭了呢？</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">value,</span> ok := &lt;- ch<br></code></pre></td></tr></table></figure><p>其中：<br>value：从通道中取出的值，如果通道被关闭则返回对应类型的零值。<br>ok：通道ch关闭时返回 false，否则返回 true。<br>下面代码片段中的f2函数会循环从通道ch中接收所有值，直到通道被关闭后退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>v, ok := &lt;-ch<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;通道已关闭&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;v:%#v ok:%#v\n&quot;</span>, v, ok)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>ch &lt;- <span class="hljs-number">1</span><br>ch &lt;- <span class="hljs-number">2</span><br><span class="hljs-built_in">close</span>(ch)<br>f2(ch)<br>&#125;<br></code></pre></td></tr></table></figure><p>通常我们会选择使用<code>for range</code>循环从通道中接收值，当通道被关闭后，会在通道内的所有值被接收完毕后会自动退出循环。上面那个示例我们使用<code>for range</code>改写后会很简洁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Println(v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;通道已关闭&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">注意</font>目前Go语言中并没有提供一个不对通道进行读取操作就能判断通道是否被关闭的方法。不能简单的通过<code>len(ch)</code>操作来判断通道是否被关闭。</p><h5 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h5><p>channel在某些场景下，可能会被作为参数在函数间传递，一般来说我们会在不同的函数中对channel的使用进行限制，让单一函数对channel只有单一的操作，比如只能读取或者发送。假如我们现在有<code>Producer</code>和<code>Consumer</code>两个函数，其中<code>Producer</code>函数会返回一个通道，并且会持续将符合条件的数据发送至该通道，并在发送完成后将该通道关闭。而C<code>onsumer</code>函数的任务是从通道中接收值进行计算，这两个函数之间通过<code>Processer</code>函数返回的通道进行通信。完整的示例代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Producer 返回一个通道</span><br><span class="hljs-comment">// 并持续将符合条件的数据发送至返回的通道中</span><br><span class="hljs-comment">// 数据发送完成后会将返回的通道关闭</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// 创建一个新的goroutine执行发送数据的任务</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>ch &lt;- i<br>&#125;<br>&#125;<br><span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// 任务完成后关闭通道</span><br>&#125;()<br><br><span class="hljs-keyword">return</span> ch<br>&#125;<br><br><span class="hljs-comment">// Consumer 从通道中接收数据进行计算</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>sum += v<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := Producer()<br><br>res := Consumer(ch)<br>fmt.Println(res) <span class="hljs-comment">// 25</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的示例代码中可以看出正常情况下<code>Consumer</code>函数中只会对通道进行接收操作，但是这不代表不可以在<code>Consumer</code>函数中对通道进行发送操作。作为<code>Producer</code>函数的提供者，我们在返回通道的时候可能只希望调用方拿到返回的通道后只能对其进行接收操作。但是我们没有办法阻止在<code>Consumer</code>函数中对通道进行发送操作。</p><p>GO语言提供了单向通道来处理这种需要限制通道只能进行某种操作的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;- <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 只接收通道，只能接收不能发送</span><br><span class="hljs-keyword">chan</span> &lt;- <span class="hljs-type">int</span> <span class="hljs-comment">// 只发送通道，只能发送不能接收</span><br></code></pre></td></tr></table></figure><p>其中，箭头&lt;-和关键字chan的相对位置表明了当前通道允许的操作，这种限制将在编译阶段进行检测。另外对一个只接收通道执行close也是不允许的，因为默认通道的关闭操作应该由发送方来完成。</p><p>我们使用单向通道将上面的示例代码进行如下改造。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Producer2 返回一个接收通道</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Producer2</span><span class="hljs-params">()</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// 创建一个新的goroutine执行发送数据的任务</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>ch &lt;- i<br>&#125;<br>&#125;<br><span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// 任务完成后关闭通道</span><br>&#125;()<br><br><span class="hljs-keyword">return</span> ch<br>&#125;<br><br><span class="hljs-comment">// Consumer2 参数为接收通道</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Consumer2</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>sum += v<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch2 := Producer2()<br>  <br>res2 := Consumer2(ch2)<br>fmt.Println(res2) <span class="hljs-comment">// 25</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这一次，Producer函数返回的是一个只接收通道，这就从代码层面限制了该函数返回的通道只能进行接收操作，保证了数据安全。很多读者看到这个示例可能会觉着这样的限制是多余的，但是试想一下如果<code>Producer</code>函数可以在其他地方被其他人调用，你该如何限制他人不对该通道执行发送操作呢？并且返回限制操作的单向通道也会让代码语义更清晰、更易读。</p><p>在函数传参及任何赋值操作中全向通道（正常通道）可以转换为单向通道，但是无法反向转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch3 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>ch3 &lt;- <span class="hljs-number">10</span><br><span class="hljs-built_in">close</span>(ch3)<br>Consumer2(ch3) <span class="hljs-comment">// 函数传参时将ch3转为单向通道</span><br><br><span class="hljs-keyword">var</span> ch4 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>ch4 &lt;- <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> ch5 &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">// 声明一个只接收通道ch5</span><br>ch5 = ch4          <span class="hljs-comment">// 变量赋值时将ch4转为单向通道</span><br>&lt;-ch5<br></code></pre></td></tr></table></figure><p>下面的表格中总结了对不同状态下的通道执行相应操作的结果。<br><img src="https://image.jokernote.com/images/channel.png"></p><h5 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h5><p>在某些场景下我们可能需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以被接收那么当前 goroutine 将会发生阻塞。你也许会写出如下代码尝试使用遍历的方式来实现从多个通道中接收值。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">for</span>&#123;<br>    <span class="hljs-comment">// 尝试从ch1接收值</span><br>    <span class="hljs-meta">data</span>, ok := &lt;-ch1<br>    <span class="hljs-comment">// 尝试从ch2接收值</span><br>    <span class="hljs-meta">data</span>, ok := &lt;-ch2<br>    …<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式虽然可以实现从多个通道接收值的需求，但是程序的运行性能会差很多。Go 语言内置了select关键字，使用它可以同时响应多个通道的操作。</p><p>Select 的使用方式类似于之前学到的 switch 语句，它也有一系列 case 分支和一个默认的分支。每个 case 分支会对应一个通道的通信（接收或发送）过程。select 会一直等待，直到其中的某个 case 的通信操作完成时，就会执行该 case 分支对应的语句。具体格式如下：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">select &#123;<br><span class="hljs-keyword">case</span> &lt;-ch1:<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">case</span> data := &lt;-ch2:<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">case</span> ch3 &lt;- <span class="hljs-number">10</span>:<br><span class="hljs-comment">//...</span><br>default:<br><span class="hljs-comment">//默认操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Select 语句具有以下特点。</p><ul><li>可处理一个或多个 channel 的发送&#x2F;接收操作。</li><li>如果多个 case 同时满足，select 会随机选择一个执行。</li><li>对于没有 case 的 select 会一直阻塞，可用于阻塞 main 函数，防止退出。</li></ul><p>下面的示例代码能够在终端打印出10以内的奇数，我们借助这个代码片段来看一下 select 的具体使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> x := &lt;-ch:<br>fmt.Println(x)<br><span class="hljs-keyword">case</span> ch &lt;- i:<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//5</span><br><span class="hljs-comment">//7</span><br><span class="hljs-comment">//9</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>示例中的代码首先是创建了一个缓冲区大小为1的通道 ch，进入 for 循环后：</p><ul><li>第一次循环时 i &#x3D; 1，select 语句中包含两个 case 分支，此时由于通道中没有值可以接收，所以x :&#x3D; &lt;-ch 这个 case 分支不满足，而ch &lt;- i这个分支可以执行，会把1发送到通道中，结束本次 for 循环；</li><li>第二次 for 循环时，i &#x3D; 2，由于通道缓冲区已满，所以ch &lt;- i这个分支不满足，而x :&#x3D; &lt;-ch这个分支可以执行，从通道接收值1并赋值给变量 x ，所以会在终端打印出 1；</li><li>后续的 for 循环以此类推会依次打印出3、5、7、9。</li></ul>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang结构体</title>
    <link href="/2022/05/31/golang%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2022/05/31/golang%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>前面已经多次使用过自定义类型，这种自定义类型正是通过GO语言类型别名（alias-types）和结构体的形式支撑的。结构体也是复合类型，通常是用一个带属性的结构体来表示一个现实中的实体。<br>一个自定义类型由一系列属性组成，每个属性都有自己的类型和值。结构体的目的就是把数据聚集在一起，以便能够更加便捷快捷的操作这些数据，在外部来看就像一个实体。结构体依旧是值类型，可以通过new函数来创建。</p><h6 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h6><p>结构体定义的方式一般如下，组成结构体类型的数据称之为字段。每个字段都有一个类型和名字，在一个结构体中，字段名字必须是唯一的：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> stuctName struct &#123;<br>    field1 type1<br>    field2 type2<br>&#125;<br></code></pre></td></tr></table></figure><p>除此以外，type T{a, b int}也是合法的。<br>结构体的字段都有名字，如果字段不会在代码中用到，还可以命名为_（空标识符）</p><p>结构体的字段可以是任意的类型，包括结构体本身，甚至可以是函数或者接口。<br>数组可以看做一种结构体类型，不过它使用下标而不是具体名称字段。</p><blockquote><p>new创建结构体</p></blockquote><p>一般结构体定义之后，习惯使用 t :&#x3D; new(T) 给该结构体分配内存，它返回已分配内存的指针。变量t是一个指向T的指针，此时结构体字段的值是他们所属类型的零值。注意定义和分配内存两部分代码一定要放在一起，例如结构体定义范围是整个包，但是内存可以选择在合适的时候分配。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> <span class="hljs-built_in">t</span> *<span class="hljs-built_in">T</span><br><span class="hljs-built_in">t</span> = new(<span class="hljs-built_in">T</span>)<br></code></pre></td></tr></table></figure><p>如果声明 var t T，这样也会给t分配内存，并初始化为零值，这个时候t是类型T的，这两种方式中，t被称为类型T的一个实例（instance）或者对象（object），以下是示例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">type</span> information struct &#123;<br><span class="hljs-type">name</span>   string<br>age    <span class="hljs-type">int</span><br>weight float32<br>&#125;<br><br>func main() &#123;<br><span class="hljs-keyword">info</span> := <span class="hljs-built_in">new</span>(information)<br><span class="hljs-keyword">info</span>.name = &quot;张三&quot;<br><span class="hljs-keyword">info</span>.age = <span class="hljs-number">20</span><br><span class="hljs-keyword">info</span>.weight = <span class="hljs-number">56.3</span><br><br>fmt.Printf(&quot;info = %#v\n&quot;, <span class="hljs-keyword">info</span>)<br>//<span class="hljs-keyword">info</span> = &amp;main.information&#123;<span class="hljs-type">name</span>:&quot;张三&quot;, age:<span class="hljs-number">20</span>, weight:<span class="hljs-number">56.3</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>fmt.Println() 可以打印结构体的属性值，使用<code>.</code>给字段赋值，同样，<code>.</code>也可以用于获取结构体字段的值。</p><p>这个点符号在GO语言中叫做选择器，无论变量是一个结构体类型还是一个结构体类型指针，都可以使用相同的选择器符号（selector-notation）来引用结构体的字段：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> testStruct <span class="hljs-comment">// 结构体变量</span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> *testStruct <span class="hljs-comment">// 结构体类型变量的指针</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.i</span><br><span class="hljs-selector-tag">b</span>.i<br></code></pre></td></tr></table></figure><p>此外结构体初始化还可以通过字面量方式来实现：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ts := &amp;<span class="hljs-built_in">testStruct</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3.4</span>, <span class="hljs-string">&quot;test&quot;</span>)<br><span class="hljs-comment">// 此时ts的类型是 *testStruct</span><br><span class="hljs-comment">// 或者以下方式也可以</span><br><span class="hljs-selector-tag">var</span> ts testStruct<br>ts = <span class="hljs-built_in">testStruct</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3.4</span>, <span class="hljs-string">&quot;test&quot;</span>)<br></code></pre></td></tr></table></figure><p>上面第一种写法称为混合字面量写法，&amp;T{…}这种方式依旧会调用new()初始化，且大括号里面的值必须按照顺序填写。</p><p>在下面的例子中，通过在值的前面放上字段名来初始化字段，显然，表达式new(Type)和&amp;Type{}是等价的：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">type</span> <span class="hljs-built_in">Sleep</span> <span class="hljs-keyword">struct</span> &#123;<br>    start int<br>    <span class="hljs-keyword">end</span> int<br>&#125;<br><span class="hljs-comment">// 三种初始化方式</span><br>intr := <span class="hljs-built_in">sleep</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;<br>intr := <span class="hljs-built_in">sleep</span>&#123;<span class="hljs-keyword">end</span>: <span class="hljs-number">0</span>, start: <span class="hljs-number">7</span>&#125;<br>intr := <span class="hljs-built_in">sleep</span>&#123;<span class="hljs-keyword">end</span>: <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>在以上的初始化方式中，第一种的值必须以字段在结构体定义时的顺序填写，这里的<code>&amp;</code>符号可以省略，因为不是直接通过字面量初始化的，前面已经定义了。第二种方式是字段名加一个冒号放在值的前面，在这种情况下值的顺序不必一致，并且某些字段还可以被忽略掉，就像第三行那样。</p><p>结构体类型和字段的命名遵循可见性规则，一个导出的结构体类型中可以只有一些字段是导出的，另一些不可导出。类型在定义它的包中必须是唯一的，它的完全命名格式就是常见的pack.struct的形式</p><p>下面的例子中有一个结构体Person和一个方法，方法有一个类型为*Person的参数（所以对象本身是可以被改变的），下面使用三种不同的当时调用这个方法：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type Person struct &#123;<br>firstName string<br>lastname  string<br>&#125;<br><br>func <span class="hljs-built_in">upName</span>(<span class="hljs-selector-tag">p</span> *Person) &#123;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.firstName</span> = strings<span class="hljs-selector-class">.ToUpper</span>(<span class="hljs-selector-tag">p</span>.firstName)<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.lastname</span> = strings<span class="hljs-selector-class">.ToUpper</span>(<span class="hljs-selector-tag">p</span>.lastname)<br>&#125;<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-comment">// 值类型</span><br><span class="hljs-selector-tag">var</span> personOne Person<br>personOne<span class="hljs-selector-class">.firstName</span> = <span class="hljs-string">&quot;john&quot;</span><br>personOne<span class="hljs-selector-class">.lastname</span> = <span class="hljs-string">&quot;wick&quot;</span><br><span class="hljs-built_in">upName</span>(&amp;personOne)<br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;name is ： %s %s \n&quot;</span>, personOne<span class="hljs-selector-class">.firstName</span>, personOne.lastname)<br><br><span class="hljs-comment">// 指针类型</span><br>personTwo := <span class="hljs-built_in">new</span>(Person)<br>personTwo<span class="hljs-selector-class">.firstName</span> = <span class="hljs-string">&quot;james&quot;</span><br><span class="hljs-comment">//(*personTwo).lastname = &quot;bond&quot; // 同样有效</span><br>personTwo<span class="hljs-selector-class">.lastname</span> = <span class="hljs-string">&quot;bond&quot;</span><br><span class="hljs-built_in">upName</span>(personTwo)<br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;name is ： %s %s \n&quot;</span>, personTwo<span class="hljs-selector-class">.firstName</span>, personTwo.lastname)<br><br><span class="hljs-comment">//字面量类型</span><br>personThree := &amp;Person&#123;<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;sparrow&quot;</span>&#125;<br><span class="hljs-built_in">upName</span>(personThree)<br>fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;name is ： %s %s \n&quot;</span>, personThree<span class="hljs-selector-class">.firstName</span>, personThree.lastname)<br>&#125;<br></code></pre></td></tr></table></figure><p>在第二种情况中，GO语言可以直接通过指针（personTwo.lastName）给结构体字段赋值，GO语言会自动转换，也可以通过解析指针来设置值，例如(*personTwo).lastName。</p><p>在其他语言中，结构体是引用类型，一个对象和它包含的对象可能会在不同的内存空间中，但GO语言不一样，GO语言的结构体与它的数据在内存中是以连续内存块存储的（嵌套结构体也是一样），由此有很大的性能优势。</p><blockquote><p>递归结构体</p></blockquote><p>结构体类型可以通过引用自身来定义，这在定义链表或二叉树的元素（通常叫节点）时特别有用，此时节点包含指向临近节点的链接（地址）。</p><p>如下所示，data字段用于存放有效数据（比如float64），su指针指向后继节点：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">type</span> <span class="hljs-keyword">Node</span> <span class="hljs-title">struct</span> &#123;<br>    data float64<br>    su *<span class="hljs-keyword">Node</span><br><span class="hljs-title">&#125;</span><br></code></pre></td></tr></table></figure><p>链表的第一个元素叫head，它指向第二个元素；最后一个元素叫tail，它没有后继元素，所以它的su值为nil。当然真实的链表会有很多数据节点，并且链表可以动态增长或收缩。</p><p>同样可以定义一个双向链表，它有一个前趋节点pr和一个后继节点su：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">type</span> <span class="hljs-keyword">Node</span> <span class="hljs-title">struct</span> &#123;<br>    pr *<span class="hljs-keyword">Node</span><br>    <span class="hljs-title">data</span> float64<br>    su *<span class="hljs-keyword">Node</span><br><span class="hljs-title">&#125;</span><br></code></pre></td></tr></table></figure><p>二叉树中每个节点最多能链接至两个节点：左节点（le）和右节点（ri），这两个节点本身又可以有左右节点，以此类推，树的顶层节点叫做根节点（root），底层没有子节点的节点叫叶子节点（leaves），叶子节点的le和ri指针为nil值。在GO语言中可以如下定义二叉树：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Tree</span> struct &#123;<br>    le *<span class="hljs-type">Tree</span><br>    data float64<br>    ri *<span class="hljs-type">Tree</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>匿名结构体</p></blockquote><p>GO语言中结构体支持匿名结构体，匿名结构体没有类型名称，无须通过type关键字定义就可以直接使用</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts">s := <span class="hljs-title class_">struct</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// 匿名结构体字段定义</span><br>    Field1 Field1Type<br>    Field2 Field2Type<br>    …<br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// 字段值初始化</span><br><span class="hljs-symbol">    Field1:</span> Value1,<br><span class="hljs-symbol">    Field2:</span> Value2,<br>    …<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h6 id="结构体的使用"><a href="#结构体的使用" class="headerlink" title="结构体的使用"></a>结构体的使用</h6><p>下面我们来尝试在别的包中使用其结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// person下的test包：</span><br><span class="hljs-keyword">package</span> person<br><br><span class="hljs-keyword">type</span> Info <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-type">string</span><br>Age    <span class="hljs-type">int</span><br>Weight <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-comment">// main包</span><br>personOne := <span class="hljs-built_in">new</span>(person.Info)<br>personOne.Name = <span class="hljs-string">&quot;john&quot;</span><br>personOne.Age = <span class="hljs-number">22</span><br>personOne.Weight = <span class="hljs-number">76.3</span><br>fmt.Println(<span class="hljs-string">&quot;weight is&quot;</span>, personOne.Weight)<br></code></pre></td></tr></table></figure><p>在GO语言中，访问结构体成员使用<code>.</code>符号既可，格式为“结构体.成员名”。</p><p>还可以定义指向结构体的指针（指向结构体变量的首地址），类似其他指针变量，如：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> employee *Company<br></code></pre></td></tr></table></figure><p>使用结构体指针访问结构体成员时，依旧使用<code>.</code>操作符</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> Info <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-built_in">string</span><br>Age    <span class="hljs-built_in">int</span><br>Weight float32<br>&#125;<br><br>func print<span class="hljs-constructor">Info(<span class="hljs-params">p</span> <span class="hljs-operator">*</span>Info)</span> &#123;<br>fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;name is&quot;</span>, <span class="hljs-params">p</span>.Name)</span><br>fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;age is&quot;</span>, <span class="hljs-params">p</span>.Age)</span><br>fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;weight is&quot;</span>, <span class="hljs-params">p</span>.Weight)</span><br>&#125;<br><br>func main<span class="hljs-literal">()</span> &#123;<br>var personOne Info<br><span class="hljs-comment">//personOne := new(Info) // 不能使用new，因为new返回的是指向Info的指针，&amp;personOne就成了指针的指针</span><br>personOne.Name = <span class="hljs-string">&quot;john&quot;</span><br>personOne.Age = <span class="hljs-number">22</span><br>personOne.Weight = <span class="hljs-number">76.3</span><br>print<span class="hljs-constructor">Info(&amp;<span class="hljs-params">personOne</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结构体还可以像其他数据类型一样作为参数传递给函数，并以以上实例的方式访问结构体变量，有形式参数传输和指针参数传输两种形式，如下例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">changeName</span>(<span class="hljs-selector-tag">p</span> Info) &#123;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.Name</span> = <span class="hljs-string">&quot;jack&quot;</span><br>&#125;<br><br>func <span class="hljs-built_in">changeName2</span>(<span class="hljs-selector-tag">p</span> *Info) &#123;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.Name</span> = <span class="hljs-string">&quot;tom&quot;</span><br>&#125;<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">var</span> personOne Info<br>personOne<span class="hljs-selector-class">.Name</span> = <span class="hljs-string">&quot;john&quot;</span><br>personOne<span class="hljs-selector-class">.Age</span> = <span class="hljs-number">22</span><br>personOne<span class="hljs-selector-class">.Weight</span> = <span class="hljs-number">76.3</span><br><span class="hljs-built_in">changeName</span>(personOne)<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;形式&quot;</span>, personOne.Name) <span class="hljs-comment">// john</span><br><br><span class="hljs-built_in">changeName2</span>(&amp;personOne)<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;指针&quot;</span>, personOne.Name) <span class="hljs-comment">// tom</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由上可见，形式传参只是传递一个副本到一个函数中，函数操作的是副本，对personOne没有影响，而在指针传参中传递的事指针地址，因此修改的结果影响了personOne。</p><h6 id="结构体的标签"><a href="#结构体的标签" class="headerlink" title="结构体的标签"></a>结构体的标签</h6><p>结构体的字段不仅有名字和类型，还有一个可选的附属于字段的标签（tag）：用于文档说明或者开发过程中的特殊标记。标签内容只有reflect包可以获取。</p><blockquote><p>用于文档说明</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Info <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-type">string</span>  <span class="hljs-string">&quot;姓名&quot;</span><br>Age    <span class="hljs-type">int</span>     <span class="hljs-string">&quot;年龄&quot;</span><br>Weight <span class="hljs-type">float32</span> <span class="hljs-string">&quot;体重&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>用于特殊标记</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">type</span> <span class="hljs-keyword">Info</span> struct &#123;<br><span class="hljs-type">Name</span>   string  `<span class="hljs-type">json</span>:&quot;name&quot;` //<span class="hljs-type">json</span>序列化时使用的tag<br>Age    <span class="hljs-type">int</span>     `<span class="hljs-type">json</span>:&quot;age&quot;`<br>Weight float32 `<span class="hljs-type">json</span>:&quot;weight&quot;`<br>&#125;<br><br>var personOne <span class="hljs-keyword">Info</span><br>personOne.Name = &quot;john&quot;<br>personOne.Age = <span class="hljs-number">22</span><br>personOne.Weight = <span class="hljs-number">76.3</span><br><br>data, err := <span class="hljs-type">json</span>.Marshal(personOne)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>fmt.Println(&quot;json marshal error&quot;)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Printf(&quot;json str: %s\n&quot;, data)<br>//<span class="hljs-type">json</span> str: &#123;&quot;name&quot;:&quot;john&quot;,&quot;age&quot;:<span class="hljs-number">22</span>,&quot;weight&quot;:<span class="hljs-number">76.3</span>&#125;<br></code></pre></td></tr></table></figure><h6 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h6><p>匿名字段和面向对象的继承概念相似，可以被用来模拟类似继承的行为。GO语言中的继承是通过内嵌和组合来实现的，所以可以说在GO语言中，组合比集成更受欢迎：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> First <span class="hljs-keyword">struct</span> &#123;<br>in1 <span class="hljs-type">int</span><br>in2 <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Second <span class="hljs-keyword">struct</span> &#123;<br>b <span class="hljs-type">int</span><br>c <span class="hljs-type">float32</span><br><span class="hljs-type">int</span> <span class="hljs-comment">// 匿名字段</span><br>First <span class="hljs-comment">// 匿名字段</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sec := <span class="hljs-built_in">new</span>(Second)<br>sec.b = <span class="hljs-number">1</span><br>sec.c = <span class="hljs-number">3.5</span><br>sec.<span class="hljs-type">int</span> = <span class="hljs-number">20</span><br>sec.in1 = <span class="hljs-number">25</span><br>sec.in2 = <span class="hljs-number">30</span><br><br>fmt.Printf(<span class="hljs-string">&quot;sec.b is %d\n&quot;</span>, sec.b)<br>fmt.Printf(<span class="hljs-string">&quot;sec.c is %f\n&quot;</span>, sec.c)<br>fmt.Printf(<span class="hljs-string">&quot;sec.int is %d\n&quot;</span>, sec.<span class="hljs-type">int</span>)<br>fmt.Printf(<span class="hljs-string">&quot;sec.in1 is %d\n&quot;</span>, sec.in1)<br>fmt.Printf(<span class="hljs-string">&quot;sec.in2 is %d\n&quot;</span>, sec.in2)<br><br>sec2 := Second&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3.5</span>, <span class="hljs-number">20</span>, First&#123;<span class="hljs-number">25</span>, <span class="hljs-number">30</span>&#125;&#125;<br>fmt.Println(sec2)<br><span class="hljs-comment">//sec.b is 1</span><br><span class="hljs-comment">//sec.c is 3.500000</span><br><span class="hljs-comment">//sec.int is 20</span><br><span class="hljs-comment">//sec.in1 is 25</span><br><span class="hljs-comment">//sec.in2 is 30</span><br><span class="hljs-comment">//&#123;1 3.5 20 &#123;25 30&#125;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过类型sec.int的名字来获取存储在匿名字段中的数据，可以看出：一个结构体中对于每一种数据类型只能有一个匿名字段。</p><h6 id="内嵌结构体"><a href="#内嵌结构体" class="headerlink" title="内嵌结构体"></a>内嵌结构体</h6><p>结构体也是一种数据类型，所以它同样可以作为匿名字段使用，上面的例子就是这样使用的。外层结构体通过sec.in1直接进入内层结构体的字段，内嵌结构体甚至可以来自其他包，内层结构体被简单的插入或者内嵌进外层结构体，这种简单的“继承”机制使得GO语言很轻松就能实现从一个或一些类型中继承部分或全部的实现。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type A struct &#123;<br>x, y int<br>&#125;<br><br>type B struct &#123;<br>A<br>bx, by int<br>&#125;<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">b</span> := B&#123;A&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.x</span>, <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.y</span>, <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.bx</span>, <span class="hljs-selector-tag">b</span>.by)<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-selector-tag">b</span>.A)<br><span class="hljs-comment">//1 2 3 4</span><br><span class="hljs-comment">//&#123;1 2&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h6><p>当两个字段拥有相同的名字（比如继承其他结构体时）会产生冲突，一般情况有两种</p><ul><li>外层字段的名字覆盖内层字段的名字，但是两者的内存空间都会保留，者提供了一种重载字段或方法的方式。</li><li>相同的名字在同层次结构体中出现了重复，并且这个字段被程序调用了，这将导致程序错误（字段不被调用不会报错，但有隐患）。这种情况只能开发者自己修正。<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">A</span> struct &#123;<br>a int<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">B</span> struct &#123;<br>a, b int<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">C</span> struct &#123;<br><span class="hljs-type">A</span><br><span class="hljs-type">B</span><br>&#125;<br><span class="hljs-title">var</span> c <span class="hljs-type">C</span><br></code></pre></td></tr></table></figure>后续代码中不能使用c.a这种方式，因为编译器分不清是c.A.a还是c.B.a，因此会报错<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">D</span> struct &#123;<br><span class="hljs-type">B</span><br>b float32<br>&#125;<br><span class="hljs-title">var</span> d <span class="hljs-type">D</span><br></code></pre></td></tr></table></figure>后续代码中使用d.b没问题，因为它的类型是float32，而不是B的b类型。如果想要调用内层的b，可以通过d.B.b得到对应的值</li></ul><h4 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h4><p>顾名思义，类型系统是指一个语言的类型体系系统，类型系统描述的是这些内容在一个语言中如何被关联。GO语言是一种静态类型的编程语言，这意味着，编译器需要在编译时知道程序每个值的类型。如果提前知道类型信息，编译器就可以确保程序合理的使用值，这有助于减少潜在的内存异常和bug，并且是编译器有机会对代码进行一些性能优化，提高执行效率。<br>值的类型给编译器提供两部分信息：第一部分，需要分配多少内存给这个值（即值的规模）；第二部分，这段内存表示什么。对于很多内置类型来说，规模和表示是类型名的一部分。例如int64类型的值需要8B（64b），表示一个整数值；float32类型的值需要4B（32b）来表示一个IEEE-754定义的二进制浮点数；bool类型的值需要1B（8b），表示布尔值true或false。<br>有些类型的内部表示与编译代码的机器的体系结构有关，例如，根据编译所在的机器的体系结构，一个int值的大小可能是8B（64b），也可能是4B（32b）。还有一些与体系结构相关的类型，如GO于艳丽的所有引用类型。好在创建和使用这些类型的值的时候，不需要了解这些与体系结构相关的信息。但是，如果编译器不知道这些信息，就无法组织用户做一些导致程序受损甚至机器故障的事情。</p><h6 id="用户自定义类型"><a href="#用户自定义类型" class="headerlink" title="用户自定义类型"></a>用户自定义类型</h6><p>GO语言允许用户定义类型。当用户声明一个新类型时，这个声明就给编译器提供了一个框架，告知必要的内存大小和表示信息。声明后的类型与内置类型的运作方式类似。GO语言里声明用户定义的类型有两种方法，最常用的方法时使用关键字<code>struct</code>，它可以让用户创建一个结构类型。<br>结构类型通过组合一系列固定且唯一的字段来声明，如下面代码所示，结构里每个字段都会用一个已知类型来声明，这个已知类型可以是内置类型，也可以是其他用户定义的类型。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">type</span> <span class="hljs-keyword">user</span> <span class="hljs-title">struct</span> &#123;<br>    name <span class="hljs-keyword">string</span><br>    age int<br>    married bool<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上代码中，可以看到一个结构类型的声明，这个声明以关键字type开始，之后是新类型的名字，最后时关键字struct，这个结构类型有4个字段，每个字段都基于一个内置类型。<br>下面展示了如何声明一个<code>user</code>类型的变量，并使用某个非零值作为初始值。首先给出一个变量名，之后是短变量声明操作符。这个操作符是冒号加一个等号（:&#x3D;）。一个短变量声明操作符在一次操作中会完成两件事：声明一个变量。并初始化。短变量声明操作符会使用右侧给出的类型信息作为声明变量的类型。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 声明user类型的变量并初始化</span><br>john := user<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    name:</span> <span class="hljs-string">&quot;john&quot;</span>,<br><span class="hljs-symbol">    age:</span> <span class="hljs-number">23</span>,<br><span class="hljs-symbol">    married:</span> false,<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>既然要创建并初始化一个结构类型，就使用结构字面量来完成这个初始化，如下面代码所示，结构字面量使用一对大括号扩住内部字段的初始值：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts">user<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    name:</span> <span class="hljs-string">&quot;john&quot;</span>,<br><span class="hljs-symbol">    age:</span> <span class="hljs-number">23</span>,<br><span class="hljs-symbol">    married:</span> false,<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>结构字面量可以对结构类型采用两种形式，上面代码使用了第一种形式，这种形式在不同声明每个字段的名字以及对应的值，字段名与值用冒号分离，每一行以逗号结尾，这种形式对字段的声明顺序没有要求；第二种形式没有字段名，只声明对应的值。如下面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">john := &#123;<span class="hljs-string">&quot;john&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-literal">false</span>&#125;<br></code></pre></td></tr></table></figure><p>每个值也可以分别占一行，不过习惯上这种形式会写在一行里，结尾不需要逗号。在这种形式下，值的顺序很重要，必须要和结构体中声明字段的顺序一致。当声明结构类型时，字段的类型并不限制在内置类型，也可以使用其他用户定义的类型。<br>比如下面展示了一个名为member的新结构类型，这个结构类型有一个名为person的user类型的字段，还声明了一个名为level的string字段。当创建具有person这种字段的结构类型的变量是，初始化用的结构字面量有一些变化：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">type</span> member struct &#123;<br>    person <span class="hljs-keyword">user</span><br>    <span class="hljs-keyword">level</span> string<br>&#125;<br><br>john := member&#123;<br>person: <span class="hljs-keyword">user</span>&#123; // A<br><span class="hljs-type">name</span>: &quot;john&quot;,<br>age: <span class="hljs-number">23</span>,<br>married: <span class="hljs-keyword">false</span>,<br>&#125;,<br><span class="hljs-keyword">level</span>: &quot;3&quot;,<br>&#125;<br></code></pre></td></tr></table></figure><p>为了初始化person字段，需要创建一个user类型的值，上面代码A处就是在创建这个值，这行代码使用结构字面量的形式创建了一个user类型的值，并赋给了person字段。<br>另一种声明用户定义类型的方式是，基于一个已有的类型，将其作为新类型的类型说明，当需要一个可以用已有类型表示的新类型的时候，这种方法会非常好用。<br>标准库使用这种声明类型的方法，从内置类型创建出很多更加明确的类型，并赋予更高级的功能：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">Duration </span>int64<br></code></pre></td></tr></table></figure><p>上面代码是标准库的time包里的一个类型声明。Duration是一种描述时间间隔的类型，单位是纳秒（ns），这个类型使用内置的int64类型作为其表示，在Duration类型的声明中，我们把int64叫做Duration的基础类型，不过，虽然int64是基础类型，但GO语言并不认为Duration和int64是同一种类型，这两个类型是完全不同的、有区别的类型。<br>类型int64的值不能作为类型Duration的值来使用，换句话来说，虽然int64类型是基础类型，Duration类型已然是一个独立的类型，两种不同的类型即便相互兼容，也不能互相赋值，编译器不会对不同类型的值做隐式转换。</p><h6 id="值语义和引用语义"><a href="#值语义和引用语义" class="headerlink" title="值语义和引用语义"></a>值语义和引用语义</h6><p>值语义和引用语义的差别在于赋值，如下例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.Modify</span>()<br></code></pre></td></tr></table></figure><p>如果b的修改不会影响a的值，那么此类型属于值类型。如果会影响a的值，那么属于引用类型。GO语言中大多数类型都基于值语义，例如基本类型（byte、int、bool、float32、float64和string等）和复合类型（如数组，结构体和指针等）<br>GO语言中类型的值语义表现得非常彻底，之所以这么说是因为数组。如果读者之前学过C语言，就会知道C语言的数组比较特别，通过函数传递一个数组的时候基于引用语义，但是在结构体中定义数组变量的时候基于值语义（表现在为结构体赋值的时候，该数组会被完整复制）。<br>GO语言的数组和基本类型没有区别，是纯粹的值类型，如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-attr">[3]</span>int&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[1]</span>++<br>fmt<span class="hljs-selector-class">.PrintLn</span>(<span class="hljs-selector-tag">a</span>, b) <span class="hljs-comment">// [1, 2, 3] [1, 3, 3]</span><br></code></pre></td></tr></table></figure><p>这表明 b &#x3D; a 赋值语句是数组内容的完整复制，要想表达引用，需要使用指针：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-attr">[3]</span>int&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = &amp;<span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[1]</span>++<br>fmt<span class="hljs-selector-class">.PrintLn</span>(<span class="hljs-selector-tag">a</span>, b) <span class="hljs-comment">// [1, 3, 3] [1, 3, 3]</span><br></code></pre></td></tr></table></figure><p>这表明 b &#x3D; &amp;a 赋值语句时数组内容的引用。变量b的类型不是[3]int，而是*[3]int类型。GO语言中有4个类型为引用类型（还有pointers、function等），如下所示：</p><ul><li>数组切片：指向数组（array）的一个区间</li><li>map：常见的数据结构，提供键值查询能力</li><li>channel：执行体（goroutine）间的通信设施</li><li>接口（interface）：对一组满足某个契约的类型的抽象</li></ul><p>但是这不影响我们将GO语言类型看作值语义。下面来看看4个类型。数组切片本质上是一个区间，可以大致将[]T表示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>    first *T<br>    <span class="hljs-built_in">len</span> <span class="hljs-type">int</span><br>    <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为数组切片内部是指向数组的指针，所以可以改变所指向的数组元素并不奇怪。数组切片类型本身的赋值仍然是值语义。<br>map本质上是一个字典指针，可以大致将map[K]V表示为：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Map_K_v</span> struct &#123;<br>    // ...<br>&#125;<br><span class="hljs-keyword">type</span> map[<span class="hljs-type">K</span>]<span class="hljs-type">V</span> struct &#123;<br>    impl *<span class="hljs-type">Map_K_V</span><br>&#125;<br></code></pre></td></tr></table></figure><p>基于指针，完全可以自定义一个引用类型，如：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">IntergerRef</span> struct &#123;<br>    impl *int<br>&#125;<br></code></pre></td></tr></table></figure><p>channel和map类型，本质上是一个指针。将它们设计成引用类型而不是统一的值类型的原因是，完整复制一个channel或map并不是常规需求。同样，接口具备引用语义，是因为内部维持了两个指针，示意为：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> interface struct &#123;<br>    data *void<br>    itab *<span class="hljs-type">Itab</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接口在GO语言中的地位非常重要，关于接口的内部实现细节，在后面会仔细讲解。</p>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang并发</title>
    <link href="/2022/05/31/golang%E7%9A%84goroutine/"/>
    <url>/2022/05/31/golang%E7%9A%84goroutine/</url>
    
    <content type="html"><![CDATA[<h6 id="指定使用核心数"><a href="#指定使用核心数" class="headerlink" title="指定使用核心数"></a>指定使用核心数</h6><p>Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过runtime.GOMAXPROCS函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的CPU 逻辑核心数。）</p><p>当然已提供了相应的标准库来制定核心数。使用flags包可以调整程序运行时调用CPU核心数，如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> numCors = flags<span class="hljs-selector-class">.Int</span>(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;CPU核心数&quot;</span>)<br><span class="hljs-keyword">in</span> <span class="hljs-selector-tag">main</span>()<br>flag<span class="hljs-selector-class">.Pars</span>()<br>runtime<span class="hljs-selector-class">.GOMAXPROCS</span>(*numCors)<br></code></pre></td></tr></table></figure><p>协程可以通过调用runtime.Goexit()来停止，但是一般不这么使用。</p><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>与传统的系统级线程和进程相比，协程的最大优势在于其“轻量级”，可以轻松创建上百万个协程为不会导致系统资源衰竭，而线程和进程通常最多也不能超过10000个。这也是协程叫做轻量级线程的原因。<br>多数语言在语法层面并不直接支持协程，而是通过库的方式支持，但通过库的当时支持的功能也不完整，比如仅仅提供轻量级线程的创建、销毁与切换等能力。如果在这也的轻量级协程中调用一个同步IO操作，比如网络通信，文件读写等，都会阻塞其他的并发执行的轻量级线程，从而无法达到轻量级线程本身期望的目标。<br>GO语言在语言级别支持轻量级线程，叫goroutine。GO语言标准库提供的所有系统调用操作（包括所有同步IO操作），都会让出CPU给其他goroutine（创建协程会自动分配一个合适的CPU优先级，不管优先级如何都会与同级协程竞争CPU资源，从外部看来就是让出了部分CPU资源）。折让轻量级线程的切换管理不依赖于系统的线程和进程，也不依赖于CPU的核心数量，而是交给GO语言运行时统一调度（也允许手动控制）</p><h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h4><p>goroutine是GO语言并行设计的核心。goroutine说到底就是协程，但是比线程更小，十几个goroutine可能体现在底层也就是五六个线程，GO语言帮我们实现了这些goroutine之间的内存共享。执行goroutine只需要极少的栈内存（大概4~5KB），当然也会根据相应的数据伸缩，也因为如此，程序可以同时运行成千上万个并发任务。<br>goroutine是通过GO程序的runtime管理的一个线程管理器，通过go关键字实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<br>fmt.Println(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">go</span> printString(<span class="hljs-string">&quot;yes&quot;</span>)<br><span class="hljs-comment">//printString(&quot;no&quot;)</span><br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">go</span> printString(<span class="hljs-string">&quot;no&quot;</span>)<br>&#125;<br>time.Sleep(time.Second * <span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-comment">/*yes</span><br><span class="hljs-comment">no</span><br><span class="hljs-comment">yes</span><br><span class="hljs-comment">no</span><br><span class="hljs-comment">yes</span><br><span class="hljs-comment">no*/</span><br></code></pre></td></tr></table></figure><p>上面可以看到go关键字很方便的实现了并发编程，两个for循环虽然代码顺序不一样，但是都在同时执行各自的任务。因为main函数执行完后，goroutine还在执行各自的操作，所以CIA会有了上面的<code>time.Sleep(time.Second * 2)</code>，让差不多goroutine都差不多执行完了才结束主线程，不过这样执行代码是不优雅的，也有可能不准确，GO语言提供的<code>sync</code>包提供了一些常用的并发用语，之后会介绍<code>sync</code>包的详细内容，当前我们简单用一下<code>sync</code>包中的<code>WaitGroup</code>。当你并不关心并发操作的结果或者有其它方式收集并发操作的结果时，WaitGroup是实现等待一组并发操作完成的好方法。其次在设计上要遵循：<font color="red">不要通过共享来通信，而要通过通信来共享</font></p><p>下面的示例代码中我们在 main goroutine 中使用sync.WaitGroup来等待 hello goroutine 完成后再退出。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 声明全局等待组变量</span><br><span class="hljs-selector-tag">var</span> wg sync<span class="hljs-selector-class">.WaitGroup</span><br><br>func <span class="hljs-built_in">hello</span>() &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>wg<span class="hljs-selector-class">.Done</span>() <span class="hljs-comment">// 告知当前goroutine完成</span><br>&#125;<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br>wg<span class="hljs-selector-class">.Add</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 登记1个goroutine</span><br>go <span class="hljs-built_in">hello</span>()<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br>wg<span class="hljs-selector-class">.Wait</span>() <span class="hljs-comment">// 阻塞等待登记的goroutine完成</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将代码编译后再执行，这一次程序不再会有多余的停顿，hello goroutine 执行完毕后程序直接退出。</p><h5 id="启用多个goroutine"><a href="#启用多个goroutine" class="headerlink" title="启用多个goroutine"></a>启用多个goroutine</h5><p>这就简单的用GO语言实现了并发，我们还可以启动多个 goroutine 。让我们再来看一个新的代码示例。这里同样使用了sync.WaitGroup来实现 goroutine 的同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// goroutine结束就登记-1</span><br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>, i)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 启动一个goroutine就登记+1</span><br><span class="hljs-keyword">go</span> hello(i)<br>&#125;<br>wg.Wait() <span class="hljs-comment">// 等待所有登记的goroutine都结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>多次执行上面的代码会发现每次终端上打印数字的顺序都不一致。这是因为10个 goroutine 是并发执行的，而 goroutine 的调度是随机的。</p><p>sync.WaitGroup：计数器+delta<br>(wg *WaitGroup) Done()：计数器-1<br>(wg *WaitGroup) Wait()：阻塞直到计数器变为0<br>sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 Done 方法将计数器减1。通过调用 Wait 来等待并发任务执行完，当计数器值为 0 时，表示所有并发任务已经完成。<br><font color="red">需要注意sync.WaitGroup是一个结构体，进行参数传递的时候要传递指针。</font></p><blockquote><p>goroutine 调度</p></blockquote><p>操作系统内核在调度时会挂起当前正在执行的线程并将寄存器中的内容保存到内存中，然后选出接下来要执行的线程并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。从一个线程切换到另一个线程需要完整的上下文切换。因为可能需要多次内存访问，索引这个切换上下文的操作开销较大，会增加运行的cpu周期。</p><p>区别于操作系统内核调度操作系统线程，goroutine 的调度是Go语言运行时（runtime）层面的实现，是完全由 Go 语言本身实现的一套调度系统——go scheduler。它的作用是按照一定的规则将所有的 goroutine 调度到操作系统线程上执行。</p><p>在经历数个版本的迭代之后，目前 Go 语言的调度器采用的是 GPM 调度模型。</p><p><img src="https://image.jokernote.com/images/gpm.png" alt="图片描述"><br>其中：</p><ul><li>G：表示 goroutine，每执行一次go f()就创建一个 G，包含要执行的函数和上下文信息。</li><li>全局队列（Global Queue）：存放等待运行的 G。</li><li>P 的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果本地队列满了会批量移动部分 G 到全局队列。</li><li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li><li>Goroutine 调度器和操作系统调度器是通过 M 结合起来的，每个 M 都代表了1个内核线程，操作系统调度器负责把内核线程分配到 CPU 的核上执行。</li></ul><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。</p><h5 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h5><p>有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生竞态问题（数据竞态）。这就好比现实生活中十字路口被各个方向的汽车竞争，还有火车上的卫生间被车厢里的人竞争。</p><p>我们用下面的代码演示一个数据竞争的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>x <span class="hljs-type">int64</span><br><br>wg sync.WaitGroup <span class="hljs-comment">// 等待组</span><br>)<br><br><span class="hljs-comment">// add 对全局变量x执行5000次加1操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<br>x = x + <span class="hljs-number">1</span><br>&#125;<br>wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">go</span> add()<br><span class="hljs-keyword">go</span> add()<br><br>wg.Wait()<br>fmt.Println(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码执行后，每次输出的结果都不一样，这是因为我们分别开了两个goroutine执行add()函数，这两个goroutine在修改全局参数X的时候发生了数据竞争，某个goroutine对X的修改会覆盖掉另一个goroutine的修改操作，所以最后结果每次都不一样。</p><h6 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h6><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用sync包中提供的Mutex类型来实现互斥锁。</p><p>sync.Mutex提供了两个方法供我们使用。</p><p>func (m *Mutex) Lock()：获取互斥锁<br>func (m *Mutex) Unlock()：释放互斥锁<br>我们在下面的示例代码中使用互斥锁限制每次只有一个 goroutine 才能修改全局变量x，从而修复上面代码中的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>x <span class="hljs-type">int64</span><br>wg sync.WaitGroup <span class="hljs-comment">// 等待组</span><br>m sync.Mutex <span class="hljs-comment">// 互斥锁</span><br>)<br><br><span class="hljs-comment">// add 对全局变量x执行5000次加1操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<br>m.Lock() <span class="hljs-comment">// 修改x前加锁</span><br>x = x + <span class="hljs-number">1</span><br>m.Unlock() <span class="hljs-comment">// 改完解锁</span><br>&#125;<br>wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">go</span> add()<br><span class="hljs-keyword">go</span> add()<br><br>wg.Wait()<br>fmt.Println(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>将上面的代码编译后多次执行，每一次都会得到预期中的结果——10000。</p><p>使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，<font color="red">唤醒的策略是随机的</font>。</p><h6 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h6><p>sync.RWMutex提供了以下5个方法。<br>func (rw *RWMutex) Lock()：获取写锁<br>func (rw *RWMutex) Unlock()：释放写锁<br>func (rw *RWMutex) RLock()：获取读锁<br>func (rw *RWMutex) RUnlock()：释放读锁<br>func (rw *RWMutex) RLocker() Locker：返回一个实现Locker接口的读写锁<br>读写锁分为两种：读锁和写锁。<br>当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；<br>当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。</p><ul><li>读锁RLock() ，我开始读了，你们也可以来读，但是谁都别写</li><li>写锁Lock() ，我要写了，所有人注意，别做任何操作.<br>下面我们使用代码构造一个读多写少的场景，然后分别使用互斥锁和读写锁查看它们的性能差异。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs awk">var (<br>x       int64<br>wg      sync.WaitGroup<br>mutex   sync.Mutex<br>rwMutex sync.RWMutex<br>)<br><br><span class="hljs-regexp">//</span> writeWithLock 使用互斥锁的写操作<br><span class="hljs-keyword">func</span> writeWithLock() &#123;<br>mutex.Lock() <span class="hljs-regexp">//</span> 加互斥锁<br>x = x + <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Millisecond) <span class="hljs-regexp">//</span> 假设读操作耗时<span class="hljs-number">10</span>毫秒<br>mutex.Unlock()                    <span class="hljs-regexp">//</span> 解互斥锁<br>wg.Done()<br>&#125;<br><br><span class="hljs-regexp">//</span> readWithLock 使用互斥锁的读操作<br><span class="hljs-keyword">func</span> readWithLock() &#123;<br>mutex.Lock()                 <span class="hljs-regexp">//</span> 加互斥锁<br>time.Sleep(time.Millisecond) <span class="hljs-regexp">//</span> 假设读操作耗时<span class="hljs-number">1</span>毫秒<br>mutex.Unlock()               <span class="hljs-regexp">//</span> 释放互斥锁<br>wg.Done()<br>&#125;<br><br><span class="hljs-regexp">//</span> writeWithLock 使用读写互斥锁的写操作<br><span class="hljs-keyword">func</span> writeWithRWLock() &#123;<br>rwMutex.Lock() <span class="hljs-regexp">//</span> 加写锁<br>x = x + <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Millisecond) <span class="hljs-regexp">//</span> 假设读操作耗时<span class="hljs-number">10</span>毫秒<br>rwMutex.Unlock()                  <span class="hljs-regexp">//</span> 释放写锁<br>wg.Done()<br>&#125;<br><br><span class="hljs-regexp">//</span> readWithRWLock 使用读写互斥锁的读操作<br><span class="hljs-keyword">func</span> readWithRWLock() &#123;<br>rwMutex.RLock()              <span class="hljs-regexp">//</span> 加读锁<br>time.Sleep(time.Millisecond) <span class="hljs-regexp">//</span> 假设读操作耗时<span class="hljs-number">1</span>毫秒<br>rwMutex.RUnlock()            <span class="hljs-regexp">//</span> 释放读锁<br>wg.Done()<br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-keyword">do</span>(wf, rf <span class="hljs-keyword">func</span>(), wc, rc int) &#123;<br>start := time.Now()<br><span class="hljs-regexp">//</span> wc个并发写操作<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; wc; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br>go wf()<br>&#125;<br><br><span class="hljs-regexp">//</span>  rc个并发读操作<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; rc; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br>go rf()<br>&#125;<br><br>wg.Wait()<br>cost := time.Since(start)<br>fmt.Printf(<span class="hljs-string">&quot;x:%v cost:%v\n&quot;</span>, x, cost)<br><br>&#125;<br><span class="hljs-keyword">func</span> main() &#123;<br><span class="hljs-keyword">do</span>(writeWithRWLock, readWithRWLock, <span class="hljs-number">10</span>, <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">do</span>(writeWithLock, readWithLock, <span class="hljs-number">10</span>, <span class="hljs-number">1000</span>)<br><span class="hljs-regexp">//</span>x:<span class="hljs-number">10</span> cost:<span class="hljs-number">108.404034</span>ms<br><span class="hljs-regexp">//</span>x:<span class="hljs-number">20</span> cost:<span class="hljs-number">1.238981628</span>s<br>&#125;<br></code></pre></td></tr></table></figure>我们假设每一次读操作都会耗时1ms，而每一次写操作会耗时10ms，我们分别测试使用互斥锁和读写互斥锁执行10次并发写和1000次并发读的耗时数据。<br>从最终的执行结果可以看出，使用读写互斥锁在读多写少的场景下能够极大地提高程序的性能。不过需要注意的是如果一个程序中的读操作和写操作数量级差别不大，那么读写互斥锁的优势就发挥不出来。</li></ul><h6 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h6><p>在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。</p><p>Go语言中的sync包中提供了一个针对只执行一次场景的解决方案——sync.Once，sync.Once只有一个Do方法，其签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Do(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>)<br></code></pre></td></tr></table></figure><p><font color="red">注意</font>：如果要执行的函数f需要传递参数就需要搭配闭包来使用。</p><blockquote><p>加载配置文件示例<br>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> icons map<span class="hljs-selector-attr">[string]</span>image<span class="hljs-selector-class">.Image</span><br><br>func <span class="hljs-built_in">loadIcons</span>() &#123;<br>icons = map<span class="hljs-selector-attr">[string]</span>image.Image&#123;<br><span class="hljs-string">&quot;left&quot;</span>:  <span class="hljs-built_in">loadIcon</span>(<span class="hljs-string">&quot;left.png&quot;</span>),<br><span class="hljs-string">&quot;up&quot;</span>:    <span class="hljs-built_in">loadIcon</span>(<span class="hljs-string">&quot;up.png&quot;</span>),<br><span class="hljs-string">&quot;right&quot;</span>: <span class="hljs-built_in">loadIcon</span>(<span class="hljs-string">&quot;right.png&quot;</span>),<br><span class="hljs-string">&quot;down&quot;</span>:  <span class="hljs-built_in">loadIcon</span>(<span class="hljs-string">&quot;down.png&quot;</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Icon 被多个goroutine调用时不是并发安全的</span><br>func <span class="hljs-built_in">Icon</span>(name string) image<span class="hljs-selector-class">.Image</span> &#123;<br><span class="hljs-keyword">if</span> icons == nil &#123;<br><span class="hljs-built_in">loadIcons</span>()<br>&#125;<br>return icons<span class="hljs-selector-attr">[name]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>多个goroutine 调用loadIcons函数时会在调用时初始化icons的数据，但是每次调用时icons的数据并不一定初始化完成，导致数据访问出错。根据之前的方法我们可以给loadIcons方法添加互斥锁，但是这样又会导致性能问题，因为每个goroutine执行时数据虽然不会出错，但是每次都会重新初始化icons数据。因此我们可以使用<code>sync.Once</code>进行改造：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> icons map<span class="hljs-selector-attr">[string]</span>image<span class="hljs-selector-class">.Image</span><br><br><span class="hljs-selector-tag">var</span> loadIconsOnce sync<span class="hljs-selector-class">.Once</span><br><br>func <span class="hljs-built_in">loadIcons</span>() &#123;<br>icons = map<span class="hljs-selector-attr">[string]</span>image.Image&#123;<br><span class="hljs-string">&quot;left&quot;</span>:  <span class="hljs-built_in">loadIcon</span>(<span class="hljs-string">&quot;left.png&quot;</span>),<br><span class="hljs-string">&quot;up&quot;</span>:    <span class="hljs-built_in">loadIcon</span>(<span class="hljs-string">&quot;up.png&quot;</span>),<br><span class="hljs-string">&quot;right&quot;</span>: <span class="hljs-built_in">loadIcon</span>(<span class="hljs-string">&quot;right.png&quot;</span>),<br><span class="hljs-string">&quot;down&quot;</span>:  <span class="hljs-built_in">loadIcon</span>(<span class="hljs-string">&quot;down.png&quot;</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Icon 是并发安全的</span><br>func <span class="hljs-built_in">Icon</span>(name string) image<span class="hljs-selector-class">.Image</span> &#123;<br>loadIconsOnce<span class="hljs-selector-class">.Do</span>(loadIcons)<br>return icons<span class="hljs-selector-attr">[name]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来只会在第一次初始化时生成数据，且之后的每次调用都会判断是否已经初始化完成，完成即不在初始化直接返回值。<br>这跟单例模式有点相像，所以下面我们来看一个<code>sync.Once</code>实现的单例模式：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">type singleton struct &#123;&#125;<br><br>var<span class="hljs-built_in"> instance </span>*singleton<br>var once sync.Once<br>func GetInstance() *singleton &#123;<br>    once.Do(func() &#123;<br>       <span class="hljs-built_in"> instance </span>= &amp;singleton&#123;&#125;<br>    &#125;)<br>   <span class="hljs-built_in"> return </span>instance<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sync.Once</code> 其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h6 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">Go 语言中内置的 <span class="hljs-keyword">map</span> 不是并发安全的，<br><br><span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> m[key]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">set</span><span class="hljs-params">(key <span class="hljs-type">string</span>, value <span class="hljs-type">int</span>)</span></span> &#123;<br>m[key] = value<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg := sync.WaitGroup&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>key := strconv.Itoa(n)<br>set(key, n)<br>fmt.Printf(<span class="hljs-string">&quot;k=:%v,v:=%v\n&quot;</span>, key, get(key))<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>将上面的代码编译后执行，会报出<code>fatal error: concurrent map writes</code>错误。我们不能在多个 goroutine 中并发对内置的 map 进行读写操作，否则会存在数据竞争问题。<br>像这种场景下就需要为 map 加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版 map——sync.Map。开箱即用表示其不用像内置的 map 一样使用 make 函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。</p><p>func (m *Map) Store(key, value interface{})：存储key-value数据<br>func (m *Map) Load(key interface{}) (value interface{}, ok bool)：查询key对应的value<br>func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)：查询或存储key对应的value<br>func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool)：查询并删除key<br>func (m *Map) Delete(key interface{})：删除key<br>func (m *Map) Range(f func(key, value interface{}) bool)：对map中的每个key-value依次调用f<br>下面的代码示例演示了并发读写sync.Map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 并发安全的map</span><br><span class="hljs-keyword">var</span> m = sync.Map&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg := sync.WaitGroup&#123;&#125;<br><span class="hljs-comment">// 对m执行20个并发的读写操作</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>key := strconv.Itoa(n)<br>m.Store(key, n)         <span class="hljs-comment">// 存储key-value</span><br>value, _ := m.Load(key) <span class="hljs-comment">// 根据key取值</span><br>fmt.Printf(<span class="hljs-string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h6><p>针对整数数据类型（int32、uint32、int64、uint64）我们还可以使用原子操作来保证并发安全，通常直接使用原子操作比使用锁操作效率更高。Go语言中原子操作由内置的标准库sync&#x2F;atomic提供。</p><p><img src="https://image.jokernote.com/golang/WeChat1f7ed5064c81ec3a001f8b8eece09058.png?x-oss-process=image/resize,w_700" alt="图片描述"></p><p>我们填写一个示例来比较下互斥锁和原子操作的性能</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs scss">type Counter interface &#123;<br><span class="hljs-built_in">Inc</span>()<br><span class="hljs-built_in">Load</span>() int64<br>&#125;<br><br><span class="hljs-comment">// 普通版</span><br>type CommonCounter struct &#123;<br>counter int64<br>&#125;<br><br>func (c CommonCounter) <span class="hljs-built_in">Inc</span>() &#123;<br>c<span class="hljs-selector-class">.counter</span>++<br>&#125;<br><br>func (c CommonCounter) <span class="hljs-built_in">Load</span>() int64 &#123;<br>return c<span class="hljs-selector-class">.counter</span><br>&#125;<br><br><span class="hljs-comment">// 互斥锁版</span><br>type MutexCounter struct &#123;<br>counter int64<br>lock    sync<span class="hljs-selector-class">.Mutex</span><br>&#125;<br><br>func (m *MutexCounter) <span class="hljs-built_in">Inc</span>() &#123;<br>m<span class="hljs-selector-class">.lock</span><span class="hljs-selector-class">.Lock</span>()<br>defer m<span class="hljs-selector-class">.lock</span><span class="hljs-selector-class">.Unlock</span>()<br>m<span class="hljs-selector-class">.counter</span>++<br>&#125;<br>func (m *MutexCounter) <span class="hljs-built_in">Load</span>() int64 &#123;<br>m<span class="hljs-selector-class">.lock</span><span class="hljs-selector-class">.Lock</span>()<br>defer m<span class="hljs-selector-class">.lock</span><span class="hljs-selector-class">.Unlock</span>()<br>return m<span class="hljs-selector-class">.counter</span><br>&#125;<br><span class="hljs-comment">// 原子操作版</span><br>type AtomicCounter struct &#123;<br>counter int64<br>&#125;<br>func (a *AtomicCounter) <span class="hljs-built_in">Inc</span>() &#123;<br>atomic<span class="hljs-selector-class">.AddInt64</span>(&amp;a.counter, <span class="hljs-number">1</span>)<br>&#125;<br>func (a *AtomicCounter) <span class="hljs-built_in">Load</span>() int64 &#123;<br>return atomic<span class="hljs-selector-class">.LoadInt64</span>(&amp;a.counter)<br>&#125;<br>func <span class="hljs-built_in">test</span>(c Counter) &#123;<br><span class="hljs-selector-tag">var</span> wg sync<span class="hljs-selector-class">.WaitGroup</span><br>start := time.Now()<br>for i := <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; <span class="hljs-number">1000</span>; <span class="hljs-selector-tag">i</span>++ &#123;<br>wg<span class="hljs-selector-class">.Add</span>(<span class="hljs-number">1</span>)<br>go <span class="hljs-built_in">func</span>() &#123;<br>c<span class="hljs-selector-class">.Inc</span>()<br>wg<span class="hljs-selector-class">.Done</span>()<br>&#125;()<br>&#125;<br>wg<span class="hljs-selector-class">.Wait</span>()<br>end := time.Now()<br>fmt.Println(c.Load(), end.Sub(start))<br>&#125;<br>func <span class="hljs-selector-tag">main</span>() &#123;<br>c1 := CommonCounter&#123;&#125; <span class="hljs-comment">// 非并发安全</span><br><span class="hljs-built_in">test</span>(c1)<br>c2 := MutexCounter&#123;&#125; <span class="hljs-comment">// 使用互斥锁实现并发安全</span><br><span class="hljs-built_in">test</span>(&amp;c2)<br>c3 := AtomicCounter&#123;&#125; <span class="hljs-comment">// 并发安全且比互斥锁效率更高</span><br><span class="hljs-built_in">test</span>(&amp;c3)<br>&#125;<br><span class="hljs-comment">//0 598.714µs </span><br><span class="hljs-comment">//1000 452.944µs</span><br><span class="hljs-comment">//1000 348.842µs</span><br></code></pre></td></tr></table></figure><p>atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者 sync 包的函数&#x2F;类型实现同步更好。</p>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发基础</title>
    <link href="/2022/05/31/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/31/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>在学习GO语言的并发之前，先让我们理解一下并发中的相关概念</p><blockquote><p>进程、线程和协程</p></blockquote><p>进程(process)<br>&amp;emsp;&amp;emsp; 程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。当一个应用程序被启动时，操作系统会为这个应用程序启动一个进程，可以将这个进程看做包含了应用程序在运行时需要用到和维护的各种资源额容器。这些资源包括但不限于内存空间地址、文件、设备的句柄以及线程。一个进程至少是一个执行空间，每个进程的初始线程称为主线程。又因为执行这个线程的空间是应用程序本身的空间，所以当主线程终止时，应用程序也会终止。<br>线程(thred)<br>&amp;emsp;&amp;emsp; 操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位。<br>协程（coroutine）<br>&amp;emsp;&amp;emsp; 非操作系统提供而是由用户自行创建和控制的用户态“线程”，比线程更轻量级。</p><blockquote><p>串行、并发与并行</p></blockquote><p>串行：我们都是先读小学，然后初中，然后高中最后到大学，一切按顺序执行。<br>并发：同一时间内执行多个任务（我同时和爸妈两个人微信聊天）<br>并行：同一时刻执行多个任务（我和我弟弟同时都在和爸妈微信聊天）</p>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang运算基础</title>
    <link href="/2022/05/01/golang%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/01/golang%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h2><p>&amp;:<br>取地址运算符，表示取一个变量的内存地址，同时也属于一元操作符(也叫单目运算符)。</p><p>* :<br>取值运算符，表示取一个变量所指向内存地址中保存的数据，它同时也属于一元操作符(也叫单目运算符)。</p><h3 id="如何区分”-amp-”-“-”到底是逻辑运算符（乘法算术符）还是取地址运算符（取值运算符）？"><a href="#如何区分”-amp-”-“-”到底是逻辑运算符（乘法算术符）还是取地址运算符（取值运算符）？" class="headerlink" title="如何区分”&amp;”, “*”到底是逻辑运算符（乘法算术符）还是取地址运算符（取值运算符）？"></a>如何区分”&amp;”, “*”到底是逻辑运算符（乘法算术符）还是取地址运算符（取值运算符）？</h3><p>如果需要两个变量来进行操作，则是逻辑运算符，比如 a &amp; b 和 a * b，同时需要两个变量，称之为二元运算符，而取地址（取值）运算符只需要一个变量既可，比如 &amp;a 和 *b ，称之为一元运算符。</p><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul><li>前缀是0x或0X为十六进制</li><li>前缀为0的为8进制</li><li>十进制无前缀</li></ul><p>整数可以有一个后缀，是u和l的组合，分别代表 unsigned 和 long ，后缀可以是大小写字母，顺序也随意。</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>&amp;：</p><p>按位与操作，将两个值转化为二进制后进行对比，两位均为1时为1，位数不够时用0从左补充，再将获得的二进制值转化为十进制。</p><p>|：</p><p>按位或操作，将两个值转化为二进制后进行对比，两位有1位为1时为1，位数不够时用0从左补充，再将获得的二进制值转化为十进制。</p><p>^：</p><p>按位异或操作，将两个值转化为二进制后进行对比，两位不一样时为1，其它都为0，位数不够时用0从左补充，再将获得的二进制值转化为十进制。</p><p>&lt;&lt;：</p><p>按位左移操作，左移n位等于乘以2的n次方。</p><p>&gt;&gt;：</p><p>按位右移操作，右移n位等于除以2的n次方。</p><p>&amp;^：</p><p>按位清除操作，比如5&amp;^11，指5转化为二进制时为0101，11为1011。将5的二进制值中为1的值设置为0，剩余位与11的二进制值相应位相同，则得到0100，十进制为4。</p><p>^x：</p><p>取反操作，公式可以为-（x+1），适用于正负数和零。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>每个 const 定义的默认为0，除非显式设置为其他值，后续常量默认值为上一个常量值。如果常量值为 iota ，则都被设置为 iota，iota 有递增效果，所以可以实现枚举。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-literal">iota</span><br>b<br>c<br>d, e, f = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span><br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>GOLANG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GOLANG</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
